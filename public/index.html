<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="优秀不够，你是否无可替代">
<meta property="og:type" content="website">
<meta property="og:title" content="Neil&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Neil&#39;s blog">
<meta property="og:description" content="优秀不够，你是否无可替代">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neil&#39;s blog">
<meta name="twitter:description" content="优秀不够，你是否无可替代">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Neil's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Neil's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Let's start from here</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/17/Android四大组件之BroadCast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/17/Android四大组件之BroadCast/" itemprop="url">Android四大组件之BroadCast</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-17T13:40:28+08:00">
                2018-09-17
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/17/Android四大组件之BroadCast/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/09/17/Android四大组件之BroadCast/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Android四大组件之BroadCast"><a href="#Android四大组件之BroadCast" class="headerlink" title="Android四大组件之BroadCast"></a>Android四大组件之BroadCast</h3><h4 id="一、广播概述"><a href="#一、广播概述" class="headerlink" title="一、广播概述"></a>一、广播概述</h4><p>Android应用可以从Android系统和其他Android应用发送或接收广播消息，是观察者设计模式，即一对多的关系。例如，应用程序还可以发送自定义广播，以通知其他应用程序可能感兴趣的内容（例如，已下载了一些新数据）。</p>
<p>广播是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的广播进行过滤接收并响应的一类组件；</p>
<p>BroadcastReceiver自身并不实现图形用户界面，但是当它收到某个通知后，BroadcastReceiver可以启动Activity作为响应，或者通过NotificationMananger提醒用户，或者启动Service等等。</p>
<p>经常说”发送广播“和”接收广播“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。</p>
<h4 id="二、广播分类"><a href="#二、广播分类" class="headerlink" title="二、广播分类"></a>二、广播分类</h4><p>Android中的BroadCast类型主要分为5类:</p>
<ul>
<li>Normal BroadCast(普通广播)</li>
<li>System BroadCast(系统广播)</li>
<li>Ordered BroadCast(有序广播)</li>
<li>Sticky BroadCast(粘性广播)</li>
<li>Local BroadCast(App应用内广播)</li>
</ul>
<h4 id="三、广播的注册和接收"><a href="#三、广播的注册和接收" class="headerlink" title="三、广播的注册和接收"></a>三、广播的注册和接收</h4><p>广播的注册分为两种：静态注册和动态注册</p>
<h5 id="1-静态注册"><a href="#1-静态注册" class="headerlink" title="1.静态注册"></a>1.静态注册</h5><p>静态注册就是在AndroidManifest中注册，</p>
<pre><code>&lt;receiver 
//此广播接收者类是MyBroadCastReceiver
android:name=&quot;.MyBroadCastReceiver&quot; &gt;
//用于接收网络状态改变时发出的广播
&lt;intent-filter&gt;
    &lt;action android:name=&quot;com.test.mybroadcast&quot; /&gt;
&lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><h5 id="2-动态注册"><a href="#2-动态注册" class="headerlink" title="2.动态注册"></a>2.动态注册</h5><p>需要在代码中实现</p>
<pre><code>IntentFilter intentFilter = new IntentFilter();
intentFilter.addAction(&quot;com.action.myreceiver&quot;);
myReceiver = new MyReceiver();
registerReceiver(myReceiver, intentFilter);
</code></pre><p>注意：动态注册后记得解绑注册。</p>
<h4 id="四、常用广播的简单使用"><a href="#四、常用广播的简单使用" class="headerlink" title="四、常用广播的简单使用"></a>四、常用广播的简单使用</h4><h5 id="1-普通广播"><a href="#1-普通广播" class="headerlink" title="1.普通广播"></a>1.普通广播</h5><p>普通广播的使用，在第三点中已举例说明，不再重复。</p>
<h5 id="2-系统广播"><a href="#2-系统广播" class="headerlink" title="2.系统广播"></a>2.系统广播</h5><p>Android中内置了一些系统广播。常见的有开关机、网络、电话短信、拍照等等。</p>
<p>例如：</p>
<ul>
<li><p>监听网络变化    android.net.conn.CONNECTIVITY_CHANGE</p>
</li>
<li><p>关闭或打开飞行模式    Intent.ACTION_AIRPLANE_MODE_CHANGED</p>
</li>
<li><p>充电时或电量发生变化    Intent.ACTION_BATTERY_CHANGED</p>
</li>
<li><p>电池电量低    Intent.ACTION_BATTERY_LOW</p>
</li>
<li><p>电池电量充足（即从电量低变化到饱满时会发出广播    Intent.ACTION_BATTERY_OKAY</p>
</li>
<li><p>系统启动完成后(仅广播一次)    Intent.ACTION_BOOT_COMPLETED</p>
</li>
<li><p>按下照相时的拍照按键(硬件按键)时    Intent.ACTION_CAMERA_BUTTON</p>
</li>
<li><p>屏幕锁屏    Intent.ACTION_CLOSE_SYSTEM_DIALOGS</p>
</li>
<li><p>设备当前设置被改变时(界面语言、设备方向等)    Intent.ACTION_CONFIGURATION_CHANGED</p>
</li>
<li><p>插入耳机时    Intent.ACTION_HEADSET_PLUG</p>
</li>
<li><p>插入外部储存装置（如SD卡）    Intent.ACTION_MEDIA_CHECKING</p>
</li>
<li><p>成功安装APK    Intent.ACTION_PACKAGE_ADDED</p>
</li>
<li><p>成功删除APK    Intent.ACTION_PACKAGE_REMOVED</p>
</li>
<li><p>重启设备    Intent.ACTION_REBOOT</p>
</li>
<li><p>屏幕被关闭    Intent.ACTION_SCREEN_OFF</p>
</li>
<li><p>屏幕被打开    Intent.ACTION_SCREEN_ON</p>
</li>
<li><p>关闭系统时    Intent.ACTION_SHUTDOWN</p>
</li>
<li><p>重启设备    Intent.ACTION_REBOOT</p>
</li>
</ul>
<h5 id="3-有序广播"><a href="#3-有序广播" class="headerlink" title="3.有序广播"></a>3.有序广播</h5><p>有序广播，也比较常用。发送广播和普通广播的区别是有序广播 通过sendOrderedBroadCast发送广播。<br>有序广播的顺序，体现在广播接收者中，是按照广播接收者的优先顺序来的，优先级在清单文件中广播接收者的intent-filter中通过设置priority属性来定义。<br>例如：</p>
<pre><code>&lt;intent-filter android:priority=&quot;2000&quot;&gt;
</code></pre><p>priority值越大，表示优先级越高</p>
<p>当优先级最高的广播接收者接收到广播后，可以通过setResult继续传递广播，也可以通过abortBroadcast()中断广播的继续传播</p>
<p>代码示例：</p>
<pre><code>&lt;receiver
    android:name=&quot;.MyOrderedReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter android:priority=&quot;1000&quot;&gt;
        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
&lt;receiver
    android:name=&quot;.MySecondOrderedReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter android:priority=&quot;500&quot;&gt;
        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p> 发送广播：</p>
<pre><code>void sendOrderedBroadcast (Intent intent, 
                String receiverPermission)
</code></pre><p>接收广播和普通广播一样，只是按照优先级有接收的先后顺序。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/27/Android过度绘制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/Android过度绘制/" itemprop="url">Android过度绘制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T11:17:23+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/27/Android过度绘制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/07/27/Android过度绘制/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h4><p>android 的渲染主要分为两个组件：1.CPU 2.GPU，由这两者共同完成在屏幕上绘制 。 </p>
<ul>
<li>CPU：中央处理器,它集成了运算,缓冲,控制等单元,包括绘图功能.CPU将对象处理为多维图形,纹理(Bitmaps、Drawables等都是一起打包到统一的纹理)。 </li>
</ul>
<ul>
<li><p>GPU：一个类似于CPU的专门用来处理Graphics的处理器,用来帮助加快格栅化操作,当然,也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 </p>
</li>
<li><p>OpenGL ES：手持嵌入式设备的3DAPI,跨平台的、功能完善的2D和3D图形应用程序接口API,有一套固定渲染管线流程。 </p>
</li>
<li><p>DisplayList：把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 </p>
</li>
<li><p>栅格化：将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上。 </p>
</li>
<li><p>垂直同步VSYNC：让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前，要等待屏幕绘制完成前一帧。下面的三张图分别是GPU和硬件同步所发生的情况,Refresh Rate:屏幕一秒内刷新屏幕的次数,由硬件决定,例如60Hz.而Frame Rate:GPU一秒绘制操作的帧数,单位fps。</p>
<h4 id="二、什么是过度绘制？"><a href="#二、什么是过度绘制？" class="headerlink" title="二、什么是过度绘制？"></a>二、什么是过度绘制？</h4></li>
</ul>
<p>过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源，绘制示意图如下图所示</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blogoverdraw.png" alt="overdraw"></p>
<ul>
<li><p>原色：没有过度绘制 </p>
</li>
<li><p>蓝色：1 次过度绘制 </p>
</li>
<li><p>绿色：2 次过度绘制 </p>
</li>
<li><p>粉色：3 次过度绘制 </p>
</li>
<li><p>红色：4 次及以上过度绘制</p>
</li>
</ul>
<h4 id="三、过度绘制优化"><a href="#三、过度绘制优化" class="headerlink" title="三、过度绘制优化"></a>三、过度绘制优化</h4><h5 id="1-去除Activity自带的默认window背景"><a href="#1-去除Activity自带的默认window背景" class="headerlink" title="1. 去除Activity自带的默认window背景"></a>1. 去除Activity自带的默认window背景</h5><p>一般应用默认继承的主题都会有一个默认的 windowBackground ，比如默认的 Light 主题：</p>
<pre><code>&lt;style name=&quot;Theme.Light&quot;&gt; 
&lt;item name=&quot;isLightTheme&quot;&gt;true&lt;/item&gt; 
&lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;
 ...
  &lt;/style&gt;
</code></pre><p>但是一般界面都会自己设置界面的背景颜色或者列表页则由 item 的背景来决定，所以默认的 Window 背景基本用不上，如果不移除就会导致所有界面都多 1 次绘制。</p>
<p>可以在应用的主题中添加如下的一行属性来移除默认的 Window 背景：</p>
<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
 &lt;!-- 或者 --&gt; 
 &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;
</code></pre><p>或者在 BaseActivity 的 onCreate() 方法中使用下面的代码移除：</p>
<pre><code>getWindow().setBackgroundDrawable(null); 
或者
getWindow().setBackgroundDrawableResource(android.R.color.transparent);
</code></pre><p>移除默认的 Window 背景的工作在项目初期做最好，因为有可能有的界面未设置背景色，这就会导致该界面显示成黑色的背景，如下所示，如果是后期移除的，就需要检查移除默认 Window 背景之后的界面是否显示正常。</p>
<h5 id="2-移除不必要的背景"><a href="#2-移除不必要的背景" class="headerlink" title="2.移除不必要的背景"></a>2.移除不必要的背景</h5><p>还是上面的那个界面，因为移除了默认的 Window 背景，所以在布局中设置背景为白色：</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/主线程的Loop-loop-一直无限循环为什么不会造成ANR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/主线程的Loop-loop-一直无限循环为什么不会造成ANR/" itemprop="url">主线程的Loop.loop()一直无限循环为什么不会造成ANR?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T11:27:35+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/30/主线程的Loop-loop-一直无限循环为什么不会造成ANR/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/05/30/主线程的Loop-loop-一直无限循环为什么不会造成ANR/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR?"></a>什么是ANR?</h5><p>简单来说就是：</p>
<ol>
<li><p>当前事件没有机会得到处理</p>
</li>
<li><p>当前事件正在处理但是没有及时完成</p>
</li>
</ol>
<pre><code>public static void main(String[] args) {
     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);
     SamplingProfilerIntegration.start();

     // CloseGuard defaults to true and can be quite spammy.  We
     // disable it here, but selectively enable it later (via
     // StrictMode) on debug builds, but using DropBox, not logs.
     CloseGuard.setEnabled(false);

     Environment.initForCurrentUser();

     // Set the reporter for event logging in libcore
     EventLogger.setReporter(new EventLoggingReporter());

     AndroidKeyStoreProvider.install();

     // Make sure TrustedCertificateStore looks in the right place for CA certificates
     final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
     TrustedCertificateStore.setDefaultUserDirectory(configDir);

     Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

     Looper.prepareMainLooper();

     ActivityThread thread = new ActivityThread();
     thread.attach(false);

     if (sMainThreadHandler == null) {
         sMainThreadHandler = thread.getHandler();
     }

     if (false) {
         Looper.myLooper().setMessageLogging(new
                 LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
     }

     // End of event ActivityThreadMain.
     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
     Looper.loop();

     throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
 }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android-7-0-so库兼容问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android-7-0-so库兼容问题/" itemprop="url">Android 7.0 so库兼容问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T10:38:07+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/18/Android-7-0-so库兼容问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/05/18/Android-7-0-so库兼容问题/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。</p>
<p>系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png" alt="加密库兼容问题"></p>
<p>发扬面向百度编程的精神，百度到网上相关资料分析。</p>
<p>问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。</p>
<p>解决方案：</p>
<p>可以采用gradle引用更高版本的包，</p>
<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ </p>
<p>或者</p>
<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9’ </p>
<p>对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。</p>
<p>详见：<a href="https://blog.csdn.net/qklnmc/article/details/77967636" target="_blank" rel="external">https://blog.csdn.net/qklnmc/article/details/77967636</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/LruCache源码及原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/LruCache源码及原理分析/" itemprop="url">LruCache源码及原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T17:02:25+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/19/LruCache源码及原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/19/LruCache源码及原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、源码及解析"><a href="#一、源码及解析" class="headerlink" title="一、源码及解析"></a>一、源码及解析</h3><p>因为源码不多，就直接全部贴出来分析。源码及分析如下：</p>
<pre><code>/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.util;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * BEGIN LAYOUTLIB CHANGE
 * This is a custom version that doesn&apos;t use the non standard LinkedHashMap#eldest.
 * END LAYOUTLIB CHANGE
 *
 * A cache that holds strong references to a limited number of values. Each time
 * a value is accessed, it is moved to the head of a queue. When a value is
 * added to a full cache, the value at the end of that queue is evicted and may
 * become eligible for garbage collection.
 *
 * &lt;p&gt;If your cached values hold resources that need to be explicitly released,
 * override {@link #entryRemoved}.
 *
 * &lt;p&gt;If a cache miss should be computed on demand for the corresponding keys,
 * override {@link #create}. This simplifies the calling code, allowing it to
 * assume a value will always be returned, even when there&apos;s a cache miss.
 *
 * &lt;p&gt;By default, the cache size is measured in the number of entries. Override
 * {@link #sizeOf} to size the cache in different units. For example, this cache
 * is limited to 4MiB of bitmaps:
 * &lt;pre&gt;   {@code
 *   int cacheSize = 4 * 1024 * 1024; // 4MiB
 *   LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
 *       protected int sizeOf(String key, Bitmap value) {
 *           return value.getByteCount();
 *       }
 *   }}&lt;/pre&gt;
 *
 * &lt;p&gt;This class is thread-safe. Perform multiple cache operations atomically by
 * synchronizing on the cache: &lt;pre&gt;   {@code
 *   synchronized (cache) {
 *     if (cache.get(key) == null) {
 *         cache.put(key, value);
 *     }
 *   }}&lt;/pre&gt;
 *
 * &lt;p&gt;This class does not allow null to be used as a key or value. A return
 * value of null from {@link #get}, {@link #put} or {@link #remove} is
 * unambiguous: the key was not in the cache.
 *
 * &lt;p&gt;This class appeared in Android 3.1 (Honeycomb MR1); it&apos;s available as part
 * of &lt;a href=&quot;http://developer.android.com/sdk/compatibility-library.html&quot;&gt;Android&apos;s
 * Support Package&lt;/a&gt; for earlier releases.
 */
// note: ssh 
//date: 20170418
public class LruCache&lt;K, V&gt; {
    private final LinkedHashMap&lt;K, V&gt; map;//存放数据的集合

    /** Size of this cache in units. Not necessarily the number of elements. */
    private int size;//当前LruCache的内存占用的大小
    private int maxSize;//Lrucache的最大容量

    private int putCount;//put的次数
    private int createCount;//create的次数
    private int evictionCount;//回收的次数
    private int hitCount;//命中的次数
    private int missCount;//丢失的次数

    /**
     * @param maxSize for caches that do not override {@link #sizeOf}, this is
     *     the maximum number of entries in the cache. For all other caches,
     *     this is the maximum sum of the sizes of the entries in this cache.
     */
    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。
    public LruCache(int maxSize) {
        if (maxSize &lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);
        }
        this.maxSize = maxSize;
        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序
        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);
    }

    /**
     * Sets the size of the cache.
     * @param maxSize The new maximum size.
     *
     * @hide
     */
    //重置最大容量，调用trimToSize来实现
    public void resize(int maxSize) {
        if (maxSize &lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);
        }

        synchronized (this) {
            this.maxSize = maxSize;
        }
        trimToSize(maxSize);
    }

    /**
     * Returns the value for {@code key} if it exists in the cache or can be
     * created by {@code #create}. If a value was returned, it is moved to the
     * head of the queue. This returns null if a value is not cached and cannot
     * be created.
     */
    //通过key获取元素值，如果缓存中存在的话
    public final V get(K key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        V mapValue;
        synchronized (this) {
            mapValue = map.get(key);
            if (mapValue != null) {
                hitCount++;
                return mapValue;
            }
            missCount++;
        }

        /*
         * Attempt to create a value. This may take a long time, and the map
         * may be different when create() returns. If a conflicting value was
         * added to the map while create() was working, we leave that value in
         * the map and release the created value.
         */
        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法
        V createdValue = create(key);
        if (createdValue == null) {
            return null;
        }
        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中
        synchronized (this) {
            createCount++;
            mapValue = map.put(key, createdValue);

            if (mapValue != null) {
                // There was a conflict so undo that last put
                map.put(key, mapValue);
            } else {
                size += safeSizeOf(key, createdValue);
            }
        }

        if (mapValue != null) {
            entryRemoved(false, key, createdValue, mapValue);
            return mapValue;
        } else {
            trimToSize(maxSize);
            return createdValue;
        }
    }

    /**
     * Caches {@code value} for {@code key}. The value is moved to the head of
     * the queue.
     *
     * @return the previous value mapped by {@code key}.
     */
    //向缓存中添加数据
    public final V put(K key, V value) {
        if (key == null || value == null) {
            throw new NullPointerException(&quot;key == null || value == null&quot;);
        }

        V previous;
        synchronized (this) {
            putCount++;
            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1
            previous = map.put(key, value);//Hashmap.put()
            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小
                size -= safeSizeOf(key, previous);
            }
        }

        if (previous != null) {
            entryRemoved(false, key, previous, value);
        }

        trimToSize(maxSize);
        return previous;
    }

    /**
     * @param maxSize the maximum size of the cache before returning. May be -1
     *     to evict even 0-sized elements.
     */
    private void trimToSize(int maxSize) {
        while (true) {//开启死循环
            K key;
            V value;
            synchronized (this) {
                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {
                    throw new IllegalStateException(getClass().getName()
                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);
                }

                if (size &lt;= maxSize) {
                    break;//当已用的缓存小于最大缓存时，推出循环
                }

                // BEGIN LAYOUTLIB CHANGE
                // get the last item in the linked list.
                // This is not efficient, the goal here is to minimize the changes
                // compared to the platform version.
                //否则就在缓存中找到最近最少使用的元素
                Map.Entry&lt;K, V&gt; toEvict = null;
                for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {
                    toEvict = entry;
                }
                // END LAYOUTLIB CHANGE

                if (toEvict == null) {
                    break;
                }

                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);//然后删掉找到的最近最少使用的元素
                size -= safeSizeOf(key, value);//减少了已使用的缓存空间
                evictionCount++;
            }

            entryRemoved(true, key, value, null);
        }
    }

    /**
     * Removes the entry for {@code key} if it exists.
     *
     * @return the previous value mapped by {@code key}.
     */
    //删除元素
    //删去元素，缩减已使用缓存值
    public final V remove(K key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        V previous;
        synchronized (this) {
            previous = map.remove(key);
            if (previous != null) {
                size -= safeSizeOf(key, previous);
            }
        }

        if (previous != null) {
            entryRemoved(false, key, previous, null);
        }

        return previous;
    }

    /**
     * Called for entries that have been evicted or removed. This method is
     * invoked when a value is evicted to make space, removed by a call to
     * {@link #remove}, or replaced by a call to {@link #put}. The default
     * implementation does nothing.
     *
     * &lt;p&gt;The method is called without synchronization: other threads may
     * access the cache while this method is executing.
     *
     * @param evicted true if the entry is being removed to make space, false
     *     if the removal was caused by a {@link #put} or {@link #remove}.
     * @param newValue the new value for {@code key}, if it exists. If non-null,
     *     this removal was caused by a {@link #put}. Otherwise it was caused by
     *     an eviction or a {@link #remove}.
     */
    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}

    /**
     * Called after a cache miss to compute a value for the corresponding key.
     * Returns the computed value or null if no value can be computed. The
     * default implementation returns null.
     *
     * &lt;p&gt;The method is called without synchronization: other threads may
     * access the cache while this method is executing.
     *
     * &lt;p&gt;If a value for {@code key} exists in the cache when this method
     * returns, the created value will be released with {@link #entryRemoved}
     * and discarded. This can occur when multiple threads request the same key
     * at the same time (causing multiple values to be created), or when one
     * thread calls {@link #put} while another is creating a value for the same
     * key.
     */
    protected V create(K key) {
        return null;
    }

    private int safeSizeOf(K key, V value) {
        int result = sizeOf(key, value);
        if (result &lt; 0) {
            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
        }
        return result;
    }

    /**
     * Returns the size of the entry for {@code key} and {@code value} in
     * user-defined units.  The default implementation returns 1 so that size
     * is the number of entries and max size is the maximum number of entries.
     *
     * &lt;p&gt;An entry&apos;s size must not change while it is in the cache.
     */
    protected int sizeOf(K key, V value) {
        return 1;
    }

    /**
     * Clear the cache, calling {@link #entryRemoved} on each removed entry.
     */
    public final void evictAll() {
        trimToSize(-1); // -1 will evict 0-sized elements
    }

    /**
     * For caches that do not override {@link #sizeOf}, this returns the number
     * of entries in the cache. For all other caches, this returns the sum of
     * the sizes of the entries in this cache.
     */
    public synchronized final int size() {
        return size;
    }

    /**
     * For caches that do not override {@link #sizeOf}, this returns the maximum
     * number of entries in the cache. For all other caches, this returns the
     * maximum sum of the sizes of the entries in this cache.
     */
    public synchronized final int maxSize() {
        return maxSize;
    }

    /**
     * Returns the number of times {@link #get} returned a value that was
     * already present in the cache.
     */
    public synchronized final int hitCount() {
        return hitCount;
    }

    /**
     * Returns the number of times {@link #get} returned null or required a new
     * value to be created.
     */
    public synchronized final int missCount() {
        return missCount;
    }

    /**
     * Returns the number of times {@link #create(Object)} returned a value.
     */
    public synchronized final int createCount() {
        return createCount;
    }

    /**
     * Returns the number of times {@link #put} was called.
     */
    public synchronized final int putCount() {
        return putCount;
    }

    /**
     * Returns the number of values that have been evicted.
     */
    public synchronized final int evictionCount() {
        return evictionCount;
    }

    /**
     * Returns a copy of the current contents of the cache, ordered from least
     * recently accessed to most recently accessed.
     */
    public synchronized final Map&lt;K, V&gt; snapshot() {
        return new LinkedHashMap&lt;K, V&gt;(map);
    }

    @Override public synchronized final String toString() {
        int accesses = hitCount + missCount;
        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
        return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,
                maxSize, hitCount, missCount, hitPercent);
    }
}
</code></pre><p>以上就是全部源码和分析注释。</p>
<h3 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h3><p>举个例子，图片缓存：</p>
<pre><code>private static class BitmapLruCache extends LruCache&lt;String, Bitmap&gt; {
        public BitmapLruCache() {
            // 构造方法传入当前应用可用最大内存的八分之一
            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));
        }

        @Override
        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写
        protected int sizeOf(String key, Bitmap value) {
            return value.getByteCount() / 1024;
        }

        @Override
        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写
        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap
                newValue) {
            super.entryRemoved(evicted, key, oldValue, newValue);
        }

        @Override
        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作
        protected Bitmap create(String key) {
            return super.create(key);
        }
    }
</code></pre><ul>
<li><p>1.初始化</p>
<pre><code>LruCache&lt;String, Bitmap&gt; mLruCache = new BitmapLruCache();
</code></pre></li>
<li><p>2.将图片写入缓存中</p>
<pre><code>mLruCache.put(key, bitmap);
</code></pre></li>
<li><p>3.从缓存中读取图片</p>
<pre><code>mLruCache.get(key, bitmap);
</code></pre></li>
<li><p>4.将图片从缓存中删除</p>
<pre><code>mLruCache.remove(key);
</code></pre></li>
</ul>
<p>使用还是很简单的。</p>
<h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>LruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?<br>因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。</p>
<p>看一下LinkedHashMap的构造方法，</p>
<pre><code>/**
     * Constructs a new {@code LinkedHashMap} instance with the specified
     * capacity, load factor and a flag specifying the ordering behavior.
     *
     * @param initialCapacity
     *            the initial capacity of this hash map.
     * @param loadFactor
     *            the initial load factor.
     * @param accessOrder
     *            {@code true} if the ordering should be done based on the last
     *            access (from least-recently accessed to most-recently
     *            accessed), and {@code false} if the ordering should be the
     *            order in which the entries were inserted.
     * @throws IllegalArgumentException
     *             when the capacity is less than zero or the load factor is
     *             less or equal to zero.
     */
    public LinkedHashMap(
            int initialCapacity, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor);
        init();
        this.accessOrder = accessOrder;
    }
</code></pre><p>参数在LruCache中已经分析过了，再说一遍具体含义。</p>
<p>initialCapacity：这个哈希表的初始容量</p>
<p>loadFactor：加载因子</p>
<p>accessOrder：true,访问顺序；false,插入顺序。</p>
<p>其实很简单。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Neil Liu" />
          <p class="site-author-name" itemprop="name">Neil Liu</p>
           
              <p class="site-description motion-element" itemprop="description">优秀不够，你是否无可替代</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/GitHublsh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Neil Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 93292, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/93292/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  

  

  

</body>
</html>
