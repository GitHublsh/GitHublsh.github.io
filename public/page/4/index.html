<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="优秀不够，你是否无可替代">
<meta property="og:type" content="website">
<meta property="og:title" content="Neil&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Neil&#39;s blog">
<meta property="og:description" content="优秀不够，你是否无可替代">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neil&#39;s blog">
<meta name="twitter:description" content="优秀不够，你是否无可替代">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>Neil's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Neil's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Let's start from here</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/Android四大组件之Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/Android四大组件之Service/" itemprop="url">Android四大组件之Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T10:09:43+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/16/Android四大组件之Service/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/16/Android四大组件之Service/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、Service简介"><a href="#一、Service简介" class="headerlink" title="一、Service简介"></a>一、Service简介</h3><h5 id="Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。"><a href="#Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。" class="headerlink" title="Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。"></a>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</h5><h6 id="服务基本上分为两种形式："><a href="#服务基本上分为两种形式：" class="headerlink" title="服务基本上分为两种形式："></a>服务基本上分为两种形式：</h6><ul>
<li><p>启动</p>
<ul>
<li>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</li>
</ul>
</li>
<li><p>绑定</p>
<ul>
<li>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</li>
</ul>
<p>两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>
<p>–</p>
<p>需要注意的是：</p>
<p>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>
<p>–</p>
</li>
</ul>
<h3 id="二、如何创建"><a href="#二、如何创建" class="headerlink" title="二、如何创建"></a>二、如何创建</h3><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><p>要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：</p>
<ul>
<li><p>onStartCommand()</p>
<ul>
<li>当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）</li>
</ul>
</li>
<li><p>onBind()</p>
<ul>
<li>当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。</li>
</ul>
</li>
<li><p>onCreate()</p>
<ul>
<li>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</li>
</ul>
</li>
</ul>
<ul>
<li><p>onDestory()</p>
<ul>
<li>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</li>
</ul>
</li>
</ul>
<p>######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。</p>
<p>######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<p>仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务</p>
<h4 id="2-清单文件中声明服务"><a href="#2-清单文件中声明服务" class="headerlink" title="2.清单文件中声明服务"></a>2.清单文件中声明服务</h4><p>如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。</p>
<p>要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：</application></service></p>
<pre><code>&lt;manifest ... &gt;
  ...
  &lt;application ... &gt;
      &lt;service android:name=&quot;.ExampleService&quot; /&gt;
      ...
  &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><p>还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。</service></p>
<p>为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。</p>
<p>此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。</p>
<h4 id="3-创建启动服务"><a href="#3-创建启动服务" class="headerlink" title="3. 创建启动服务"></a>3. 创建启动服务</h4><p>启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。</p>
<p>服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。</p>
<p>应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。</p>
<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。</p>
<p>–</p>
<p>注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。</p>
<p>–</p>
<p>两种方式：</p>
<ul>
<li><p>Service</p>
<ul>
<li>这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。</li>
</ul>
</li>
<li><p>IntentService</p>
<ul>
<li>这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。</li>
</ul>
</li>
</ul>
<h4 id="4-IntentService"><a href="#4-IntentService" class="headerlink" title="4.IntentService"></a>4.IntentService</h4><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li><p>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</p>
</li>
<li><p>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。</p>
</li>
<li><p>在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。</p>
</li>
<li><p>提供 onBind() 的默认实现（返回 null）。</p>
</li>
<li><p>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</p>
</li>
</ul>
<p>综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p>
<p>举个例子：</p>
<pre><code>public class HelloIntentService extends IntentService {

  /**
   * A constructor is required, and must call the super IntentService(String)
   * constructor with a name for the worker thread.
   */
  public HelloIntentService() {
      super(&quot;HelloIntentService&quot;);
  }

  /**
   * The IntentService calls this method from the default worker thread with
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // Normally we would do some work here, like download a file.
      // For our sample, we just sleep for 5 seconds.
      try {
          Thread.sleep(5000);
      } catch (InterruptedException e) {
          // Restore interrupt status.
          Thread.currentThread().interrupt();
      }
  }
}
</code></pre><p>只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>两种方式的生命周期如下：</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png" alt="service_lifecycle"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/Activity的四种启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/Activity的四种启动模式/" itemprop="url">Activity的四种启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T14:33:26+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/15/Activity的四种启动模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/15/Activity的四种启动模式/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为基础回顾~</p>
<h4 id="一、Activity的四种启动模式简介"><a href="#一、Activity的四种启动模式简介" class="headerlink" title="一、Activity的四种启动模式简介"></a>一、Activity的四种启动模式简介</h4><p>Activity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。</p>
<p>如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：</p>
<pre><code>&lt;activity android:name=&quot;com.app.TestActivity&quot; android:launchMode=&quot;standard&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><h4 id="二、四种模式详解"><a href="#二、四种模式详解" class="headerlink" title="二、四种模式详解"></a>二、四种模式详解</h4><ul>
<li>standard</li>
</ul>
<p>standard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。</p>
<ul>
<li>singletop</li>
</ul>
<p>singletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。</p>
<ul>
<li>singletask</li>
</ul>
<p>singletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。</p>
<p>那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。</p>
<p>需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。</p>
<ul>
<li>singleInstance</li>
</ul>
<p>singleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/13/Android性能优化（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/Android性能优化（一）/" itemprop="url">Android性能优化（一）布局优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T14:57:40+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/13/Android性能优化（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/13/Android性能优化（一）/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>布局优化主要的思想就一点：减少布局的层级</p>
<p>常用的优化方式有三种：</p>
<h4 id="一、-lt-include-gt-标签"><a href="#一、-lt-include-gt-标签" class="headerlink" title="一、&lt;include&gt;标签"></a>一、&lt;include&gt;标签</h4><p>&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。</p>
<p>举个例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;include layout=&quot;@layout/include_comm_new_topbar_header&quot;/&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/courier_recycle_change_record&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>引用的部分，</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;ComTopBarNew xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolBar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;@dimen/com_toolbar_height&quot;
    android:background=&quot;@color/comm_color18&quot;
    /&gt;
</code></pre><p>需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。</p>
<h4 id="二、-lt-merge-gt-标签"><a href="#二、-lt-merge-gt-标签" class="headerlink" title="二、&lt;merge&gt;标签"></a>二、&lt;merge&gt;标签</h4><p>&lt;merge>标签，一般是和<include>标签配合使用的，举个例子：</include></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;merge&gt;

    &lt;View style=&quot;@style/Comm.Divider.Horizontal&quot; /&gt;
&lt;/merge&gt;
</code></pre><p>使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。</merge></p>
<h4 id="三、-lt-ViewStub-gt-标签"><a href="#三、-lt-ViewStub-gt-标签" class="headerlink" title="三、 &lt;ViewStub&gt;标签"></a>三、 &lt;ViewStub&gt;标签</h4><p>&lt;ViewStub>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<viewstub>标签以减少内存使用量，加快渲染速度。<viewstub>标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。</viewstub></viewstub></p>
<p>在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。</p>
<p>举个例子：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot;  
    tools:context=&quot;.MainActivity&quot;&gt;  

    &lt;Button  
        android:id=&quot;@+id/btn_show&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Show&quot;/&gt;  
    &lt;Button  
        android:id=&quot;@+id/btn_gone&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;GONE&quot;/&gt;  

    &lt;LinearLayout  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ViewStub  
        android:id=&quot;@+id/viewstub&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:layout=&quot;@layout/view&quot;/&gt;  
    &lt;/LinearLayout&gt;  

&lt;/LinearLayout&gt; 
</code></pre><p>在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>
<p>那么如何加载？</p>
<p>两种方式：</p>
<ul>
<li><p>stub.setVisibility(View.VISIBLE); </p>
</li>
<li><p>stub.inflate();</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/11/Bitmap-OOM解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/Bitmap-OOM解决方案/" itemprop="url">Bitmap OOM解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T18:11:28+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/11/Bitmap-OOM解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/11/Bitmap-OOM解决方案/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Bitmap-OOM常用解决方案"><a href="#Bitmap-OOM常用解决方案" class="headerlink" title="Bitmap OOM常用解决方案"></a>Bitmap OOM常用解决方案</h3><hr>
<ol>
<li><p>在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。</p>
</li>
<li><p>在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。</p>
</li>
<li><p>通过设置Options.inPreferredConfig值来降低内存消耗：<br>  默认为ARGB_8888: 每个像素4字节. 共32位。<br>  Alpha_8: 只保存透明度，共8位，1字节。<br>  ARGB_4444: 共16位，2字节。<br>  RGB_565:共16位，2字节。<br>  如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。</p>
</li>
<li><p>通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。</p>
</li>
<li><p>设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。</p>
<ul>
<li><p>inPurgeable:</p>
<ul>
<li>设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。</li>
<li>设置为False时，表示不能被回收。</li>
</ul>
</li>
<li><p>inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为</p>
<ul>
<li>false，该参数无意义；</li>
<li>True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。</p>
</li>
</ol>
<p>区别：<br>decodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。</p>
<p>decodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。</p>
<pre><code>decodeStream调用过程：
      decodeStream(InputStream,Rect,Options) -&gt; nativeDecodeAsset/nativeDecodeStream
decodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。
      decodeResource(Resource,resId,Options)  -&gt; decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -&gt; decodeStream() (在完成Decode后，进行finishDecode操作)
      finishDecode() -&gt; Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -&gt; Bitmap.createBitmap()
</code></pre><p>以上方法的组合使用，合理避免OOM错误。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/IPC基础概念介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/IPC基础概念介绍/" itemprop="url">IPC基础概念介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T09:09:50+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/22/IPC基础概念介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/03/22/IPC基础概念介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h2><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><ul>
<li><p>IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。</p>
</li>
<li><p>线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。</p>
</li>
</ul>
<h4 id="二、Android中的多进程模式"><a href="#二、Android中的多进程模式" class="headerlink" title="二、Android中的多进程模式"></a>二、Android中的多进程模式</h4><p> Android中开启多进程的方法：</p>
<pre><code>&lt;activity android:name=&quot;.BinderOneActivity&quot;
           android:process=&quot;com.neil.binder.one&quot;/&gt;
&lt;activity android:name=&quot;.BinderTwoActivity&quot;
           android:process=&quot;com.neil.binder.two&quot;/&gt;
&lt;activity android:name=&quot;.BinderThreeActivity&quot;
           android:process=&quot;com.neil.binder.three&quot;/&gt;
</code></pre><p>在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。</p>
<p>日志输出：</p>
<pre><code>u0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo
u0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one
u0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two
u0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three
</code></pre><p>Android系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。</p>
<h4 id="三、序列化和反序列化"><a href="#三、序列化和反序列化" class="headerlink" title="三、序列化和反序列化"></a>三、序列化和反序列化</h4><ol>
<li>序列化</li>
</ol>
<p>由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。</p>
<p>指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程</p>
<ol>
<li>反序列化</li>
</ol>
<p>反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。</p>
<p>  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。<br>  <br>  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程
  </p>
<h4 id="四、Serializable-VS-Parcelable"><a href="#四、Serializable-VS-Parcelable" class="headerlink" title="四、Serializable VS  Parcelable"></a>四、Serializable VS  Parcelable</h4><h5 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1. Serializable"></a>1. Serializable</h5><p>Serializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。</p>
<p>举个例子：</p>
<pre><code>import java.io.Serializable;

public class Person implements Serializable {

    **
     * 生成序列号标识
     */
    private static final long serialVersionUID = -2083503801443301445L;

    private String firstName;
    private String lastName;
    private int age;


    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }


    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre><p>实现的Serializable接口并声明了序列化标识serialVersionUID。</p>
<p>那么serialVersionUID有什么作用呢？</p>
<p>实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。</p>
<p>那么既然自动生成我们是不是可以不写？</p>
<p>由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。</p>
<p>例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。</p>
<h5 id="2-Parcelable"><a href="#2-Parcelable" class="headerlink" title="2. Parcelable"></a>2. Parcelable</h5><p>Parcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。</p>
<p>举个例子：</p>
<pre><code>import android.os.Parcel;
import android.os.Parcelable;

public class Person implements Parcelable {

    private String firstName;
    private String lastName;
    private int age;


    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }


    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }


    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.firstName);
        dest.writeString(this.lastName);
        dest.writeInt(this.age);
    }

    protected Person(Parcel in) {
            this.firstName = in.readString();
            this.lastName = in.readString();
            this.age = in.readInt();
        }

    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() {
        @Override
        public Person createFromParcel(Parcel source) {
            return new Person(source);
        }

        @Override
        public Person[] newArray(int size) {
            return new Person[size];
        }
    };
}
</code></pre><p>相对Serializable稍显复杂。</p>
<ul>
<li><p>Parcelable.Creator</p>
<ul>
<li>必须实现的接口。</li>
</ul>
</li>
<li><p>T createFromParcel (Parcel source)</p>
<ul>
<li>创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层</li>
</ul>
</li>
<li><p>T[] newArray (int size)</p>
<ul>
<li>创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。</li>
</ul>
</li>
<li><p>void writeToParcel (Parcel dest, </p>
<pre><code>int flags)
</code></pre></li>
</ul>
<pre><code>* 将当前对象写入序列化结构中
</code></pre><p>简单概括下：</p>
<p> 序列化过程中，需要实现序列化和反序列化以及内容描述。</p>
<p> writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。</p>
<p> 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。</p>
<h5 id="3-Serializable-和-Parcelable-异同"><a href="#3-Serializable-和-Parcelable-异同" class="headerlink" title="3. Serializable 和 Parcelable 异同"></a>3. Serializable 和 Parcelable 异同</h5><ul>
<li><p>都能序列化，都可用于Intent传递数据</p>
</li>
<li><p>Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。</p>
</li>
<li><p>Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。</p>
</li>
<li><p>Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Neil Liu" />
          <p class="site-author-name" itemprop="name">Neil Liu</p>
           
              <p class="site-description motion-element" itemprop="description">优秀不够，你是否无可替代</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/GitHublsh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Neil Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 93292, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/93292/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  

  

  

</body>
</html>
