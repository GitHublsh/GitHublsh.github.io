<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="优秀不够，你是否无可替代">
<meta property="og:type" content="website">
<meta property="og:title" content="Neil&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Neil&#39;s blog">
<meta property="og:description" content="优秀不够，你是否无可替代">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neil&#39;s blog">
<meta name="twitter:description" content="优秀不够，你是否无可替代">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Neil's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Neil's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Let's start from here</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/11/Bitmap-OOM解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/Bitmap-OOM解决方案/" itemprop="url">Bitmap OOM解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T18:11:28+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/11/Bitmap-OOM解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/11/Bitmap-OOM解决方案/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Bitmap-OOM常用解决方案"><a href="#Bitmap-OOM常用解决方案" class="headerlink" title="Bitmap OOM常用解决方案"></a>Bitmap OOM常用解决方案</h3><hr>
<ol>
<li><p>在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。</p>
</li>
<li><p>在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。</p>
</li>
<li><p>通过设置Options.inPreferredConfig值来降低内存消耗：<br>  默认为ARGB_8888: 每个像素4字节. 共32位。<br>  Alpha_8: 只保存透明度，共8位，1字节。<br>  ARGB_4444: 共16位，2字节。<br>  RGB_565:共16位，2字节。<br>  如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。</p>
</li>
<li><p>通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。</p>
</li>
<li><p>设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。</p>
<ul>
<li><p>inPurgeable:</p>
<ul>
<li>设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。</li>
<li>设置为False时，表示不能被回收。</li>
</ul>
</li>
<li><p>inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为</p>
<ul>
<li>false，该参数无意义；</li>
<li>True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。</p>
</li>
</ol>
<p>区别：<br>decodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。</p>
<p>decodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。</p>
<pre><code>decodeStream调用过程：
      decodeStream(InputStream,Rect,Options) -&gt; nativeDecodeAsset/nativeDecodeStream
decodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。
      decodeResource(Resource,resId,Options)  -&gt; decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -&gt; decodeStream() (在完成Decode后，进行finishDecode操作)
      finishDecode() -&gt; Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -&gt; Bitmap.createBitmap()
</code></pre><p>以上方法的组合使用，合理避免OOM错误。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/IPC基础概念介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/IPC基础概念介绍/" itemprop="url">IPC基础概念介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T09:09:50+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/22/IPC基础概念介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/03/22/IPC基础概念介绍/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h2><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><ul>
<li><p>IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。</p>
</li>
<li><p>线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。</p>
</li>
</ul>
<h4 id="二、Android中的多进程模式"><a href="#二、Android中的多进程模式" class="headerlink" title="二、Android中的多进程模式"></a>二、Android中的多进程模式</h4><p> Android中开启多进程的方法：</p>
<pre><code>&lt;activity android:name=&quot;.BinderOneActivity&quot;
           android:process=&quot;com.neil.binder.one&quot;/&gt;
&lt;activity android:name=&quot;.BinderTwoActivity&quot;
           android:process=&quot;com.neil.binder.two&quot;/&gt;
&lt;activity android:name=&quot;.BinderThreeActivity&quot;
           android:process=&quot;com.neil.binder.three&quot;/&gt;
</code></pre><p>在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。</p>
<p>日志输出：</p>
<pre><code>u0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo
u0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one
u0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two
u0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three
</code></pre><p>Android系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。</p>
<h4 id="三、序列化和反序列化"><a href="#三、序列化和反序列化" class="headerlink" title="三、序列化和反序列化"></a>三、序列化和反序列化</h4><ol>
<li>序列化</li>
</ol>
<p>由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。</p>
<p>指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程</p>
<ol>
<li>反序列化</li>
</ol>
<p>反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。</p>
<p>  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。<br>  <br>  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程
  </p>
<h4 id="四、Serializable-VS-Parcelable"><a href="#四、Serializable-VS-Parcelable" class="headerlink" title="四、Serializable VS  Parcelable"></a>四、Serializable VS  Parcelable</h4><h5 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1. Serializable"></a>1. Serializable</h5><p>Serializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。</p>
<p>举个例子：</p>
<pre><code>import java.io.Serializable;

public class Person implements Serializable {

    **
     * 生成序列号标识
     */
    private static final long serialVersionUID = -2083503801443301445L;

    private String firstName;
    private String lastName;
    private int age;


    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }


    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre><p>实现的Serializable接口并声明了序列化标识serialVersionUID。</p>
<p>那么serialVersionUID有什么作用呢？</p>
<p>实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。</p>
<p>那么既然自动生成我们是不是可以不写？</p>
<p>由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。</p>
<p>例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。</p>
<h5 id="2-Parcelable"><a href="#2-Parcelable" class="headerlink" title="2. Parcelable"></a>2. Parcelable</h5><p>Parcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。</p>
<p>举个例子：</p>
<pre><code>import android.os.Parcel;
import android.os.Parcelable;

public class Person implements Parcelable {

    private String firstName;
    private String lastName;
    private int age;


    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }


    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }


    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.firstName);
        dest.writeString(this.lastName);
        dest.writeInt(this.age);
    }

    protected Person(Parcel in) {
            this.firstName = in.readString();
            this.lastName = in.readString();
            this.age = in.readInt();
        }

    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() {
        @Override
        public Person createFromParcel(Parcel source) {
            return new Person(source);
        }

        @Override
        public Person[] newArray(int size) {
            return new Person[size];
        }
    };
}
</code></pre><p>相对Serializable稍显复杂。</p>
<ul>
<li><p>Parcelable.Creator</p>
<ul>
<li>必须实现的接口。</li>
</ul>
</li>
<li><p>T createFromParcel (Parcel source)</p>
<ul>
<li>创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层</li>
</ul>
</li>
<li><p>T[] newArray (int size)</p>
<ul>
<li>创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。</li>
</ul>
</li>
<li><p>void writeToParcel (Parcel dest, </p>
<pre><code>int flags)
</code></pre></li>
</ul>
<pre><code>* 将当前对象写入序列化结构中
</code></pre><p>简单概括下：</p>
<p> 序列化过程中，需要实现序列化和反序列化以及内容描述。</p>
<p> writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。</p>
<p> 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。</p>
<h5 id="3-Serializable-和-Parcelable-异同"><a href="#3-Serializable-和-Parcelable-异同" class="headerlink" title="3. Serializable 和 Parcelable 异同"></a>3. Serializable 和 Parcelable 异同</h5><ul>
<li><p>都能序列化，都可用于Intent传递数据</p>
</li>
<li><p>Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。</p>
</li>
<li><p>Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。</p>
</li>
<li><p>Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/HashMap的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/HashMap的实现原理/" itemprop="url">HashMap的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T15:59:34+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/20/HashMap的实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/03/20/HashMap的实现原理/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h3><h4 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h4><p>HashMap 是一个散列表，允许使用空值和空键。存储的内容是键值对(key-value)映射</p>
<p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p>在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p>
<p>继承关系：</p>
<pre><code>java.lang.Object
   ↳     java.util.AbstractMap&lt;K, V&gt;
         ↳     java.util.HashMap&lt;K, V&gt;

public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable { }
</code></pre><h4 id="HashMap的构造函数"><a href="#HashMap的构造函数" class="headerlink" title="HashMap的构造函数"></a>HashMap的构造函数</h4><pre><code>// 默认构造函数。
HashMap()

// 指定“容量大小”的构造函数
HashMap(int capacity)

// 指定“容量大小”和“加载因子”的构造函数
HashMap(int capacity, float loadFactor)

// 包含“子Map”的构造函数
HashMap(Map&lt;? extends K, ? extends V&gt; map)
</code></pre><h4 id="HashMap的整体结构"><a href="#HashMap的整体结构" class="headerlink" title="HashMap的整体结构"></a>HashMap的整体结构</h4><p><img src="http://ot29getcp.bkt.clouddn.com//blog/hashmapbuild.png" alt="HashMap整体结构"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/Android常见内存泄漏及解决办法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/Android常见内存泄漏及解决办法/" itemprop="url">Android常见内存泄漏及解决办法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T16:12:15+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/13/Android常见内存泄漏及解决办法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/03/13/Android常见内存泄漏及解决办法/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h4 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h4><p>主要几点：</p>
<ul>
<li>Context</li>
<li>内部类（handler等）</li>
<li>Cursor</li>
<li>Adapter</li>
<li>Bitmap</li>
</ul>
<h5 id="1-单例造成的内存泄漏"><a href="#1-单例造成的内存泄漏" class="headerlink" title="1. 单例造成的内存泄漏"></a>1. 单例造成的内存泄漏</h5><p>单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 </p>
<p>例如：</p>
<pre><code>public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context;
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
</code></pre><ul>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 </li>
</ul>
<ul>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 </li>
</ul>
<p> 正确的单例：</p>
<pre><code> public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context.getApplicationContext();
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
</code></pre><h5 id="2-非静态内部类创建静态实例造成的内存泄漏"><a href="#2-非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="2.非静态内部类创建静态实例造成的内存泄漏"></a>2.非静态内部类创建静态实例造成的内存泄漏</h5><p>在实际的项目开发中，有时候我们需要频繁的启动某个页面（Activity），启动的时候总是需要初始化一些资源，为了避免重复创建相同资源，常常会使用静态对象去保存这些值，这种情况下，也很容易照成内存泄漏。我们举个例子：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private static TestResource mResource = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if(mManager == null){
            mManager = new TestResource();
        }
        //...
    }
    private class TestResource {
        //...
    }
}
</code></pre><p>我们创建了一个静态的资源对象mResouce，每次Activity启动都会使用该资源的数据，避免了重复创建。但是这样会造成内存泄漏</p>
<ul>
<li>非静态内部类默认会持有外部类的引用</li>
<li>又使用了该非静态内部类创建了一个静态的实例</li>
<li>该静态实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>将内部类testResource改成静态内部类</li>
<li>将testResource抽取出来，封装成一个单例</li>
</ul>
<pre><code>public class MainActivity extends AppCompatActivity {
    private static TestResource mResource = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if(mManager == null){
            mManager = new TestResource();
        }
        //...
    }
    private static class TestResource {
        //...
    }
}
</code></pre><h5 id="3-handler导致内存泄漏"><a href="#3-handler导致内存泄漏" class="headerlink" title="3. handler导致内存泄漏"></a>3. handler导致内存泄漏</h5><p>举例如下</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            //...
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        loadData();
    }
    private void loadData(){
        //...request
        Message message = Message.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏</p>
<p>解决方案：</p>
<ul>
<li>在Activity onDestroy的时候，也应该对消息队列中的消息移除。</li>
</ul>
<pre><code> @Override
public void onDestroy() {
   //三种均可
    mHandler.removeMessages(message);
    mHandler.removeCallbacks(Runnable);
    mHandler.removeCallbacksAndMessages(null);
}
</code></pre><h5 id="4-资源未关闭导致内存泄漏"><a href="#4-资源未关闭导致内存泄漏" class="headerlink" title="4.资源未关闭导致内存泄漏"></a>4.资源未关闭导致内存泄漏</h5><p>BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/30/Android-Gradle构建入门(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/30/Android-Gradle构建入门(一)/" itemprop="url">Android Gradle构建入门 (一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-30T17:35:50+08:00">
                2017-12-30
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/30/Android-Gradle构建入门(一)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/12/30/Android-Gradle构建入门(一)/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Android-Gradle入门"><a href="#Android-Gradle入门" class="headerlink" title="Android Gradle入门"></a>Android Gradle入门</h3><h5 id="本文内容来自官方文档整理"><a href="#本文内容来自官方文档整理" class="headerlink" title="本文内容来自官方文档整理"></a>本文内容来自官方文档整理</h5><h4 id="一、查看生成的Gradle文件列表"><a href="#一、查看生成的Gradle文件列表" class="headerlink" title="一、查看生成的Gradle文件列表"></a>一、查看生成的Gradle文件列表</h4><p>默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png" alt="“asmodel”"></p>
<p>Android项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。</p>
<p>在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。</p>
<ul>
<li>settings.gradle</li>
</ul>
<p>Gradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：</p>
<pre><code>include &apos;:app&apos;
</code></pre><p>这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。</p>
<ul>
<li>gradle-wrapper.properties</li>
</ul>
<p>gradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：</p>
<pre><code>distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
</code></pre><p>前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。</p>
<p>最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）</p>
<h4 id="二、查看整个项目的build-gradle"><a href="#二、查看整个项目的build-gradle" class="headerlink" title="二、查看整个项目的build.gradle"></a>二、查看整个项目的build.gradle</h4><p>project的build.geadle文件：</p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {

    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;


        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>各个代码块具体作用：</p>
<ol>
<li>buildscript - 下载插件</li>
<li>dependencies - 标识Android插件</li>
<li>allproject -     top-level and module projects的配置</li>
<li>task clean - 特设任务</li>
</ol>
<p>Gradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。</p>
<p>当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。</p>
<p>allprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从<a href="https://jcenter.bintray.com上的公共Bintray" target="_blank" rel="external">https://jcenter.bintray.com上的公共Bintray</a> Artifactory存储库的google或jcenter下载。</p>
<p>最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。</p>
<h4 id="三、查看app-module的build-gradle"><a href="#三、查看app-module的build-gradle" class="headerlink" title="三、查看app module的build.gradle"></a>三、查看app module的build.gradle</h4><p>看一下 build.gradle</p>
<pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 26
    defaultConfig {
        applicationId &quot;com.example.liushihan.gradletest&quot;
        minSdkVersion 21
        targetSdkVersion 26
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}

dependencies {
    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;
    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;
    testImplementation &apos;junit:junit:4.12&apos;
    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;
    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;
}
</code></pre><p>第一行：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
</code></pre><p>应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。</p>
<pre><code>android {
    compileSdkVersion 26
    defaultConfig {
        applicationId &quot;com.example.liushihan.gradletest&quot;
        minSdkVersion 21
        targetSdkVersion 26
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}
</code></pre><p>对这些属性进行简单的介绍：</p>
<ul>
<li>compileSdkVersion：Android SDK版本</li>
<li>defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。<ul>
<li>applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。</li>
</ul>
</li>
</ul>
<pre><code>* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。


* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。

* versionName:版本名称值用于自己的内部版本跟踪。

* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。
</code></pre><p>在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。</p>
<pre><code>buildTypes {
      release {
          minifyEnabled false
          proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
      }
  }
</code></pre><p>继续往下面看，就是这个应用程序所依赖的库</p>
<pre><code>dependencies {
    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;
    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;
    testImplementation &apos;junit:junit:4.12&apos;
    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;
    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;
}
</code></pre><p>配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。</p>
<p>testImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。</p>
<p>androidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。</p>
<pre><code>fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
</code></pre><p>是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中</p>
<pre><code>com.android.support:appcompat-v7:26.1.0
</code></pre><p>将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。</p>
<pre><code>com.android.support.constraint:constraint-layout:1.0.2
</code></pre><p>将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。</p>
<h4 id="四、运行标准的Gradle任务"><a href="#四、运行标准的Gradle任务" class="headerlink" title="四、运行标准的Gradle任务"></a>四、运行标准的Gradle任务</h4><p>Android Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建</p>
<pre><code>$ ./gradlew build
</code></pre><p>构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.</p>
<ul>
<li>可以在命令行中显示在项目中使用的support-annotations模块的版本。</li>
</ul>
<p>执行命令，可以看到结果：</p>
<pre><code>$ ./gradlew :app:dependencies --configuration releaseCompileClasspath
:app:dependencies

------------------------------------------------------------
Project :app
------------------------------------------------------------

releaseCompileClasspath - Resolved configuration for compilation for variant: release
+--- com.android.support:appcompat-v7:26.1.0
|    +--- com.android.support:support-annotations:26.1.0
|    +--- com.android.support:support-v4:26.1.0
|    |    +--- com.android.support:support-compat:26.1.0
|    |    |    +--- com.android.support:support-annotations:26.1.0
|    |    |    \--- android.arch.lifecycle:runtime:1.0.0
|    |    |         +--- android.arch.lifecycle:common:1.0.0
|    |    |         \--- android.arch.core:common:1.0.0
|    |    +--- com.android.support:support-media-compat:26.1.0
|    |    |    +--- com.android.support:support-annotations:26.1.0
|    |    |    \--- com.android.support:support-compat:26.1.0 (*)
|    |    +--- com.android.support:support-core-utils:26.1.0
|    |    |    +--- com.android.support:support-annotations:26.1.0
|    |    |    \--- com.android.support:support-compat:26.1.0 (*)
|    |    +--- com.android.support:support-core-ui:26.1.0
|    |    |    +--- com.android.support:support-annotations:26.1.0
|    |    |    \--- com.android.support:support-compat:26.1.0 (*)
|    |    \--- com.android.support:support-fragment:26.1.0
|    |         +--- com.android.support:support-compat:26.1.0 (*)
|    |         +--- com.android.support:support-core-ui:26.1.0 (*)
|    |         \--- com.android.support:support-core-utils:26.1.0 (*)
|    +--- com.android.support:support-vector-drawable:26.1.0
|    |    +--- com.android.support:support-annotations:26.1.0
|    |    \--- com.android.support:support-compat:26.1.0 (*)
|    \--- com.android.support:animated-vector-drawable:26.1.0
|         +--- com.android.support:support-vector-drawable:26.1.0 (*)
|         \--- com.android.support:support-core-ui:26.1.0 (*)
\--- com.android.support.constraint:constraint-layout:1.0.2
     \--- com.android.support.constraint:constraint-layout-solver:1.0.2

(*) - dependencies omitted (listed previously)


BUILD SUCCESSFUL
</code></pre><p>从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库</p>
<ul>
<li>另一种方式查看所需的版本</li>
</ul>
<p>执行命令及结果：</p>
<pre><code>$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath
:app:dependencyInsight
com.android.support:support-annotations:26.1.0
+--- com.android.support:appcompat-v7:26.1.0
|    \--- releaseCompileClasspath
+--- com.android.support:support-compat:26.1.0
|    +--- com.android.support:support-vector-drawable:26.1.0
|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)
|    |    \--- com.android.support:animated-vector-drawable:26.1.0
|    |         \--- com.android.support:appcompat-v7:26.1.0 (*)
|    +--- com.android.support:support-v4:26.1.0
|    |    \--- com.android.support:appcompat-v7:26.1.0 (*)
|    +--- com.android.support:support-media-compat:26.1.0
|    |    \--- com.android.support:support-v4:26.1.0 (*)
|    +--- com.android.support:support-fragment:26.1.0
|    |    \--- com.android.support:support-v4:26.1.0 (*)
|    +--- com.android.support:support-core-utils:26.1.0
|    |    +--- com.android.support:support-v4:26.1.0 (*)
|    |    \--- com.android.support:support-fragment:26.1.0 (*)
|    \--- com.android.support:support-core-ui:26.1.0
|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)
|         +--- com.android.support:support-v4:26.1.0 (*)
|         \--- com.android.support:support-fragment:26.1.0 (*)
+--- com.android.support:support-core-ui:26.1.0 (*)
+--- com.android.support:support-core-utils:26.1.0 (*)
+--- com.android.support:support-media-compat:26.1.0 (*)
\--- com.android.support:support-vector-drawable:26.1.0 (*)

(*) - dependencies omitted (listed previously)


BUILD SUCCESSFUL
</code></pre><p>这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。</p>
<h4 id="五、查看Gradle窗口可执行的命令"><a href="#五、查看Gradle窗口可执行的命令" class="headerlink" title="五、查看Gradle窗口可执行的命令"></a>五、查看Gradle窗口可执行的命令</h4><p><img src="http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png" alt="&quot;gradle window&quot;"></p>
<p>可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：</p>
<pre><code>Executing tasks: [signingReport]

Configuration on demand is an incubating feature.
:app:signingReport
Variant: release
Config: none
----------
Variant: releaseUnitTest
Config: none
----------
Variant: debug
Config: debug
Store: /Users/liushihan/.android/debug.keystore
Alias: AndroidDebugKey
MD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B
SHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87
Valid until: 2047年5月1日 星期三
----------
Variant: debugAndroidTest
Config: debug
Store: /Users/liushihan/.android/debug.keystore
Alias: AndroidDebugKey
MD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B
SHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87
Valid until: 2047年5月1日 星期三
----------
Variant: debugUnitTest
Config: debug
Store: /Users/liushihan/.android/debug.keystore
Alias: AndroidDebugKey
MD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B
SHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87
Valid until: 2047年5月1日 星期三
----------

BUILD SUCCESSFUL in 14s
1 actionable task: 1 executed
</code></pre><p>从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）</p>
<p>下面的install，可以通过installDebug来安装应用</p>
<p>也可用命令行来执行：</p>
<pre><code>$ ./gradlew installDebug
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Neil Liu" />
          <p class="site-author-name" itemprop="name">Neil Liu</p>
           
              <p class="site-description motion-element" itemprop="description">优秀不够，你是否无可替代</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/GitHublsh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Neil Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 93292, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/93292/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  

  

  

</body>
</html>
