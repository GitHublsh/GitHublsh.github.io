<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="优秀不够，你是否无可替代">
<meta property="og:type" content="website">
<meta property="og:title" content="Neil&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Neil&#39;s blog">
<meta property="og:description" content="优秀不够，你是否无可替代">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neil&#39;s blog">
<meta name="twitter:description" content="优秀不够，你是否无可替代">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Neil's blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Neil's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Let's start from here</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android-7-0-so库兼容问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android-7-0-so库兼容问题/" itemprop="url">Android 7.0 so库兼容问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T10:38:07+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/18/Android-7-0-so库兼容问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/05/18/Android-7-0-so库兼容问题/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。</p>
<p>系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png" alt="加密库兼容问题"></p>
<p>发扬面向百度编程的精神，百度到网上相关资料分析。</p>
<p>问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。</p>
<p>解决方案：</p>
<p>可以采用gradle引用更高版本的包，</p>
<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ </p>
<p>或者</p>
<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9’ </p>
<p>对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。</p>
<p>详见：<a href="https://blog.csdn.net/qklnmc/article/details/77967636" target="_blank" rel="external">https://blog.csdn.net/qklnmc/article/details/77967636</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/LruCache源码及原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/LruCache源码及原理分析/" itemprop="url">LruCache源码及原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T17:02:25+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/19/LruCache源码及原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/19/LruCache源码及原理分析/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、源码及解析"><a href="#一、源码及解析" class="headerlink" title="一、源码及解析"></a>一、源码及解析</h3><p>因为源码不多，就直接全部贴出来分析。源码及分析如下：</p>
<pre><code>/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.util;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * BEGIN LAYOUTLIB CHANGE
 * This is a custom version that doesn&apos;t use the non standard LinkedHashMap#eldest.
 * END LAYOUTLIB CHANGE
 *
 * A cache that holds strong references to a limited number of values. Each time
 * a value is accessed, it is moved to the head of a queue. When a value is
 * added to a full cache, the value at the end of that queue is evicted and may
 * become eligible for garbage collection.
 *
 * &lt;p&gt;If your cached values hold resources that need to be explicitly released,
 * override {@link #entryRemoved}.
 *
 * &lt;p&gt;If a cache miss should be computed on demand for the corresponding keys,
 * override {@link #create}. This simplifies the calling code, allowing it to
 * assume a value will always be returned, even when there&apos;s a cache miss.
 *
 * &lt;p&gt;By default, the cache size is measured in the number of entries. Override
 * {@link #sizeOf} to size the cache in different units. For example, this cache
 * is limited to 4MiB of bitmaps:
 * &lt;pre&gt;   {@code
 *   int cacheSize = 4 * 1024 * 1024; // 4MiB
 *   LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
 *       protected int sizeOf(String key, Bitmap value) {
 *           return value.getByteCount();
 *       }
 *   }}&lt;/pre&gt;
 *
 * &lt;p&gt;This class is thread-safe. Perform multiple cache operations atomically by
 * synchronizing on the cache: &lt;pre&gt;   {@code
 *   synchronized (cache) {
 *     if (cache.get(key) == null) {
 *         cache.put(key, value);
 *     }
 *   }}&lt;/pre&gt;
 *
 * &lt;p&gt;This class does not allow null to be used as a key or value. A return
 * value of null from {@link #get}, {@link #put} or {@link #remove} is
 * unambiguous: the key was not in the cache.
 *
 * &lt;p&gt;This class appeared in Android 3.1 (Honeycomb MR1); it&apos;s available as part
 * of &lt;a href=&quot;http://developer.android.com/sdk/compatibility-library.html&quot;&gt;Android&apos;s
 * Support Package&lt;/a&gt; for earlier releases.
 */
// note: ssh 
//date: 20170418
public class LruCache&lt;K, V&gt; {
    private final LinkedHashMap&lt;K, V&gt; map;//存放数据的集合

    /** Size of this cache in units. Not necessarily the number of elements. */
    private int size;//当前LruCache的内存占用的大小
    private int maxSize;//Lrucache的最大容量

    private int putCount;//put的次数
    private int createCount;//create的次数
    private int evictionCount;//回收的次数
    private int hitCount;//命中的次数
    private int missCount;//丢失的次数

    /**
     * @param maxSize for caches that do not override {@link #sizeOf}, this is
     *     the maximum number of entries in the cache. For all other caches,
     *     this is the maximum sum of the sizes of the entries in this cache.
     */
    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。
    public LruCache(int maxSize) {
        if (maxSize &lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);
        }
        this.maxSize = maxSize;
        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序
        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);
    }

    /**
     * Sets the size of the cache.
     * @param maxSize The new maximum size.
     *
     * @hide
     */
    //重置最大容量，调用trimToSize来实现
    public void resize(int maxSize) {
        if (maxSize &lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);
        }

        synchronized (this) {
            this.maxSize = maxSize;
        }
        trimToSize(maxSize);
    }

    /**
     * Returns the value for {@code key} if it exists in the cache or can be
     * created by {@code #create}. If a value was returned, it is moved to the
     * head of the queue. This returns null if a value is not cached and cannot
     * be created.
     */
    //通过key获取元素值，如果缓存中存在的话
    public final V get(K key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        V mapValue;
        synchronized (this) {
            mapValue = map.get(key);
            if (mapValue != null) {
                hitCount++;
                return mapValue;
            }
            missCount++;
        }

        /*
         * Attempt to create a value. This may take a long time, and the map
         * may be different when create() returns. If a conflicting value was
         * added to the map while create() was working, we leave that value in
         * the map and release the created value.
         */
        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法
        V createdValue = create(key);
        if (createdValue == null) {
            return null;
        }
        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中
        synchronized (this) {
            createCount++;
            mapValue = map.put(key, createdValue);

            if (mapValue != null) {
                // There was a conflict so undo that last put
                map.put(key, mapValue);
            } else {
                size += safeSizeOf(key, createdValue);
            }
        }

        if (mapValue != null) {
            entryRemoved(false, key, createdValue, mapValue);
            return mapValue;
        } else {
            trimToSize(maxSize);
            return createdValue;
        }
    }

    /**
     * Caches {@code value} for {@code key}. The value is moved to the head of
     * the queue.
     *
     * @return the previous value mapped by {@code key}.
     */
    //向缓存中添加数据
    public final V put(K key, V value) {
        if (key == null || value == null) {
            throw new NullPointerException(&quot;key == null || value == null&quot;);
        }

        V previous;
        synchronized (this) {
            putCount++;
            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1
            previous = map.put(key, value);//Hashmap.put()
            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小
                size -= safeSizeOf(key, previous);
            }
        }

        if (previous != null) {
            entryRemoved(false, key, previous, value);
        }

        trimToSize(maxSize);
        return previous;
    }

    /**
     * @param maxSize the maximum size of the cache before returning. May be -1
     *     to evict even 0-sized elements.
     */
    private void trimToSize(int maxSize) {
        while (true) {//开启死循环
            K key;
            V value;
            synchronized (this) {
                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {
                    throw new IllegalStateException(getClass().getName()
                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);
                }

                if (size &lt;= maxSize) {
                    break;//当已用的缓存小于最大缓存时，推出循环
                }

                // BEGIN LAYOUTLIB CHANGE
                // get the last item in the linked list.
                // This is not efficient, the goal here is to minimize the changes
                // compared to the platform version.
                //否则就在缓存中找到最近最少使用的元素
                Map.Entry&lt;K, V&gt; toEvict = null;
                for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {
                    toEvict = entry;
                }
                // END LAYOUTLIB CHANGE

                if (toEvict == null) {
                    break;
                }

                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);//然后删掉找到的最近最少使用的元素
                size -= safeSizeOf(key, value);//减少了已使用的缓存空间
                evictionCount++;
            }

            entryRemoved(true, key, value, null);
        }
    }

    /**
     * Removes the entry for {@code key} if it exists.
     *
     * @return the previous value mapped by {@code key}.
     */
    //删除元素
    //删去元素，缩减已使用缓存值
    public final V remove(K key) {
        if (key == null) {
            throw new NullPointerException(&quot;key == null&quot;);
        }

        V previous;
        synchronized (this) {
            previous = map.remove(key);
            if (previous != null) {
                size -= safeSizeOf(key, previous);
            }
        }

        if (previous != null) {
            entryRemoved(false, key, previous, null);
        }

        return previous;
    }

    /**
     * Called for entries that have been evicted or removed. This method is
     * invoked when a value is evicted to make space, removed by a call to
     * {@link #remove}, or replaced by a call to {@link #put}. The default
     * implementation does nothing.
     *
     * &lt;p&gt;The method is called without synchronization: other threads may
     * access the cache while this method is executing.
     *
     * @param evicted true if the entry is being removed to make space, false
     *     if the removal was caused by a {@link #put} or {@link #remove}.
     * @param newValue the new value for {@code key}, if it exists. If non-null,
     *     this removal was caused by a {@link #put}. Otherwise it was caused by
     *     an eviction or a {@link #remove}.
     */
    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}

    /**
     * Called after a cache miss to compute a value for the corresponding key.
     * Returns the computed value or null if no value can be computed. The
     * default implementation returns null.
     *
     * &lt;p&gt;The method is called without synchronization: other threads may
     * access the cache while this method is executing.
     *
     * &lt;p&gt;If a value for {@code key} exists in the cache when this method
     * returns, the created value will be released with {@link #entryRemoved}
     * and discarded. This can occur when multiple threads request the same key
     * at the same time (causing multiple values to be created), or when one
     * thread calls {@link #put} while another is creating a value for the same
     * key.
     */
    protected V create(K key) {
        return null;
    }

    private int safeSizeOf(K key, V value) {
        int result = sizeOf(key, value);
        if (result &lt; 0) {
            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
        }
        return result;
    }

    /**
     * Returns the size of the entry for {@code key} and {@code value} in
     * user-defined units.  The default implementation returns 1 so that size
     * is the number of entries and max size is the maximum number of entries.
     *
     * &lt;p&gt;An entry&apos;s size must not change while it is in the cache.
     */
    protected int sizeOf(K key, V value) {
        return 1;
    }

    /**
     * Clear the cache, calling {@link #entryRemoved} on each removed entry.
     */
    public final void evictAll() {
        trimToSize(-1); // -1 will evict 0-sized elements
    }

    /**
     * For caches that do not override {@link #sizeOf}, this returns the number
     * of entries in the cache. For all other caches, this returns the sum of
     * the sizes of the entries in this cache.
     */
    public synchronized final int size() {
        return size;
    }

    /**
     * For caches that do not override {@link #sizeOf}, this returns the maximum
     * number of entries in the cache. For all other caches, this returns the
     * maximum sum of the sizes of the entries in this cache.
     */
    public synchronized final int maxSize() {
        return maxSize;
    }

    /**
     * Returns the number of times {@link #get} returned a value that was
     * already present in the cache.
     */
    public synchronized final int hitCount() {
        return hitCount;
    }

    /**
     * Returns the number of times {@link #get} returned null or required a new
     * value to be created.
     */
    public synchronized final int missCount() {
        return missCount;
    }

    /**
     * Returns the number of times {@link #create(Object)} returned a value.
     */
    public synchronized final int createCount() {
        return createCount;
    }

    /**
     * Returns the number of times {@link #put} was called.
     */
    public synchronized final int putCount() {
        return putCount;
    }

    /**
     * Returns the number of values that have been evicted.
     */
    public synchronized final int evictionCount() {
        return evictionCount;
    }

    /**
     * Returns a copy of the current contents of the cache, ordered from least
     * recently accessed to most recently accessed.
     */
    public synchronized final Map&lt;K, V&gt; snapshot() {
        return new LinkedHashMap&lt;K, V&gt;(map);
    }

    @Override public synchronized final String toString() {
        int accesses = hitCount + missCount;
        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
        return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,
                maxSize, hitCount, missCount, hitPercent);
    }
}
</code></pre><p>以上就是全部源码和分析注释。</p>
<h3 id="二、简单使用"><a href="#二、简单使用" class="headerlink" title="二、简单使用"></a>二、简单使用</h3><p>举个例子，图片缓存：</p>
<pre><code>private static class BitmapLruCache extends LruCache&lt;String, Bitmap&gt; {
        public BitmapLruCache() {
            // 构造方法传入当前应用可用最大内存的八分之一
            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));
        }

        @Override
        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写
        protected int sizeOf(String key, Bitmap value) {
            return value.getByteCount() / 1024;
        }

        @Override
        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写
        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap
                newValue) {
            super.entryRemoved(evicted, key, oldValue, newValue);
        }

        @Override
        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作
        protected Bitmap create(String key) {
            return super.create(key);
        }
    }
</code></pre><ul>
<li><p>1.初始化</p>
<pre><code>LruCache&lt;String, Bitmap&gt; mLruCache = new BitmapLruCache();
</code></pre></li>
<li><p>2.将图片写入缓存中</p>
<pre><code>mLruCache.put(key, bitmap);
</code></pre></li>
<li><p>3.从缓存中读取图片</p>
<pre><code>mLruCache.get(key, bitmap);
</code></pre></li>
<li><p>4.将图片从缓存中删除</p>
<pre><code>mLruCache.remove(key);
</code></pre></li>
</ul>
<p>使用还是很简单的。</p>
<h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>LruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?<br>因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。</p>
<p>看一下LinkedHashMap的构造方法，</p>
<pre><code>/**
     * Constructs a new {@code LinkedHashMap} instance with the specified
     * capacity, load factor and a flag specifying the ordering behavior.
     *
     * @param initialCapacity
     *            the initial capacity of this hash map.
     * @param loadFactor
     *            the initial load factor.
     * @param accessOrder
     *            {@code true} if the ordering should be done based on the last
     *            access (from least-recently accessed to most-recently
     *            accessed), and {@code false} if the ordering should be the
     *            order in which the entries were inserted.
     * @throws IllegalArgumentException
     *             when the capacity is less than zero or the load factor is
     *             less or equal to zero.
     */
    public LinkedHashMap(
            int initialCapacity, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor);
        init();
        this.accessOrder = accessOrder;
    }
</code></pre><p>参数在LruCache中已经分析过了，再说一遍具体含义。</p>
<p>initialCapacity：这个哈希表的初始容量</p>
<p>loadFactor：加载因子</p>
<p>accessOrder：true,访问顺序；false,插入顺序。</p>
<p>其实很简单。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/Android四大组件之Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/Android四大组件之Service/" itemprop="url">Android四大组件之Service</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T10:09:43+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/16/Android四大组件之Service/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/16/Android四大组件之Service/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、Service简介"><a href="#一、Service简介" class="headerlink" title="一、Service简介"></a>一、Service简介</h3><h5 id="Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。"><a href="#Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。" class="headerlink" title="Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。"></a>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</h5><h6 id="服务基本上分为两种形式："><a href="#服务基本上分为两种形式：" class="headerlink" title="服务基本上分为两种形式："></a>服务基本上分为两种形式：</h6><ul>
<li><p>启动</p>
<ul>
<li>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</li>
</ul>
</li>
<li><p>绑定</p>
<ul>
<li>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</li>
</ul>
<p>两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>
<p>–</p>
<p>需要注意的是：</p>
<p>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>
<p>–</p>
</li>
</ul>
<h3 id="二、如何创建"><a href="#二、如何创建" class="headerlink" title="二、如何创建"></a>二、如何创建</h3><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><p>要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：</p>
<ul>
<li><p>onStartCommand()</p>
<ul>
<li>当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）</li>
</ul>
</li>
<li><p>onBind()</p>
<ul>
<li>当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。</li>
</ul>
</li>
<li><p>onCreate()</p>
<ul>
<li>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</li>
</ul>
</li>
</ul>
<ul>
<li><p>onDestory()</p>
<ul>
<li>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</li>
</ul>
</li>
</ul>
<p>######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。</p>
<p>######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>
<p>仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务</p>
<h4 id="2-清单文件中声明服务"><a href="#2-清单文件中声明服务" class="headerlink" title="2.清单文件中声明服务"></a>2.清单文件中声明服务</h4><p>如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。</p>
<p>要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：</application></service></p>
<pre><code>&lt;manifest ... &gt;
  ...
  &lt;application ... &gt;
      &lt;service android:name=&quot;.ExampleService&quot; /&gt;
      ...
  &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><p>还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。</service></p>
<p>为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。</p>
<p>此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。</p>
<h4 id="3-创建启动服务"><a href="#3-创建启动服务" class="headerlink" title="3. 创建启动服务"></a>3. 创建启动服务</h4><p>启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。</p>
<p>服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。</p>
<p>应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。</p>
<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。</p>
<p>–</p>
<p>注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。</p>
<p>–</p>
<p>两种方式：</p>
<ul>
<li><p>Service</p>
<ul>
<li>这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。</li>
</ul>
</li>
<li><p>IntentService</p>
<ul>
<li>这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。</li>
</ul>
</li>
</ul>
<h4 id="4-IntentService"><a href="#4-IntentService" class="headerlink" title="4.IntentService"></a>4.IntentService</h4><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li><p>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</p>
</li>
<li><p>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。</p>
</li>
<li><p>在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。</p>
</li>
<li><p>提供 onBind() 的默认实现（返回 null）。</p>
</li>
<li><p>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</p>
</li>
</ul>
<p>综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p>
<p>举个例子：</p>
<pre><code>public class HelloIntentService extends IntentService {

  /**
   * A constructor is required, and must call the super IntentService(String)
   * constructor with a name for the worker thread.
   */
  public HelloIntentService() {
      super(&quot;HelloIntentService&quot;);
  }

  /**
   * The IntentService calls this method from the default worker thread with
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // Normally we would do some work here, like download a file.
      // For our sample, we just sleep for 5 seconds.
      try {
          Thread.sleep(5000);
      } catch (InterruptedException e) {
          // Restore interrupt status.
          Thread.currentThread().interrupt();
      }
  }
}
</code></pre><p>只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>两种方式的生命周期如下：</p>
<p><img src="http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png" alt="service_lifecycle"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/Activity的四种启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/Activity的四种启动模式/" itemprop="url">Activity的四种启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T14:33:26+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/15/Activity的四种启动模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/15/Activity的四种启动模式/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为基础回顾~</p>
<h4 id="一、Activity的四种启动模式简介"><a href="#一、Activity的四种启动模式简介" class="headerlink" title="一、Activity的四种启动模式简介"></a>一、Activity的四种启动模式简介</h4><p>Activity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。</p>
<p>如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：</p>
<pre><code>&lt;activity android:name=&quot;com.app.TestActivity&quot; android:launchMode=&quot;standard&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><h4 id="二、四种模式详解"><a href="#二、四种模式详解" class="headerlink" title="二、四种模式详解"></a>二、四种模式详解</h4><ul>
<li>standard</li>
</ul>
<p>standard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。</p>
<ul>
<li>singletop</li>
</ul>
<p>singletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。</p>
<ul>
<li>singletask</li>
</ul>
<p>singletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。</p>
<p>那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。</p>
<p>需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。</p>
<ul>
<li>singleInstance</li>
</ul>
<p>singleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/13/Android性能优化（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Neil Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Neil's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/Android性能优化（一）/" itemprop="url">Android性能优化（一）布局优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T14:57:40+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/13/Android性能优化（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/04/13/Android性能优化（一）/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>布局优化主要的思想就一点：减少布局的层级</p>
<p>常用的优化方式有三种：</p>
<h4 id="一、-lt-include-gt-标签"><a href="#一、-lt-include-gt-标签" class="headerlink" title="一、&lt;include&gt;标签"></a>一、&lt;include&gt;标签</h4><p>&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。</p>
<p>举个例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;include layout=&quot;@layout/include_comm_new_topbar_header&quot;/&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/courier_recycle_change_record&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>引用的部分，</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;ComTopBarNew xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolBar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;@dimen/com_toolbar_height&quot;
    android:background=&quot;@color/comm_color18&quot;
    /&gt;
</code></pre><p>需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。</p>
<h4 id="二、-lt-merge-gt-标签"><a href="#二、-lt-merge-gt-标签" class="headerlink" title="二、&lt;merge&gt;标签"></a>二、&lt;merge&gt;标签</h4><p>&lt;merge>标签，一般是和<include>标签配合使用的，举个例子：</include></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;merge&gt;

    &lt;View style=&quot;@style/Comm.Divider.Horizontal&quot; /&gt;
&lt;/merge&gt;
</code></pre><p>使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。</merge></p>
<h4 id="三、-lt-ViewStub-gt-标签"><a href="#三、-lt-ViewStub-gt-标签" class="headerlink" title="三、 &lt;ViewStub&gt;标签"></a>三、 &lt;ViewStub&gt;标签</h4><p>&lt;ViewStub>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<viewstub>标签以减少内存使用量，加快渲染速度。<viewstub>标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。</viewstub></viewstub></p>
<p>在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。</p>
<p>举个例子：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot;  
    tools:context=&quot;.MainActivity&quot;&gt;  

    &lt;Button  
        android:id=&quot;@+id/btn_show&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Show&quot;/&gt;  
    &lt;Button  
        android:id=&quot;@+id/btn_gone&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;GONE&quot;/&gt;  

    &lt;LinearLayout  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ViewStub  
        android:id=&quot;@+id/viewstub&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:layout=&quot;@layout/view&quot;/&gt;  
    &lt;/LinearLayout&gt;  

&lt;/LinearLayout&gt; 
</code></pre><p>在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>
<p>那么如何加载？</p>
<p>两种方式：</p>
<ul>
<li><p>stub.setVisibility(View.VISIBLE); </p>
</li>
<li><p>stub.inflate();</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Neil Liu" />
          <p class="site-author-name" itemprop="name">Neil Liu</p>
           
              <p class="site-description motion-element" itemprop="description">优秀不够，你是否无可替代</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/GitHublsh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Neil Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 93292, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/93292/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  

  

  

</body>
</html>
