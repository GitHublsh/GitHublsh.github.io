{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/request.png","path":"images/request.png","modified":1,"renderable":0},{"_id":"source/images/httpmessage.jpg","path":"images/httpmessage.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/WechatIMG5.jpeg","path":"images/WechatIMG5.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/WechatIMG3.jpeg","path":"images/WechatIMG3.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/images/WechatIMG7.jpeg","path":"images/WechatIMG7.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/bugsnag.png","path":"images/bugsnag.png","modified":1,"renderable":0},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"23a5c4b02d6e9ae946724516ee32281d9046d55f","modified":1503756385000},{"_id":"themes/next/.DS_Store","hash":"fc1358a4a2cb46e67c42d93f3179bb5f43416b9f","modified":1501138706000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1500888035000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1500888035000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1500888035000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1500888035000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1500888035000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1500888035000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1500888035000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1500888035000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1500888035000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1500888035000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1500888035000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1500888035000},{"_id":"themes/next/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1500888035000},{"_id":"themes/next/_config.yml","hash":"94d9161368513d155379293ae7803cd14bd17a60","modified":1501150632000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1500888035000},{"_id":"themes/next/package.json","hash":"6b5bfec48776ddf9c03811b1ff2cb2b615eccc88","modified":1500888035000},{"_id":"source/_posts/Android-MVPB.md","hash":"c84144c36338c8c4c87d234df24754a666191750","modified":1500888035000},{"_id":"source/_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","hash":"a24524f56b574c616cafdf934e42deadc5d36aa4","modified":1500888035000},{"_id":"source/_posts/Github-hexo搭建个人博客（3）.md","hash":"a3c4302a7e59ab2518203eb800fc487c4e795f02","modified":1500888035000},{"_id":"source/_posts/Git提交index.lock问题解决.md","hash":"0e01f071afcfcc2b4d87480e1d6e8dd3cfd210a2","modified":1500888035000},{"_id":"source/_posts/Android屏幕适配解决方案(1).md","hash":"47c1ed23619177e44209c0a0117e0e1c77a17cb2","modified":1500888035000},{"_id":"source/_posts/HTTP需要知道的知识点-补充.md","hash":"4275825346833c3bc845ab6221fbea4f5f4745d3","modified":1500888035000},{"_id":"source/_posts/Hexo+Github搭建个人博客（1）.md","hash":"431bf6b793cd93cf67bde8ae52ce1765d8d40e76","modified":1500888035000},{"_id":"source/_posts/OkHttp3源码学习（1）.md","hash":"a99973feb23bcd833e57602f671a7218ddba2bd4","modified":1501146224000},{"_id":"source/_posts/Hexo-Github搭建个人博客（2）.md","hash":"52952333d46f03f11a6f6407a251c1c65c8cdafc","modified":1500888035000},{"_id":"source/_posts/Hexo-Github搭建个人博客（4）.md","hash":"b7aa7ecf8f3679099815a7ab36a1a8f8dc4422a0","modified":1500890317000},{"_id":"source/_posts/OkHttp3源码学习（2）.md","hash":"9d68f5c576c8e8626f6e3aede9c8ab48947925ed","modified":1501146633000},{"_id":"source/_posts/OkHttp3源码学习（3）.md","hash":"87d033a27bd7ffc20422502b3c9c9b1346e3dbf2","modified":1501150745000},{"_id":"source/_posts/RxJava2-0-一.md","hash":"1261abf6419332f16ab043c04fa420ac5a9c5463","modified":1502796496000},{"_id":"source/_posts/RxJava2-0-三-变换操作.md","hash":"7528f3ac49fc438097b17038498ec50bf0cc2c13","modified":1503492511000},{"_id":"source/_posts/RxJava2-0-二.md","hash":"848ea20cc140d276e97eacf4d691c790b3ee0b59","modified":1502870152000},{"_id":"source/_posts/RxJava2-0-四-过滤操作.md","hash":"7e5541eef46178897d262ab3518d8d2bf46105f6","modified":1503674265000},{"_id":"source/_posts/自定义View-一.md","hash":"de5c8e2ce1c3643a900d1cde26e8b775b1088f6a","modified":1503845122000},{"_id":"source/_posts/Set集合使用注意tips.md","hash":"f85007dfe3208a04cef2362399f26ad80a549c2a","modified":1500888035000},{"_id":"source/_posts/关于HTTP需要理解的知识点.md","hash":"cb482ddc907156d5596697ad6a14e4561ac31430","modified":1500888035000},{"_id":"source/_posts/hello-world.md","hash":"d0a3314df13f207ed6b91e6d3f32510d7840992c","modified":1500888035000},{"_id":"source/_posts/设计模式之路（1）-简单工厂模式.md","hash":"1c9eb0cc17b5dbfca4570406d82c0a9299f16eb1","modified":1500888035000},{"_id":"source/_posts/设计模式之路（2）单一职责原则.md","hash":"312fc33429c2ffdaea870f9d00ba24c497ff89ff","modified":1500888035000},{"_id":"source/_posts/设计模式之路（4）装饰者模式.md","hash":"9e0583420972cd6a812f84e1ab48978a4f51518e","modified":1500888035000},{"_id":"source/_posts/设计模式之路（5）代理模式.md","hash":"01ee4aca73286c9994c95f4bcd6bc7f1fec04735","modified":1500890484000},{"_id":"source/_posts/设计模式之路（3）开放-封闭原则.md","hash":"b7355daec1434bf194f0d67c7a3ebcdebda52a63","modified":1500888035000},{"_id":"source/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1500888035000},{"_id":"source/about/index.md","hash":"275622fcc864a15ec99d98d188b42dd958a9703b","modified":1500888035000},{"_id":"source/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1500888035000},{"_id":"source/tags/index.md","hash":"7249889c39305c0af25b6e598a525bb4268390eb","modified":1500888035000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1500888035000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1500888035000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1500888035000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1500888035000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1500888035000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1500888035000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1500888035000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1500888035000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1500888035000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1500888035000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1500888035000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1500888035000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1500888035000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1500888035000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1500888035000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1500888035000},{"_id":"themes/next/layout/.DS_Store","hash":"538eb6e7d8b5244039466e1749f0f4d4faf9ba61","modified":1501138594000},{"_id":"themes/next/layout/_layout.swig","hash":"a44305f8fa7fe9c80eb50c0696a704424b589750","modified":1500888035000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1500888035000},{"_id":"themes/next/layout/category.swig","hash":"82e7bc278559b4335ad974659104eaaf04863032","modified":1500888035000},{"_id":"themes/next/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1500888035000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1500888035000},{"_id":"themes/next/layout/page.swig","hash":"baa667bc801349d5c4984c0f172973d3780400df","modified":1500888035000},{"_id":"themes/next/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1500888035000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1500888035000},{"_id":"themes/next/layout/tag.swig","hash":"2e73ee478e981092ea9a5d10dd472a9461db395b","modified":1500888035000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1500888035000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1500888035000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1500888035000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1500888035000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1500888035000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1500888035000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1500888035000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1500888035000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1500888035000},{"_id":"themes/next/scripts/tags/note.js","hash":"21b102db8a01c7b15ae2c0ea3ef3d4cf807ec6ed","modified":1500888035000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1500888035000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1500888035000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1500888035000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1500888035000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1500888035000},{"_id":"themes/next/layout/_macro/post.swig","hash":"d6fe43765bc01017ca3f9a384eeddaf28b6382c8","modified":1500888035000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1500888035000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1500888035000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a2b213c1a7c37cd6e4749f2018371f4c1f4f0d23","modified":1500888035000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"57019529c98e1ec24253e6d0de3f6c39162c6565","modified":1501138594000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1500888035000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1500888035000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6a7eb93d8aa7d4baa472890bd666b921f449d8af","modified":1500888035000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1500888035000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1500888035000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1500888035000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1500888035000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1500888035000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1500888035000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1500888035000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1500888035000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1500888035000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1500888035000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1500888035000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1500888035000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1500888035000},{"_id":"themes/next/source/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1500888035000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1500888035000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1500888035000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1500888035000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1500888035000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1500888035000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1500888035000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1500888035000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1500888035000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1500888035000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1500888035000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1500888035000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1500888035000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1500888035000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1500888035000},{"_id":"themes/next/source/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1500888035000},{"_id":"themes/next/source/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1500888035000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1500888035000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1500888035000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"8733db07de32d1c24710110afa04ff036ade7b4e","modified":1501138674000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1500888035000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1500888035000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1500888035000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1500888035000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1500888035000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1500888035000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1500888035000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1500888035000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1500888035000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1500888035000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1500888035000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1500888035000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1500888035000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1500888035000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1500888035000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1500888035000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1500888035000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1500888035000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1500888035000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1500888035000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1500888035000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1500888035000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1500888035000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1500888035000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1500888035000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1500888035000},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1500888035000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1500888035000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1500888035000},{"_id":"themes/next/source/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1500888035000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1500888035000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1500888035000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1500888035000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1500888035000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1500888035000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1500888035000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1500888035000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1500888035000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1500888035000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1500888035000},{"_id":"source/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1500888035000},{"_id":"themes/next/source/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1500888035000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1500888035000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1500888035000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1500888035000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1500888035000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1500888035000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1500888035000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1500888035000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1500888035000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1500888035000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1500888035000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1500888035000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1500888035000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1500888035000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"468bc734f47209096588ef1a8e55e60a3b12aa63","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"dfc86d37f5b580977d82af6ef835082d09a0c499","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1500888035000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1500888035000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1500888035000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1500888035000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1500888035000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1500888035000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1500888035000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1500888035000},{"_id":"public/about/index.html","hash":"c2a1d44bea9936fcfafb3b7d381dfa99b5925b3a","modified":1503845134496},{"_id":"public/tags/index.html","hash":"69dfd16a1089c59d751430468891a22796c43877","modified":1503845134496},{"_id":"public/archives/2016/index.html","hash":"fd32ffac66c3e0c37f12d05ee8cb589b5a5df2f2","modified":1503845134496},{"_id":"public/archives/2016/09/index.html","hash":"bd1d024c64826e7a7a6831d5cbac22d416f7d2fc","modified":1503845134496},{"_id":"public/archives/2016/11/index.html","hash":"7cd495f0f5da264cf1374cc85554ac550402c83b","modified":1503845134496},{"_id":"public/archives/2017/02/index.html","hash":"8a3aba26e3670332b7f01b85329d64f812b02975","modified":1503845134496},{"_id":"public/archives/2017/08/index.html","hash":"9fb2f2273d7f334834b476db614b3a742d304c28","modified":1503845134496},{"_id":"public/tags/Android/index.html","hash":"fb3427c215bc9af003d4d81274d8d7f3d5b7ca39","modified":1503845134496},{"_id":"public/tags/Bugsnag/index.html","hash":"b168814a06f5afcd9ee2ce78dc76d39f229cf5ef","modified":1503845134496},{"_id":"public/tags/hexo/index.html","hash":"8133bbb29ac3588ecc21f7067d33f533fd671c35","modified":1503845134496},{"_id":"public/tags/github/index.html","hash":"d9c80f551903bdc7f227d56ab8f7852064b6ce61","modified":1503845134496},{"_id":"public/tags/HTTP/index.html","hash":"715d04a8c7a586ae9d031e9d0bfa433f72446416","modified":1503845134496},{"_id":"public/tags/OkHttp3/index.html","hash":"4cf969c5dba63a0456cf179b6bb2b751acc925d6","modified":1503845134496},{"_id":"public/tags/RxJava/index.html","hash":"e2f9a226699c47c72fce01eb9552d707680785ea","modified":1503845134496},{"_id":"public/tags/自定义View/index.html","hash":"0dca50502182ff558837996528d5dc7b391bc2e7","modified":1503845134496},{"_id":"public/tags/设计模式/index.html","hash":"c79a44dcdbb5802653e1001fe2ccf1e5af4900dd","modified":1503845134496},{"_id":"public/2017/08/26/自定义View-一/index.html","hash":"34d5ba8214ad7731fa42b24a0db9587b2ad048ed","modified":1503845134497},{"_id":"public/2017/08/22/RxJava2-0-四-过滤操作/index.html","hash":"86a95d24af73d4fc64e619b851730b816867e0d5","modified":1503845134497},{"_id":"public/2017/08/12/RxJava2-0-三-变换操作/index.html","hash":"2ca77e4e1ce39e2f0fc5a07a369fc22594329833","modified":1503845134497},{"_id":"public/2017/08/11/RxJava2-0-二/index.html","hash":"eab9d61831557e85e0cdd17995c19006457236bb","modified":1503845134497},{"_id":"public/2017/08/10/RxJava2-0-一/index.html","hash":"8b3e58fd1a0a3a8c504834dc96340cd31dcd97a2","modified":1503845134497},{"_id":"public/2017/07/27/OkHttp3源码学习（3）/index.html","hash":"a8e02b871dc973ed2403df5aa125dffba3f97e38","modified":1503845134497},{"_id":"public/2017/07/26/OkHttp3源码学习（2）/index.html","hash":"2d4bab2ca9d6422c14728703a7cf34cfab2a7172","modified":1503845134497},{"_id":"public/2017/07/25/OkHttp3源码学习（1）/index.html","hash":"b537eb1244dd43eddf190f2517edbd87e06ab922","modified":1503845134497},{"_id":"public/2017/07/24/设计模式之路（5）代理模式/index.html","hash":"5b5ec63ec83f9dad9dd90ac368aa752bc27cf8a5","modified":1503845134497},{"_id":"public/2017/07/20/Android屏幕适配解决方案(1)/index.html","hash":"aa033e1addba6886e191d483a0bb0af52c0e1024","modified":1503845134497},{"_id":"public/2017/07/19/设计模式之路（4）装饰者模式/index.html","hash":"3385d5ddc5c58316d6e74c1d6d065a67d997d4e2","modified":1503845134497},{"_id":"public/2017/07/18/设计模式之路（3）开放-封闭原则/index.html","hash":"4c915f30816fa64c050764a4055dff43cf7c0018","modified":1503845134497},{"_id":"public/2017/07/18/设计模式之路（2）单一职责原则/index.html","hash":"cfa385da9d1e93aef1cd8574eeaee56eb3979bd0","modified":1503845134497},{"_id":"public/2017/07/17/设计模式之路（1）-简单工厂模式/index.html","hash":"de869c55f0f019138359f8d99618019a83d4e74b","modified":1503845134497},{"_id":"public/2017/07/14/Bugsnag-监控应用程序错误，以改善客户体验和代码质量/index.html","hash":"c4e8324647198f9c743f34f75776fb98f3d2e439","modified":1503845134497},{"_id":"public/2017/07/12/Android-MVPB/index.html","hash":"76398a298679f9ed19870932e6d0d232f57f23cc","modified":1503845134497},{"_id":"public/2017/02/22/Set集合使用注意tips/index.html","hash":"735296d53123d1520ed29333e947202013c5aaf6","modified":1503845134497},{"_id":"public/2016/11/19/HTTP需要知道的知识点-补充/index.html","hash":"c671e4fd203d68fbb14fbc66668268b2c4f016dc","modified":1503845134497},{"_id":"public/2016/11/13/关于HTTP需要理解的知识点/index.html","hash":"badfb706e3be2e8df5cdf5bd7ccdd4c7ecf23f3a","modified":1503845134497},{"_id":"public/2016/09/24/Hexo-Github搭建个人博客（4）/index.html","hash":"ffbbae7099bfe60b51fa536dec36b518e818cb5d","modified":1503845134497},{"_id":"public/2016/09/15/Github-hexo搭建个人博客（3）/index.html","hash":"6539ec12fb57821cd278d129828799b13f83b61a","modified":1503845134497},{"_id":"public/2016/09/14/Hexo-Github搭建个人博客（2）/index.html","hash":"bde239853dcc796ad331dbce5c558e7006ba5bb7","modified":1503845134497},{"_id":"public/2016/09/12/Git提交index.lock问题解决/index.html","hash":"725776f1af74b1c3d0cdc48900dabe6bfe49258c","modified":1503845134497},{"_id":"public/2016/09/10/Hexo+Github搭建个人博客（1）/index.html","hash":"c29401297ef8aee7476c8e3ec1e7b7acc9117e26","modified":1503845134497},{"_id":"public/2016/09/01/hello-world/index.html","hash":"55eb6417e6f2c93f9ba03844ac42d86ebbcbb189","modified":1503845134497},{"_id":"public/archives/index.html","hash":"5c8c3a8c59999e22c6e09e5a1c26ffea5c51da05","modified":1503845134497},{"_id":"public/archives/2017/index.html","hash":"bf8fff192d4037e06b000e29452ea1fbbbfef207","modified":1503845134497},{"_id":"public/archives/2017/07/index.html","hash":"3d5328cabf4b9b40a5b753104298dd3e312306d3","modified":1503845134497},{"_id":"public/index.html","hash":"18f7d02bf80a5ddf84b55d8d5b72b71db15ada7c","modified":1503845134497},{"_id":"public/page/2/index.html","hash":"9bfd258c1ebda2e4eb28ca03e73a70c9d32f6a89","modified":1503845134497},{"_id":"public/page/3/index.html","hash":"d2e7eeb958552d6fd76a97e805642d239cce93f3","modified":1503845134497},{"_id":"public/page/4/index.html","hash":"1771b2031b3e98a939c9012707c9f6dba4742e46","modified":1503845134498},{"_id":"public/page/5/index.html","hash":"88fa16d21319f10f3359a0aafdc089c555686eff","modified":1503845134498},{"_id":"public/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1503845134527},{"_id":"public/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1503845134528},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1503845134528},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1503845134528},{"_id":"public/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1503845134528},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1503845134528},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1503845134528},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1503845134528},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1503845134528},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1503845134528},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1503845134528},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1503845134528},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1503845134528},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1503845134528},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1503845134528},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1503845134528},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1503845134529},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1503845134529},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1503845134529},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1503845134529},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1503845134529},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1503845134529},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1503845134529},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1503845134530},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1503845134530},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1503845134530},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1503845134530},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1503845134530},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1503845134530},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1503845134530},{"_id":"public/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1503845135053},{"_id":"public/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1503845135057},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1503845135082},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1503845135082},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1503845135088},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1503845135088},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1503845135088},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1503845135088},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1503845135088},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1503845135088},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1503845135088},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1503845135088},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1503845135088},{"_id":"public/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1503845135088},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1503845135088},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1503845135088},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1503845135089},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1503845135089},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1503845135089},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1503845135089},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1503845135089},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1503845135089},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1503845135089},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1503845135089},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1503845135089},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1503845135089},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1503845135090},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1503845135090},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1503845135090},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1503845135090},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1503845135090},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1503845135090},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1503845135090},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1503845135090},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1503845135090},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1503845135091},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1503845135091},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1503845135091},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1503845135091},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1503845135091},{"_id":"public/css/main.css","hash":"31a5795aa51af35618ab54601fa5ef9103d01ecd","modified":1503845135091},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1503845135093},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1503845135094},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1503845135095},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1503845135095},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1503845135095},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1503845135095},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1503845135095},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1503845135095},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1503845135096},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1503845135096},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1503845135096},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1503845135096},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1503845135096},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1503845135096},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1503845135096},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1503845135096},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1503845135096},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1503845135096},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1503845135097},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1503845135097},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1503845135097},{"_id":"public/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1503845135109},{"_id":"public/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1503845135115},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1503845135115}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-07-10T08:42:29.000Z","_content":"## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nQQ: 601545126\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-07-10 16:42:29\n---\n## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nQQ: 601545126\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","updated":"2017-07-24T09:20:35.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj6uuka6k0022kcc0gave6svx","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>QQ: 601545126</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>QQ: 601545126</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n"},{"title":"tags","date":"2017-07-10T08:24:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-07-10 16:24:17\ntype: \"tags\"\n---\n","updated":"2017-07-24T09:20:35.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj6uuka6k0023kcc0zwhii3kq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"阿里百川Hotfix 1.4.0 Android接入","date":"2017-07-12T09:33:45.000Z","_content":"\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","source":"_posts/Android-MVPB.md","raw":"---\ntitle: 阿里百川Hotfix 1.4.0 Android接入\ndate: 2017-07-12 17:33:45\ntags: [Android]\n---\n\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","slug":"Android-MVPB","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4j0000kcc0bhia6ynx","content":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n"},{"title":"Bugsnag:监控应用程序错误，以改善客户体验和代码质量","date":"2017-07-14T02:48:23.000Z","_content":"\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","source":"_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","raw":"---\ntitle: 'Bugsnag:监控应用程序错误，以改善客户体验和代码质量'\ndate: 2017-07-14 10:48:23\ntags: [Bugsnag,Android]\n---\n\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","slug":"Bugsnag-监控应用程序错误，以改善客户体验和代码质量","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4n0001kcc0rapkuezt","content":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n"},{"title":"Hexo+Github搭建个人博客（3）","date":"2016-09-15T09:03:56.000Z","_content":"\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","source":"_posts/Github-hexo搭建个人博客（3）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（3）\ndate: 2016-09-15 17:03:56\ntags: [hexo,github]\n---\n\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","slug":"Github-hexo搭建个人博客（3）","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4q0003kcc016pcxa54","content":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n"},{"title":"Git提交index.lock问题解决","date":"2016-09-12T11:07:26.000Z","_content":"\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","source":"_posts/Git提交index.lock问题解决.md","raw":"---\ntitle: Git提交index.lock问题解决\ndate: 2016-09-12 19:07:26\ntags:\n---\n\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","slug":"Git提交index.lock问题解决","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4r0004kcc0x6xwjj50","content":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n"},{"title":"Android屏幕适配解决方案(1)","date":"2017-07-20T03:23:22.000Z","_content":"\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","source":"_posts/Android屏幕适配解决方案(1).md","raw":"---\ntitle: Android屏幕适配解决方案(1)\ndate: 2017-07-20 11:23:22\ntags: [Android]\n---\n\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","slug":"Android屏幕适配解决方案(1)","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4t0005kcc0t9v27019","content":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n"},{"title":"HTTP需要知道的知识点-补充","date":"2016-11-19T11:33:52.000Z","_content":"\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","source":"_posts/HTTP需要知道的知识点-补充.md","raw":"---\ntitle: HTTP需要知道的知识点-补充\ndate: 2016-11-19 19:33:52\ntags: [HTTP]\n---\n\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","slug":"HTTP需要知道的知识点-补充","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4v0008kcc0x12we117","content":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo+Github搭建个人博客(1)","date":"2016-09-10T13:02:08.000Z","_content":"\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","source":"_posts/Hexo+Github搭建个人博客（1）.md","raw":"---\ntitle: Hexo+Github搭建个人博客(1)\ndate: 2016-09-10 21:02:08\ntags: [hexo,github]\n---\n\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","slug":"Hexo+Github搭建个人博客（1）","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka4w000akcc0caird7k4","content":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n"},{"title":"OkHttp3源码学习（1）-简单实用教程","date":"2017-07-25T02:19:43.000Z","_content":"\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","source":"_posts/OkHttp3源码学习（1）.md","raw":"---\ntitle: OkHttp3源码学习（1）-简单实用教程\ndate: 2017-07-25 10:19:43\ntags: [OkHttp3]\n---\n\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","slug":"OkHttp3源码学习（1）","published":1,"updated":"2017-07-27T09:03:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka50000ckcc0pa93pexr","content":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n"},{"title":"Hexo+Github搭建个人博客（2）","date":"2016-09-14T06:01:42.000Z","_content":"\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","source":"_posts/Hexo-Github搭建个人博客（2）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（2）\ndate: 2016-09-14 14:01:42\ntags: [hexo,github]\n---\n\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","slug":"Hexo-Github搭建个人博客（2）","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka51000dkcc0qptdkch1","content":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>"},{"title":"Hexo+Github搭建个人博客（4）","date":"2016-09-24T09:28:09.000Z","_content":"\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","source":"_posts/Hexo-Github搭建个人博客（4）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（4）\ndate: 2016-09-24 17:28:09\ntags: [hexo,github]\n---\n\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","slug":"Hexo-Github搭建个人博客（4）","published":1,"updated":"2017-07-24T09:58:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka52000fkcc06vxbg8hy","content":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n"},{"title":"OkHttp3源码学习（2）-发起请求源码实现","date":"2017-07-26T07:25:37.000Z","_content":"\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","source":"_posts/OkHttp3源码学习（2）.md","raw":"---\ntitle: OkHttp3源码学习（2）-发起请求源码实现\ndate: 2017-07-26 15:25:37\ntags: [OkHttp3]\n---\n\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","slug":"OkHttp3源码学习（2）","published":1,"updated":"2017-07-27T09:10:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka53000hkcc0nxntqfo0","content":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n"},{"title":"OkHttp3源码学习(3)-拦截器链详解","date":"2017-07-27T09:02:28.000Z","_content":"\n#### 构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n#### RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链从下一个拦截器访问。\n\n#### 一、RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t\n      if (!sameConnection(response, followUp.url())) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器\n\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n\n","source":"_posts/OkHttp3源码学习（3）.md","raw":"---\ntitle: OkHttp3源码学习(3)-拦截器链详解\ndate: 2017-07-27 17:02:28\ntags: [OkHttp3]\n---\n\n#### 构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n#### RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链从下一个拦截器访问。\n\n#### 一、RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t\n      if (!sameConnection(response, followUp.url())) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器\n\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n\n","slug":"OkHttp3源码学习（3）","published":1,"updated":"2017-07-27T10:19:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka55000kkcc00uc2x8fc","content":"<h4 id=\"构建拦截器链\"><a href=\"#构建拦截器链\" class=\"headerlink\" title=\"构建拦截器链\"></a>构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><h4 id=\"RealInterceptorChain\"><a href=\"#RealInterceptorChain\" class=\"headerlink\" title=\"RealInterceptorChain\"></a>RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：<br>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链从下一个拦截器访问。</p>\n<h4 id=\"一、RetryAndFollowUpInterceptor\"><a href=\"#一、RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"一、RetryAndFollowUpInterceptor\"></a>一、RetryAndFollowUpInterceptor</h4><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n\n  if (!sameConnection(response, followUp.url())) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器</p>\n<pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"构建拦截器链\"><a href=\"#构建拦截器链\" class=\"headerlink\" title=\"构建拦截器链\"></a>构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><h4 id=\"RealInterceptorChain\"><a href=\"#RealInterceptorChain\" class=\"headerlink\" title=\"RealInterceptorChain\"></a>RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：<br>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链从下一个拦截器访问。</p>\n<h4 id=\"一、RetryAndFollowUpInterceptor\"><a href=\"#一、RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"一、RetryAndFollowUpInterceptor\"></a>一、RetryAndFollowUpInterceptor</h4><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n\n  if (!sameConnection(response, followUp.url())) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器</p>\n<pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n"},{"title":"RxJava2.0(一)基本使用","date":"2017-08-10T11:16:59.000Z","_content":"\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","source":"_posts/RxJava2-0-一.md","raw":"---\ntitle: RxJava2.0(一)基本使用\ndate: 2017-08-10 19:16:59\ntags: [RxJava]\n---\n\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","slug":"RxJava2-0-一","published":1,"updated":"2017-08-15T11:28:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka56000lkcc0r8t88esd","content":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n"},{"title":"RxJava2.0(三)变换操作","date":"2017-08-12T07:58:33.000Z","_content":"\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\n\n\n\n\n\n","source":"_posts/RxJava2-0-三-变换操作.md","raw":"---\ntitle: RxJava2.0(三)变换操作\ndate: 2017-08-12 15:58:33\ntags: [RxJava]\n---\n\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\n\n\n\n\n\n","slug":"RxJava2-0-三-变换操作","published":1,"updated":"2017-08-23T12:48:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka57000nkcc0euuxlrqo","content":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n","site":{"data":{}},"excerpt":"","more":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n"},{"title":"RxJava2.0(二)线程控制","date":"2017-08-11T11:27:52.000Z","_content":"\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","source":"_posts/RxJava2-0-二.md","raw":"---\ntitle: RxJava2.0(二)线程控制\ndate: 2017-08-11 19:27:52\ntags: [RxJava]\n---\n\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","slug":"RxJava2-0-二","published":1,"updated":"2017-08-16T07:55:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka59000pkcc0jejb309r","content":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"RxJava2.0(四)过滤操作","date":"2017-08-22T14:33:27.000Z","_content":"\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n","source":"_posts/RxJava2-0-四-过滤操作.md","raw":"---\ntitle: RxJava2.0(四)过滤操作\ndate: 2017-08-22 22:33:27\ntags: [RxJava]\n---\n\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n","slug":"RxJava2-0-四-过滤操作","published":1,"updated":"2017-08-25T15:17:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5b000rkcc0k9w66gxq","content":"<h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n"},{"title":"自定义View(一)","date":"2017-08-26T14:06:02.000Z","_content":"\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n","source":"_posts/自定义View-一.md","raw":"---\ntitle: 自定义View(一)\ndate: 2017-08-26 22:06:02\ntags: [自定义View]\n---\n\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n","slug":"自定义View-一","published":1,"updated":"2017-08-27T14:45:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5d000ukcc0mns40j6w","content":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n"},{"title":"关于HTTP需要理解的知识点","date":"2016-11-13T07:24:05.000Z","_content":"\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","source":"_posts/关于HTTP需要理解的知识点.md","raw":"---\ntitle: 关于HTTP需要理解的知识点\ndate: 2016-11-13 15:24:05\ntags: [HTTP]\n---\n\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","slug":"关于HTTP需要理解的知识点","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5e000vkcc0thtuqkts","content":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n"},{"title":"Set集合使用注意tips","date":"2017-02-22T11:11:02.000Z","_content":"\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","source":"_posts/Set集合使用注意tips.md","raw":"---\ntitle: Set集合使用注意tips\ndate: 2017-02-22 19:11:02\ntags:\n---\n\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","slug":"Set集合使用注意tips","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5f000xkcc0lxzu7dgg","content":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n"},{"title":"Hello World","date":"2016-09-01T12:02:08.000Z","type":["Hello"],"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-09-01 20:02:08\ntype: [Hello]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5k000zkcc0pnvnouv0","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"设计模式之路（1）-简单工厂模式","date":"2017-07-17T04:48:01.000Z","_content":"\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","source":"_posts/设计模式之路（1）-简单工厂模式.md","raw":"---\ntitle: 设计模式之路（1）-简单工厂模式\ndate: 2017-07-17 12:48:01\ntags: [设计模式]\n---\n\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","slug":"设计模式之路（1）-简单工厂模式","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5l0012kcc0rev4hdgy","content":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n"},{"title":"设计模式之路（2）单一职责原则","date":"2017-07-18T07:06:41.000Z","_content":"\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","source":"_posts/设计模式之路（2）单一职责原则.md","raw":"---\ntitle: 设计模式之路（2）单一职责原则\ndate: 2017-07-18 15:06:41\ntags: [设计模式]\n---\n\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","slug":"设计模式之路（2）单一职责原则","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5m0014kcc0udfh0ksn","content":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n"},{"title":"设计模式之路（4）装饰者模式","date":"2017-07-19T02:20:23.000Z","author":"Neil Liu","_content":"\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","source":"_posts/设计模式之路（4）装饰者模式.md","raw":"---\ntitle: 设计模式之路（4）装饰者模式\ndate: 2017-07-19 10:20:23\ntags: [设计模式]\nauthor: Neil Liu\n---\n\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","slug":"设计模式之路（4）装饰者模式","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5o0016kcc0j8g6kjmc","content":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n"},{"title":"设计模式之路（5）代理模式","date":"2017-07-24T07:06:52.000Z","_content":"\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","source":"_posts/设计模式之路（5）代理模式.md","raw":"---\ntitle: 设计模式之路（5）代理模式\ndate: 2017-07-24 15:06:52\ntags: [设计模式]\n---\n\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","slug":"设计模式之路（5）代理模式","published":1,"updated":"2017-07-24T10:01:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka5p0018kcc0am9ffqlj","content":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n"},{"title":"设计模式之路（3）开放-封闭原则","date":"2017-07-18T08:24:08.000Z","_content":"\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","source":"_posts/设计模式之路（3）开放-封闭原则.md","raw":"---\ntitle: 设计模式之路（3）开放-封闭原则\ndate: 2017-07-18 16:24:08\ntags: [设计模式]\n---\n\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","slug":"设计模式之路（3）开放-封闭原则","published":1,"updated":"2017-07-24T09:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uuka6j0021kcc00soq8j0a","content":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6uuka4j0000kcc0bhia6ynx","tag_id":"cj6uuka4p0002kcc0jt9lawl6","_id":"cj6uuka4v0007kcc03wgaocat"},{"post_id":"cj6uuka4t0005kcc0t9v27019","tag_id":"cj6uuka4p0002kcc0jt9lawl6","_id":"cj6uuka4w0009kcc0fg7d5n86"},{"post_id":"cj6uuka4n0001kcc0rapkuezt","tag_id":"cj6uuka4t0006kcc02nye5fcx","_id":"cj6uuka53000gkcc02634n85q"},{"post_id":"cj6uuka4n0001kcc0rapkuezt","tag_id":"cj6uuka4p0002kcc0jt9lawl6","_id":"cj6uuka54000ikcc0imwohpqc"},{"post_id":"cj6uuka4q0003kcc016pcxa54","tag_id":"cj6uuka51000ekcc06qekhhjh","_id":"cj6uuka58000okcc03fkmpvta"},{"post_id":"cj6uuka4q0003kcc016pcxa54","tag_id":"cj6uuka54000jkcc0drtjq0ib","_id":"cj6uuka5b000qkcc0d1n0jplh"},{"post_id":"cj6uuka4v0008kcc0x12we117","tag_id":"cj6uuka57000mkcc0vvl8sous","_id":"cj6uuka5d000tkcc0rplvhw8x"},{"post_id":"cj6uuka5e000vkcc0thtuqkts","tag_id":"cj6uuka57000mkcc0vvl8sous","_id":"cj6uuka5j000ykcc0q3bojtxa"},{"post_id":"cj6uuka4w000akcc0caird7k4","tag_id":"cj6uuka51000ekcc06qekhhjh","_id":"cj6uuka5l0011kcc0q0jcznm7"},{"post_id":"cj6uuka4w000akcc0caird7k4","tag_id":"cj6uuka54000jkcc0drtjq0ib","_id":"cj6uuka5m0013kcc0hp4p1bpe"},{"post_id":"cj6uuka50000ckcc0pa93pexr","tag_id":"cj6uuka5l0010kcc071bmo7r3","_id":"cj6uuka5p0017kcc018m33phs"},{"post_id":"cj6uuka51000dkcc0qptdkch1","tag_id":"cj6uuka51000ekcc06qekhhjh","_id":"cj6uuka5t001bkcc0yjjf2gp9"},{"post_id":"cj6uuka51000dkcc0qptdkch1","tag_id":"cj6uuka54000jkcc0drtjq0ib","_id":"cj6uuka5u001ckcc0thg1098f"},{"post_id":"cj6uuka52000fkcc06vxbg8hy","tag_id":"cj6uuka51000ekcc06qekhhjh","_id":"cj6uuka5u001ekcc0ohp35pkb"},{"post_id":"cj6uuka52000fkcc06vxbg8hy","tag_id":"cj6uuka54000jkcc0drtjq0ib","_id":"cj6uuka5v001fkcc0ndfjv5k7"},{"post_id":"cj6uuka53000hkcc0nxntqfo0","tag_id":"cj6uuka5l0010kcc071bmo7r3","_id":"cj6uuka5v001hkcc0p07hnlpu"},{"post_id":"cj6uuka55000kkcc00uc2x8fc","tag_id":"cj6uuka5l0010kcc071bmo7r3","_id":"cj6uuka5v001jkcc0yng6ocqd"},{"post_id":"cj6uuka56000lkcc0r8t88esd","tag_id":"cj6uuka5v001ikcc00sftrmun","_id":"cj6uuka5w001lkcc0md8ojudx"},{"post_id":"cj6uuka57000nkcc0euuxlrqo","tag_id":"cj6uuka5v001ikcc00sftrmun","_id":"cj6uuka5x001nkcc0bf0kvob3"},{"post_id":"cj6uuka59000pkcc0jejb309r","tag_id":"cj6uuka5v001ikcc00sftrmun","_id":"cj6uuka5x001pkcc0t7n7p4p5"},{"post_id":"cj6uuka5b000rkcc0k9w66gxq","tag_id":"cj6uuka5v001ikcc00sftrmun","_id":"cj6uuka60001rkcc0hz76p0it"},{"post_id":"cj6uuka5d000ukcc0mns40j6w","tag_id":"cj6uuka60001qkcc07cfvnn0s","_id":"cj6uuka62001tkcc09faqrom2"},{"post_id":"cj6uuka5l0012kcc0rev4hdgy","tag_id":"cj6uuka61001skcc08wh31jej","_id":"cj6uuka64001vkcc0c4xeong7"},{"post_id":"cj6uuka5m0014kcc0udfh0ksn","tag_id":"cj6uuka61001skcc08wh31jej","_id":"cj6uuka66001xkcc05u6jawxs"},{"post_id":"cj6uuka5o0016kcc0j8g6kjmc","tag_id":"cj6uuka61001skcc08wh31jej","_id":"cj6uuka66001zkcc0ofjo3jk0"},{"post_id":"cj6uuka5p0018kcc0am9ffqlj","tag_id":"cj6uuka61001skcc08wh31jej","_id":"cj6uuka660020kcc0986zqpdq"},{"post_id":"cj6uuka6j0021kcc00soq8j0a","tag_id":"cj6uuka61001skcc08wh31jej","_id":"cj6uuka6l0024kcc03awposxl"}],"Tag":[{"name":"Android","_id":"cj6uuka4p0002kcc0jt9lawl6"},{"name":"Bugsnag","_id":"cj6uuka4t0006kcc02nye5fcx"},{"name":"hexo","_id":"cj6uuka51000ekcc06qekhhjh"},{"name":"github","_id":"cj6uuka54000jkcc0drtjq0ib"},{"name":"HTTP","_id":"cj6uuka57000mkcc0vvl8sous"},{"name":"OkHttp3","_id":"cj6uuka5l0010kcc071bmo7r3"},{"name":"RxJava","_id":"cj6uuka5v001ikcc00sftrmun"},{"name":"自定义View","_id":"cj6uuka60001qkcc07cfvnn0s"},{"name":"设计模式","_id":"cj6uuka61001skcc08wh31jej"}]}}