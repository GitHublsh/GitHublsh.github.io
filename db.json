{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/httpmessage.jpg","path":"images/httpmessage.jpg","modified":0,"renderable":0},{"_id":"source/images/request.png","path":"images/request.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG5.jpeg","path":"images/WechatIMG5.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG3.jpeg","path":"images/WechatIMG3.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG7.jpeg","path":"images/WechatIMG7.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/bugsnag.png","path":"images/bugsnag.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1543917558000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1543914925000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1543914925000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1543914925000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1543914925000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1543914925000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1543914925000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1543914925000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1543914925000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1543914925000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1543914925000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1543914925000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1543914925000},{"_id":"themes/next/_config.yml","hash":"a8ffc20bc851e5ad754f1d97d6f80c085b7b195b","modified":1543914925000},{"_id":"themes/next/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1543914925000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1543914925000},{"_id":"themes/next/package.json","hash":"6b5bfec48776ddf9c03811b1ff2cb2b615eccc88","modified":1543914925000},{"_id":"source/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1543914925000},{"_id":"source/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1543914925000},{"_id":"source/_posts/ADB常用命令备忘录.md","hash":"c6c42f9585184882a940ffa50546780157e7e7ed","modified":1543914925000},{"_id":"source/_posts/Activity的四种启动模式.md","hash":"7e7b4a2a49c04837e3f06ff161f0574bd804ab97","modified":1543914925000},{"_id":"source/_posts/Android-7-0-so库兼容问题.md","hash":"73b49b07292bee69745b04dcec6975b37abaabf0","modified":1543914925000},{"_id":"source/_posts/Android-Gradle构建入门(一).md","hash":"387ac62cb2f930daa956bab817fc05a0fd666bd4","modified":1543914925000},{"_id":"source/_posts/Android-MVPB.md","hash":"c84144c36338c8c4c87d234df24754a666191750","modified":1543914925000},{"_id":"source/_posts/Android-Studio3-0-Trace分析.md","hash":"fbafe2ff1c70d09076118c5c48047a1ce33acac2","modified":1543914925000},{"_id":"source/_posts/Android-View事件分发机制.md","hash":"bd963771ce69a172fafc0c3d5618a1f997076ebf","modified":1543914925000},{"_id":"source/_posts/Android四大组件之BroadCast.md","hash":"22021dac4935192ca79a5c081407bf52e3d1fb89","modified":1543914925000},{"_id":"source/_posts/Android四大组件之ContentProvider.md","hash":"ecb9ae780cdfba769bfeb8424b1c411cd2d8406b","modified":1543914925000},{"_id":"source/_posts/Android四大组件之Service.md","hash":"8ae50213cba61b171049504de7f57410ad644371","modified":1543914925000},{"_id":"source/_posts/Android屏幕适配解决方案(1).md","hash":"47c1ed23619177e44209c0a0117e0e1c77a17cb2","modified":1543914925000},{"_id":"source/_posts/Android常见内存泄漏及解决办法.md","hash":"49411c8b7c57a4ab3d32d8b2b35b006fb1ccdbc4","modified":1543914925000},{"_id":"source/_posts/Android过度绘制.md","hash":"a7dcee8981c90fddf5aa9007396848c4a7cee4cf","modified":1543914925000},{"_id":"source/_posts/Android性能优化（一）.md","hash":"b2e962da0338c26e0a86bc7ad026e0043955f456","modified":1543914925000},{"_id":"source/_posts/Bitmap-OOM解决方案.md","hash":"9f0d4de7f4439852d04998912e7c34f164a0e716","modified":1543914925000},{"_id":"source/_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","hash":"a24524f56b574c616cafdf934e42deadc5d36aa4","modified":1543914925000},{"_id":"source/_posts/Github-hexo搭建个人博客（3）.md","hash":"a3c4302a7e59ab2518203eb800fc487c4e795f02","modified":1543914925000},{"_id":"source/_posts/Git提交index.lock问题解决.md","hash":"0e01f071afcfcc2b4d87480e1d6e8dd3cfd210a2","modified":1543914925000},{"_id":"source/_posts/Glide4.x源码解析(1)-基本使用.md","hash":"45daa5ad609114c4f228badd84980b1bfed30334","modified":1543914925000},{"_id":"source/_posts/HTTP需要知道的知识点-补充.md","hash":"4275825346833c3bc845ab6221fbea4f5f4745d3","modified":1543914925000},{"_id":"source/_posts/Hexo+Github搭建个人博客（1）.md","hash":"431bf6b793cd93cf67bde8ae52ce1765d8d40e76","modified":1543914925000},{"_id":"source/_posts/HashMap的实现原理.md","hash":"cd4300f0055134adf51a1fb4ae7b6af413175bb4","modified":1543914925000},{"_id":"source/_posts/Hexo-Github搭建个人博客（2）.md","hash":"52952333d46f03f11a6f6407a251c1c65c8cdafc","modified":1543914925000},{"_id":"source/_posts/Hexo-Github搭建个人博客（4）.md","hash":"b7aa7ecf8f3679099815a7ab36a1a8f8dc4422a0","modified":1543914925000},{"_id":"source/_posts/IPC基础概念介绍.md","hash":"e3c121351d8199c35055ebde5a08a64b716d1750","modified":1543914925000},{"_id":"source/_posts/Java-线程池浅析.md","hash":"0bd9daf8a7e9816e23c518bb2e848a2a37b3ff3e","modified":1543920177000},{"_id":"source/_posts/Java并发编程：volatile关键字解析.md","hash":"ca536f0e1668e8c62308275d2a911b1484dce3e3","modified":1543914925000},{"_id":"source/_posts/Java死锁浅析.md","hash":"602e1bb52d6c5685cdd281d29aa2b38218705d49","modified":1543914925000},{"_id":"source/_posts/MarkDown语法.md","hash":"c2253c907f5cecbdadfcf8a4fc8858db590beb8e","modified":1543914925000},{"_id":"source/_posts/LruCache源码及原理分析.md","hash":"3185507bfd58850e081cf5356882dff7b090c265","modified":1543914925000},{"_id":"source/_posts/OkHttp3源码学习（1）.md","hash":"a99973feb23bcd833e57602f671a7218ddba2bd4","modified":1543914925000},{"_id":"source/_posts/OkHttp3源码学习（2）.md","hash":"9d68f5c576c8e8626f6e3aede9c8ab48947925ed","modified":1543914925000},{"_id":"source/_posts/OkHttp3源码学习（3）.md","hash":"c5515e3b433ec37ecaac9a2e97c163dd789b56e6","modified":1543914925000},{"_id":"source/_posts/OkHttp3源码学习（4）-Dispatcher.md","hash":"139e81b00d2be5b0d8aca421c280414df190d9ab","modified":1543914925000},{"_id":"source/_posts/PackageManager使用姿势.md","hash":"4ccb891b075d09dbb9b6a5e93ae3b5335a2a5b60","modified":1543914925000},{"_id":"source/_posts/RxJava2-0-一.md","hash":"1261abf6419332f16ab043c04fa420ac5a9c5463","modified":1543914925000},{"_id":"source/_posts/RxJava2-0-三-变换操作.md","hash":"028f39c304237fbc03e3942b07c0d071b489b355","modified":1543914925000},{"_id":"source/_posts/RxJava2-0-二.md","hash":"848ea20cc140d276e97eacf4d691c790b3ee0b59","modified":1543914925000},{"_id":"source/_posts/RxJava2-0-四-Backpressure.md","hash":"2ae659bc7d27523ca069bae37fd07ca7c703286c","modified":1543914925000},{"_id":"source/_posts/Set集合使用注意tips.md","hash":"f85007dfe3208a04cef2362399f26ad80a549c2a","modified":1543914925000},{"_id":"source/_posts/hello-world.md","hash":"d0a3314df13f207ed6b91e6d3f32510d7840992c","modified":1543914925000},{"_id":"source/_posts/主线程的Loop-loop-一直无限循环为什么不会造成ANR.md","hash":"984679dfd9e35e63a6eb45e094c46bc468c66a27","modified":1543914925000},{"_id":"source/_posts/书读的不多，却想的太多.md","hash":"06030ee1c8cdbfa82d82c2eaa1b77360c2bfb2ab","modified":1543914925000},{"_id":"source/_posts/关于HTTP需要理解的知识点.md","hash":"cb482ddc907156d5596697ad6a14e4561ac31430","modified":1543914925000},{"_id":"source/_posts/多的是，你不知道的事.md","hash":"7377d8f8a368944f197775236a7702533b9ef434","modified":1543914925000},{"_id":"source/_posts/自定义View-2-Canvas简介.md","hash":"c0fa541950b1a9b8e86214a5e265ba871fbfe8cb","modified":1543914925000},{"_id":"source/_posts/自定义View-一.md","hash":"cfe065b228e69dc97715a9dd3bbec26a442a097b","modified":1543914925000},{"_id":"source/_posts/设计模式之路（1）-简单工厂模式.md","hash":"1c9eb0cc17b5dbfca4570406d82c0a9299f16eb1","modified":1543914925000},{"_id":"source/_posts/设计模式之路（2）单一职责原则.md","hash":"312fc33429c2ffdaea870f9d00ba24c497ff89ff","modified":1543914925000},{"_id":"source/_posts/设计模式之路（3）开放-封闭原则.md","hash":"b7355daec1434bf194f0d67c7a3ebcdebda52a63","modified":1543914925000},{"_id":"source/_posts/设计模式之路（4）装饰者模式.md","hash":"9e0583420972cd6a812f84e1ab48978a4f51518e","modified":1543914925000},{"_id":"source/_posts/设计模式之路（5）代理模式.md","hash":"01ee4aca73286c9994c95f4bcd6bc7f1fec04735","modified":1543914925000},{"_id":"source/_posts/设计模式之路（6）依赖倒转原则.md","hash":"6dda0cdc33abc4c88965c6afa051d5a89beed69e","modified":1543914925000},{"_id":"source/_posts/设计模式之路（7）里氏替换原则.md","hash":"49023cb4ed09af1f68103a4a13299ed6186dab9b","modified":1543914925000},{"_id":"source/about/index.md","hash":"3ecb0736ba06879cb06182acc40828a982b52711","modified":1543914925000},{"_id":"source/tags/index.md","hash":"7249889c39305c0af25b6e598a525bb4268390eb","modified":1543914925000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1543914925000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1543914925000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1543914925000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1543914925000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1543914925000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1543914925000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1543914925000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1543914925000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1543914925000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1543914925000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1543914925000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1543914925000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1543914925000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1543914925000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1543914925000},{"_id":"themes/next/layout/_layout.swig","hash":"a44305f8fa7fe9c80eb50c0696a704424b589750","modified":1543914925000},{"_id":"themes/next/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1543914925000},{"_id":"themes/next/layout/category.swig","hash":"82e7bc278559b4335ad974659104eaaf04863032","modified":1543914925000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1543914925000},{"_id":"themes/next/layout/page.swig","hash":"baa667bc801349d5c4984c0f172973d3780400df","modified":1543914925000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1543914925000},{"_id":"themes/next/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1543914925000},{"_id":"themes/next/layout/tag.swig","hash":"2e73ee478e981092ea9a5d10dd472a9461db395b","modified":1543914925000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1543914925000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1543914925000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1543914925000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1543914925000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1543914925000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543914925000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1543914925000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1543914925000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1543914925000},{"_id":"themes/next/layout/_macro/post.swig","hash":"d6fe43765bc01017ca3f9a384eeddaf28b6382c8","modified":1543914925000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1543914925000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a2b213c1a7c37cd6e4749f2018371f4c1f4f0d23","modified":1543914925000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1543914925000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1543914925000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1543914925000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6a7eb93d8aa7d4baa472890bd666b921f449d8af","modified":1543914925000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1543914925000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1543914925000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1543914925000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1543914925000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1543914925000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1543914925000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1543914925000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1543914925000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1543914925000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1543914925000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1543914925000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1543914925000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1543914925000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1543914925000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1543914925000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1543914925000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1543914925000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1543914925000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1543914925000},{"_id":"themes/next/scripts/tags/note.js","hash":"21b102db8a01c7b15ae2c0ea3ef3d4cf807ec6ed","modified":1543914925000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1543914925000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1543914925000},{"_id":"themes/next/source/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1543914925000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543914925000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543914925000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543914925000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543914925000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543914925000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543914925000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543914925000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543914925000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543914925000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543914925000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543914925000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543914925000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1543914925000},{"_id":"themes/next/source/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1543914925000},{"_id":"themes/next/source/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1543914925000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1543914925000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"8733db07de32d1c24710110afa04ff036ade7b4e","modified":1543914925000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1543914925000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1543914925000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1543914925000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1543914925000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1543914925000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1543914925000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1543914925000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1543914925000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1543914925000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1543914925000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1543914925000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1543914925000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1543914925000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1543914925000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1543914925000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1543914925000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1543914925000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1543914925000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1543914925000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1543914925000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1543914925000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543914925000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543914925000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1543914925000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543914925000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1543914925000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543914925000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1543914925000},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1543914925000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543914925000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543914925000},{"_id":"themes/next/source/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1543914925000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1543914925000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1543914925000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1543914925000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543914925000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1543914925000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1543914925000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1543914925000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1543914925000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543914925000},{"_id":"themes/next/source/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1543914925000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543914925000},{"_id":"source/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1543914925000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1543914925000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1543914925000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1543914925000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1543914925000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1543914925000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1543914925000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1543914925000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1543914925000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543914925000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543914925000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543914925000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543914925000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"468bc734f47209096588ef1a8e55e60a3b12aa63","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"dfc86d37f5b580977d82af6ef835082d09a0c499","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1543914925000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543914925000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1543914925000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543914925000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1543914925000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1543914925000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1543914925000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1543914925000},{"_id":"public/about/index.html","hash":"b2f957ed04aa6bd2a3faa2aeb8563ae04c4299d2","modified":1543920239702},{"_id":"public/tags/index.html","hash":"07c0a34b0b7cf90e6a3f0180e3136f4ff2b72ddb","modified":1543920239702},{"_id":"public/2017/09/03/书读的不多，却想的太多/index.html","hash":"f7a8b708a6b612eee4de272b79176f0ed64787e8","modified":1543920239702},{"_id":"public/archives/2016/09/index.html","hash":"c4b85cf53f10b29ec0b7739805e348bafdacf1c1","modified":1543920239702},{"_id":"public/archives/2016/11/index.html","hash":"0fe227994dcebd837aa201e3fae76a6e033eec82","modified":1543920239702},{"_id":"public/archives/2017/02/index.html","hash":"6dd78c6114a87be0167d3fb3d00b54c450773366","modified":1543920239702},{"_id":"public/archives/2017/08/index.html","hash":"9e361afbe375e5039a7d0601f89c9c4345bd1cb6","modified":1543920239702},{"_id":"public/archives/2017/09/index.html","hash":"90bcd6b28675ed9d4e34f793b182b1380ed79379","modified":1543920239702},{"_id":"public/archives/2017/10/index.html","hash":"ca916ae4555a7e604144a4e4a05932f42937bf8d","modified":1543920239702},{"_id":"public/archives/2017/12/index.html","hash":"3e34003a40a1389da7ac3335d1af091d45c61b70","modified":1543920239702},{"_id":"public/archives/2018/03/index.html","hash":"30cbf1ae8eec329ba884569441b2b68fb2d75902","modified":1543920239702},{"_id":"public/archives/2018/04/index.html","hash":"a6dd1420f827b7216cef8af49a2cf3556b1587c9","modified":1543920239702},{"_id":"public/archives/2018/05/index.html","hash":"75384f601f43f7a422053e181ae86faa8ca734d8","modified":1543920239702},{"_id":"public/archives/2018/07/index.html","hash":"1aaf92e41ded4aa6ef2e6c9bb1610a27bfe03e5d","modified":1543920239702},{"_id":"public/archives/2018/09/index.html","hash":"be36e0aa0bb787b5f7e94ee28dffee01857b5f85","modified":1543920239702},{"_id":"public/archives/2018/11/index.html","hash":"670a7e6eec4d64cdff5203a9cc0d302409200ba3","modified":1543920239702},{"_id":"public/archives/2018/12/index.html","hash":"188314a68339cdeef3dd03bb11d9fdf317911e47","modified":1543920239703},{"_id":"public/tags/ADB/index.html","hash":"d1aca204a4271fe985de031fa3cfcbfa0da70529","modified":1543920239703},{"_id":"public/tags/Android四大组件/index.html","hash":"ffcc69384a5db57fd42339e3a4de83dd6ea18b8e","modified":1543920239703},{"_id":"public/tags/Android/index.html","hash":"43053a7bd5a7e86d5b613609ecdcd4021e52de60","modified":1543920239703},{"_id":"public/tags/Android/page/2/index.html","hash":"5aeda841d87f8d05c68aad6fabb0fbc93d58088b","modified":1543920239703},{"_id":"public/tags/Gradle/index.html","hash":"03ef06887eefffd44c9cf1395fdd4883ae5c1261","modified":1543920239703},{"_id":"public/tags/Android性能优化/index.html","hash":"d41aec5a641005886ccc571cc33d1dcca7b72946","modified":1543920239703},{"_id":"public/tags/View事件分发机制/index.html","hash":"aecfa6e20e679e72dac6ba0a4d1469f3e1971208","modified":1543920239703},{"_id":"public/tags/Android进阶/index.html","hash":"db01063501e881cfee7df76e6689850816a9a164","modified":1543920239703},{"_id":"public/tags/内存优化/index.html","hash":"4709bf88c2f569cea3c33b74c2136068b7f953ed","modified":1543920239703},{"_id":"public/tags/Bugsnag/index.html","hash":"cce8c465775c5317f6db71e46e10afe5b1848f9c","modified":1543920239703},{"_id":"public/tags/hexo/index.html","hash":"e66a4ac866e211028bffceacc357f6fd3b84472d","modified":1543920239703},{"_id":"public/tags/github/index.html","hash":"c6f28e1552fe587905dfdc903c61083302123c93","modified":1543920239703},{"_id":"public/tags/Glide/index.html","hash":"fd5dba2a987500565883d63f3dc80c8971fb2210","modified":1543920239703},{"_id":"public/tags/HTTP/index.html","hash":"ce14ada814f730e546b33a206b8a52e900b0d86e","modified":1543920239703},{"_id":"public/tags/数据结构/index.html","hash":"7035fb654de8bf0e9219d15926f017275261a7ae","modified":1543920239703},{"_id":"public/tags/Java/index.html","hash":"1fe4b14589f4a55cd506f772a450f12ff1921b1f","modified":1543920239703},{"_id":"public/tags/MarkDown/index.html","hash":"393f26f15adfa51369e92a419e91bca72fed3d5f","modified":1543920239703},{"_id":"public/tags/OkHttp3/index.html","hash":"49dc46d440c4618254c465321fd2098f16c7cd7d","modified":1543920239703},{"_id":"public/tags/PackageManager/index.html","hash":"4240306a4e8503faf56887af727cd1f9ba489a8b","modified":1543920239703},{"_id":"public/tags/RxJava/index.html","hash":"e28b3858c54c11e1c45e8782b40da4c7e3d9000c","modified":1543920239703},{"_id":"public/tags/Book推荐/index.html","hash":"de2812c644adfe3fc6cb4f2a3a9d896b99d9768b","modified":1543920239703},{"_id":"public/tags/自定义View/index.html","hash":"98b82cd41376bd17c1febc4eae30d4f62c6f9c2d","modified":1543920239703},{"_id":"public/tags/设计模式/index.html","hash":"2e7587a2a4dd2c73d133ca511898bbc283bcc744","modified":1543920239704},{"_id":"public/tags/设计模式/page/2/index.html","hash":"9ab60c3334574908984853d03af7adf92217e36f","modified":1543920239704},{"_id":"public/2018/12/04/Java-线程池浅析/index.html","hash":"f546ce1c2f43e86547e03e5d274125f7d6aeb6f6","modified":1543920239704},{"_id":"public/2018/11/14/Java死锁浅析/index.html","hash":"c2d26a34198e68d891b8154995855a7c5e4c675e","modified":1543920239704},{"_id":"public/2018/11/07/Android-Studio3-0-Trace分析/index.html","hash":"02e9d96fee835655e04b622c31685ade76d6b0f9","modified":1543920239704},{"_id":"public/2018/09/18/Android四大组件之ContentProvider/index.html","hash":"9808d1e6184b6e7b9ea080d44da9d46cb40f3867","modified":1543920239704},{"_id":"public/2018/09/17/Android四大组件之BroadCast/index.html","hash":"640e6afe685072d590c970314eca947196156b48","modified":1543920239704},{"_id":"public/2018/07/27/Android过度绘制/index.html","hash":"f41cd5d1937f7ea9238c77cecca578c0b2a56f4a","modified":1543920239704},{"_id":"public/2018/05/30/主线程的Loop-loop-一直无限循环为什么不会造成ANR/index.html","hash":"d227a2731ef5d140d18008f244791d4c38603761","modified":1543920239704},{"_id":"public/2018/05/18/Android-7-0-so库兼容问题/index.html","hash":"9af098083d0810dc3d2f1979eb446c5c8ffdbb06","modified":1543920239704},{"_id":"public/2018/04/19/LruCache源码及原理分析/index.html","hash":"1e9cdcddff77f4a2b454b05885db84fe358320a2","modified":1543920239704},{"_id":"public/2018/04/16/Android四大组件之Service/index.html","hash":"e70f868b5e4a7228b33ef9c6bcaa48ae2805d843","modified":1543920239704},{"_id":"public/2018/04/15/Activity的四种启动模式/index.html","hash":"d9d4821417c4e692ee3901d28ddb3bc55f81ab3f","modified":1543920239704},{"_id":"public/2018/04/13/Android性能优化（一）/index.html","hash":"141c3c4507c44b5cd77d7a2e4d45e4f62dbca498","modified":1543920239704},{"_id":"public/2018/04/11/Bitmap-OOM解决方案/index.html","hash":"a62de88a9d42009e3fdee860918040df8d1e0d9c","modified":1543920239704},{"_id":"public/2018/03/22/IPC基础概念介绍/index.html","hash":"a7429ce91f7f079253b3c0209c0568c80c8df348","modified":1543920239704},{"_id":"public/2018/03/20/HashMap的实现原理/index.html","hash":"8dfac0510588aa6687e22d20ad61c151fad469d5","modified":1543920239704},{"_id":"public/2018/03/13/Android常见内存泄漏及解决办法/index.html","hash":"7afaebd58c69763d2756d2b6c68bc57de3bba2ad","modified":1543920239705},{"_id":"public/2017/12/30/Android-Gradle构建入门(一)/index.html","hash":"bcf1c5b7700883580d7daeef5d56f773449ac8e5","modified":1543920239705},{"_id":"public/2017/12/11/Glide4.x源码解析(1)-基本使用/index.html","hash":"1d5d4e36ec3e34f733bdc4f6b301673fb9c86742","modified":1543920239705},{"_id":"public/2017/12/08/Java并发编程：volatile关键字解析/index.html","hash":"0cb61abd8335769981bc0c5a53ae8dd587a4628f","modified":1543920239705},{"_id":"public/2017/10/25/PackageManager使用姿势/index.html","hash":"d985715786b458f990a3663ad5f7cb2d5e494b14","modified":1543920239705},{"_id":"public/2017/10/11/Android-View事件分发机制/index.html","hash":"528e962f7bd692279fa6fa68846f48cf34e71625","modified":1543920239706},{"_id":"public/2017/09/21/自定义View-2-Canvas简介/index.html","hash":"661e9d0dfc8feac868bfc11fe6ab3dbd14458081","modified":1543920239706},{"_id":"public/2017/09/11/设计模式之路（7）里氏替换原则/index.html","hash":"c64668fcfcc988456b752b22936b994b9d9026ff","modified":1543920239706},{"_id":"public/2017/09/10/设计模式之路（6）依赖倒转原则/index.html","hash":"f046b4d2a60f6ca3b04aac9a5ca5cc7a0b82ead1","modified":1543920239706},{"_id":"public/2017/09/04/RxJava2-0-四-Backpressure/index.html","hash":"06b4c38fd34f3dffe1ba059d358dd303ae59dcd1","modified":1543920239706},{"_id":"public/2017/09/03/多的是，你不知道的事/index.html","hash":"d4623471c4fa96195f029e82ecc0e22852560200","modified":1543920239706},{"_id":"public/2017/08/26/自定义View-一/index.html","hash":"b5d844feeb2358c69319ceee1897459ad2793c5f","modified":1543920239706},{"_id":"public/2017/08/12/RxJava2-0-三-变换操作/index.html","hash":"3d870e6157c03ee6e02872fbc1f9862b509be592","modified":1543920239706},{"_id":"public/2017/08/11/RxJava2-0-二/index.html","hash":"72e2d09ff48cfb7f45a56bfa443142420776ed69","modified":1543920239706},{"_id":"public/2017/08/10/RxJava2-0-一/index.html","hash":"b252e48cec1de56d966d051f1293d37cfcb4578d","modified":1543920239706},{"_id":"public/2017/07/28/OkHttp3源码学习（4）-Dispatcher/index.html","hash":"b9ccd11f53e603b63028da7f585742da8d8913de","modified":1543920239706},{"_id":"public/2017/07/27/OkHttp3源码学习（3）/index.html","hash":"a0f52ee1da31358c28f4614c33748f8232be16d5","modified":1543920239706},{"_id":"public/2017/07/26/OkHttp3源码学习（2）/index.html","hash":"e741e32671b9e25654d70cde1c34615b25ef66da","modified":1543920239706},{"_id":"public/2017/07/25/OkHttp3源码学习（1）/index.html","hash":"8d3cfb2aa62ede8e543bc98a7a24ff2cd217dd93","modified":1543920239706},{"_id":"public/2017/07/24/设计模式之路（5）代理模式/index.html","hash":"28a37a2f735d34b4ef6c522ee1c34ffba7173b2a","modified":1543920239706},{"_id":"public/2017/07/20/Android屏幕适配解决方案(1)/index.html","hash":"37a532f0c79b4d39ac837092e9201cedff5b183d","modified":1543920239706},{"_id":"public/2017/07/19/设计模式之路（4）装饰者模式/index.html","hash":"60198605c9505c570ff8733cb2240178eae36f63","modified":1543920239706},{"_id":"public/2017/07/18/设计模式之路（3）开放-封闭原则/index.html","hash":"2cee94a83d24363410f9be25315f4b9283506a45","modified":1543920239706},{"_id":"public/2017/07/18/设计模式之路（2）单一职责原则/index.html","hash":"9207d80bcbbc414bca5efe846c3a2d037fc8a22d","modified":1543920239707},{"_id":"public/2017/07/17/设计模式之路（1）-简单工厂模式/index.html","hash":"6786183027f82d177ed6ba3525be4236c249694f","modified":1543920239707},{"_id":"public/2017/07/14/Bugsnag-监控应用程序错误，以改善客户体验和代码质量/index.html","hash":"ad64fbea2bfc725e032f0098d52e4b0b9fd41500","modified":1543920239707},{"_id":"public/2017/07/12/Android-MVPB/index.html","hash":"8426ecc65cae9597f933b59fea6f4f1a8c75835e","modified":1543920239707},{"_id":"public/2017/02/22/Set集合使用注意tips/index.html","hash":"b8e5b4cde2ea8407e5e6edc14467ed8ea27af9f9","modified":1543920239707},{"_id":"public/2016/11/19/HTTP需要知道的知识点-补充/index.html","hash":"ba832f1820b57182b5b2d1fb8f1c4406b5e52fee","modified":1543920239707},{"_id":"public/2016/11/13/关于HTTP需要理解的知识点/index.html","hash":"e8ad310dd2dfd31b7858c90ba6c01317c77dba39","modified":1543920239707},{"_id":"public/2016/09/24/Hexo-Github搭建个人博客（4）/index.html","hash":"6e80cd93d6401fa2a684063ec796e8e0ed09cc42","modified":1543920239707},{"_id":"public/2016/09/15/Github-hexo搭建个人博客（3）/index.html","hash":"87e8d20eaffd1397f7fda375cf6c91f7e68a34d3","modified":1543920239708},{"_id":"public/2016/09/14/Hexo-Github搭建个人博客（2）/index.html","hash":"4ff98fbc2e4d4f1d801484132497508c2ea4cafb","modified":1543920239708},{"_id":"public/2016/09/12/Git提交index.lock问题解决/index.html","hash":"3d160b84cade3a9623d8bf1657c77904fb8bc497","modified":1543920239708},{"_id":"public/2016/09/10/Hexo+Github搭建个人博客（1）/index.html","hash":"c5b6eda43c841e9a96ee7e4620f71b5cd9a98fb0","modified":1543920239708},{"_id":"public/2016/09/04/MarkDown语法/index.html","hash":"b1807f7dca73f486b5f816d633a7451ffa1c6df6","modified":1543920239708},{"_id":"public/2016/09/02/ADB常用命令备忘录/index.html","hash":"3e8ac766063feb9b8a6a778c53f33dfd1495e936","modified":1543920239708},{"_id":"public/2016/09/01/hello-world/index.html","hash":"94c1854adcab41ce52a005f3b10cd351420848af","modified":1543920239708},{"_id":"public/archives/index.html","hash":"eb737201e68bd1b87a3e83aba7077433c58ed5ce","modified":1543920239708},{"_id":"public/archives/2016/index.html","hash":"2c4eb00f4a0040aef10ed6f507e92ea1878b1a51","modified":1543920239708},{"_id":"public/archives/2017/index.html","hash":"3820c6698a5bd27bef42867c0001fa4bfdf0d2bd","modified":1543920239708},{"_id":"public/archives/2017/07/index.html","hash":"38b4849f2382ccd48da1b1486ef0f2f60cc379e0","modified":1543920239708},{"_id":"public/archives/2018/index.html","hash":"a263fda8164c6d8ef2cedc97aef4e0289a23d487","modified":1543920239708},{"_id":"public/index.html","hash":"4876ab5f7045475c6c0b029764153a9db0dd5054","modified":1543920239708},{"_id":"public/page/2/index.html","hash":"aac6a21b654092afed30ffb14ebc816b27e2c4d1","modified":1543920239708},{"_id":"public/page/3/index.html","hash":"f7cc086fa0bb81dc96a32b55f34381ae3a54014c","modified":1543920239708},{"_id":"public/page/4/index.html","hash":"2b1ac3fb1a6a23e81746e76986fd5bbd5053cfc4","modified":1543920239708},{"_id":"public/page/5/index.html","hash":"33bfaac068ebf39d2dc222eb703d4a3178b31746","modified":1543920239709},{"_id":"public/page/6/index.html","hash":"22c5936f83aee3713033d1b5084062b8684df275","modified":1543920239709},{"_id":"public/page/7/index.html","hash":"0cef89d2a0e8bcdc9e8dc756dd6e998253593ad4","modified":1543920239709},{"_id":"public/page/8/index.html","hash":"3f11ffcca957b7ae308aa6bb19606236e57d15ef","modified":1543920239709},{"_id":"public/page/9/index.html","hash":"daeb167adc60ba0f111e04c1542b45f51df7447e","modified":1543920239709},{"_id":"public/page/10/index.html","hash":"f51349ec8894977c67ae06f2e65a102b6e082a58","modified":1543920239709},{"_id":"public/page/11/index.html","hash":"abeefc360446404b2bf3d339868da1f32aca8678","modified":1543920239709},{"_id":"public/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1543920239730},{"_id":"public/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1543920239730},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1543920239730},{"_id":"public/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1543920239730},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543920239731},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543920239731},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543920239731},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543920239731},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543920239731},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543920239731},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543920239731},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543920239731},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543920239731},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543920239731},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543920239731},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543920239731},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1543920239731},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543920239731},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543920239731},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543920239731},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543920239731},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543920239731},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543920239732},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543920239733},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543920239733},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1543920239733},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1543920239733},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1543920239733},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1543920239733},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543920239733},{"_id":"public/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1543920240266},{"_id":"public/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1543920240268},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543920240280},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543920240280},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543920240290},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543920240290},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1543920240290},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543920240290},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543920240290},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1543920240290},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1543920240290},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543920240290},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543920240290},{"_id":"public/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1543920240290},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1543920240290},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1543920240290},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1543920240290},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1543920240290},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1543920240290},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1543920240290},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543920240290},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1543920240290},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1543920240290},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1543920240290},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543920240290},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1543920240290},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1543920240291},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1543920240291},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1543920240291},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543920240291},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1543920240291},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543920240291},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543920240291},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543920240291},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543920240291},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543920240291},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543920240291},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543920240291},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543920240291},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543920240291},{"_id":"public/css/main.css","hash":"294dcabe4443cfa84aee2b94fbecf4194adb2e7f","modified":1543920240291},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1543920240291},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1543920240291},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1543920240291},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543920240291},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543920240291},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543920240291},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1543920240291},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543920240291},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1543920240291},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543920240291},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543920240291},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543920240291},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543920240291},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543920240291},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1543920240292},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1543920240292},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1543920240292},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1543920240292},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1543920240292},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543920240292},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1543920240292},{"_id":"public/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1543920240294},{"_id":"public/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1543920240300},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1543920240300}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-07-10T08:42:29.000Z","_content":"## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-07-10 16:42:29\n---\n## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","updated":"2018-12-04T09:15:25.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjp9m8tmp0001x3c0ic5oq86b","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n"},{"title":"tags","date":"2017-07-10T08:24:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-07-10 16:24:17\ntype: \"tags\"\n---\n","updated":"2018-12-04T09:15:25.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjp9m8tmr0003x3c0o1g9ay75","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ADB常用命令备忘录","date":"2016-09-02T15:27:48.000Z","_content":"\n* adb start-server\t启动服务\n\n* adb kill-server\t关闭服务\n\n* adb devices\t显示当前连接的所有设备（如果服务没有开启会自动开启）\n\n* adb install xxx.apk\t将应用安装进设备中\n\n* adb uninstall <包名>\t卸载应用\n\n* adb -s <设备名> <命令>\t如果有多个设备，指定某一个设备进行操作\n\n* adb pull <手机文件> <电脑文件>\t将手机内文件导入到电脑上(文件名均为全称)\n\n* adb push <电脑文件> <手机文件>\t将电脑中文件推送到手机上(文件名均为全称)\n\n* adb shell\t进入手机命令行终端\n\n* adb logcat  打印 Android 的系统日志\n\n* adb logcat | grep MyApp 匹配字符串过滤\n* adb logcat | grep -i myapp 忽略大小写通过字符串过滤\n\n* adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误\n\n* adb bugreport > d:\\bugreport.log  输出比较多，建议重定向到一个文件中\n\n* adb shell pm list package\t不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）\n\n* adb shell pm list package -3\t列出第三方应用\t-s：列出系统应用\t命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用\n\n\n* logcat | grep ActivityManager :查看当前运行的Activity\n* adb shell dumpsys activity activities | grep \"Run\":查看当前运行的Activity ","source":"_posts/ADB常用命令备忘录.md","raw":"---\ntitle: ADB常用命令备忘录\ndate: 2016-09-02 23:27:48\ntags: [ADB]\n---\n\n* adb start-server\t启动服务\n\n* adb kill-server\t关闭服务\n\n* adb devices\t显示当前连接的所有设备（如果服务没有开启会自动开启）\n\n* adb install xxx.apk\t将应用安装进设备中\n\n* adb uninstall <包名>\t卸载应用\n\n* adb -s <设备名> <命令>\t如果有多个设备，指定某一个设备进行操作\n\n* adb pull <手机文件> <电脑文件>\t将手机内文件导入到电脑上(文件名均为全称)\n\n* adb push <电脑文件> <手机文件>\t将电脑中文件推送到手机上(文件名均为全称)\n\n* adb shell\t进入手机命令行终端\n\n* adb logcat  打印 Android 的系统日志\n\n* adb logcat | grep MyApp 匹配字符串过滤\n* adb logcat | grep -i myapp 忽略大小写通过字符串过滤\n\n* adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误\n\n* adb bugreport > d:\\bugreport.log  输出比较多，建议重定向到一个文件中\n\n* adb shell pm list package\t不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）\n\n* adb shell pm list package -3\t列出第三方应用\t-s：列出系统应用\t命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用\n\n\n* logcat | grep ActivityManager :查看当前运行的Activity\n* adb shell dumpsys activity activities | grep \"Run\":查看当前运行的Activity ","slug":"ADB常用命令备忘录","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tme0000x3c0no91o5xu","content":"<ul>\n<li><p>adb start-server    启动服务</p>\n</li>\n<li><p>adb kill-server    关闭服务</p>\n</li>\n<li><p>adb devices    显示当前连接的所有设备（如果服务没有开启会自动开启）</p>\n</li>\n<li><p>adb install xxx.apk    将应用安装进设备中</p>\n</li>\n<li><p>adb uninstall &lt;包名&gt;    卸载应用</p>\n</li>\n<li><p>adb -s &lt;设备名&gt; &lt;命令&gt;    如果有多个设备，指定某一个设备进行操作</p>\n</li>\n<li><p>adb pull &lt;手机文件&gt; &lt;电脑文件&gt;    将手机内文件导入到电脑上(文件名均为全称)</p>\n</li>\n<li><p>adb push &lt;电脑文件&gt; &lt;手机文件&gt;    将电脑中文件推送到手机上(文件名均为全称)</p>\n</li>\n<li><p>adb shell    进入手机命令行终端</p>\n</li>\n<li><p>adb logcat  打印 Android 的系统日志</p>\n</li>\n<li><p>adb logcat | grep MyApp 匹配字符串过滤</p>\n</li>\n<li><p>adb logcat | grep -i myapp 忽略大小写通过字符串过滤</p>\n</li>\n<li><p>adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误</p>\n</li>\n<li><p>adb bugreport &gt; d:\\bugreport.log  输出比较多，建议重定向到一个文件中</p>\n</li>\n<li><p>adb shell pm list package    不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）</p>\n</li>\n<li><p>adb shell pm list package -3    列出第三方应用    -s：列出系统应用    命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用</p>\n</li>\n</ul>\n<ul>\n<li>logcat | grep ActivityManager :查看当前运行的Activity</li>\n<li>adb shell dumpsys activity activities | grep “Run”:查看当前运行的Activity </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>adb start-server    启动服务</p>\n</li>\n<li><p>adb kill-server    关闭服务</p>\n</li>\n<li><p>adb devices    显示当前连接的所有设备（如果服务没有开启会自动开启）</p>\n</li>\n<li><p>adb install xxx.apk    将应用安装进设备中</p>\n</li>\n<li><p>adb uninstall &lt;包名&gt;    卸载应用</p>\n</li>\n<li><p>adb -s &lt;设备名&gt; &lt;命令&gt;    如果有多个设备，指定某一个设备进行操作</p>\n</li>\n<li><p>adb pull &lt;手机文件&gt; &lt;电脑文件&gt;    将手机内文件导入到电脑上(文件名均为全称)</p>\n</li>\n<li><p>adb push &lt;电脑文件&gt; &lt;手机文件&gt;    将电脑中文件推送到手机上(文件名均为全称)</p>\n</li>\n<li><p>adb shell    进入手机命令行终端</p>\n</li>\n<li><p>adb logcat  打印 Android 的系统日志</p>\n</li>\n<li><p>adb logcat | grep MyApp 匹配字符串过滤</p>\n</li>\n<li><p>adb logcat | grep -i myapp 忽略大小写通过字符串过滤</p>\n</li>\n<li><p>adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误</p>\n</li>\n<li><p>adb bugreport &gt; d:\\bugreport.log  输出比较多，建议重定向到一个文件中</p>\n</li>\n<li><p>adb shell pm list package    不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）</p>\n</li>\n<li><p>adb shell pm list package -3    列出第三方应用    -s：列出系统应用    命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用</p>\n</li>\n</ul>\n<ul>\n<li>logcat | grep ActivityManager :查看当前运行的Activity</li>\n<li>adb shell dumpsys activity activities | grep “Run”:查看当前运行的Activity </li>\n</ul>\n"},{"title":"Activity的四种启动模式","date":"2018-04-15T06:33:26.000Z","_content":"\n作为基础回顾~\n\n\n#### 一、Activity的四种启动模式简介\n\nActivity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。\n\n如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：\n\n\t<activity android:name=\"com.app.TestActivity\" android:launchMode=\"standard\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\"/>\n            <category android:name=\"android.intent.category.LAUNCHER\"/>\n        </intent-filter>\n\t</activity>\n\n#### 二、四种模式详解\n\n* standard\n\nstandard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。\n\n* singletop\n\nsingletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。\n\n* singletask\n\nsingletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。\n\n那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。\n\n需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。\n\n* singleInstance\n\nsingleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。","source":"_posts/Activity的四种启动模式.md","raw":"---\ntitle: Activity的四种启动模式\ndate: 2018-04-15 14:33:26\ntags: [Android四大组件]\n---\n\n作为基础回顾~\n\n\n#### 一、Activity的四种启动模式简介\n\nActivity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。\n\n如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：\n\n\t<activity android:name=\"com.app.TestActivity\" android:launchMode=\"standard\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\"/>\n            <category android:name=\"android.intent.category.LAUNCHER\"/>\n        </intent-filter>\n\t</activity>\n\n#### 二、四种模式详解\n\n* standard\n\nstandard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。\n\n* singletop\n\nsingletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。\n\n* singletask\n\nsingletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。\n\n那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。\n\n需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。\n\n* singleInstance\n\nsingleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。","slug":"Activity的四种启动模式","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tmq0002x3c01ibrohxk","content":"<p>作为基础回顾~</p>\n<h4 id=\"一、Activity的四种启动模式简介\"><a href=\"#一、Activity的四种启动模式简介\" class=\"headerlink\" title=\"一、Activity的四种启动模式简介\"></a>一、Activity的四种启动模式简介</h4><p>Activity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。</p>\n<p>如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：</p>\n<pre><code>&lt;activity android:name=&quot;com.app.TestActivity&quot; android:launchMode=&quot;standard&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre><h4 id=\"二、四种模式详解\"><a href=\"#二、四种模式详解\" class=\"headerlink\" title=\"二、四种模式详解\"></a>二、四种模式详解</h4><ul>\n<li>standard</li>\n</ul>\n<p>standard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。</p>\n<ul>\n<li>singletop</li>\n</ul>\n<p>singletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。</p>\n<ul>\n<li>singletask</li>\n</ul>\n<p>singletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。</p>\n<p>那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。</p>\n<p>需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。</p>\n<ul>\n<li>singleInstance</li>\n</ul>\n<p>singleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为基础回顾~</p>\n<h4 id=\"一、Activity的四种启动模式简介\"><a href=\"#一、Activity的四种启动模式简介\" class=\"headerlink\" title=\"一、Activity的四种启动模式简介\"></a>一、Activity的四种启动模式简介</h4><p>Activity是通过Activity栈来进行管理的。当一个Activity启动时，那么就会根据系统配置来将Activity压入栈中。当Back返回或销毁时,Activity出栈。</p>\n<p>如果不指定Activity的启动模式，那么将以默认模式启动。如果要指定启动模式，在AndroidManifest中指定Activity的启动模式。例如：</p>\n<pre><code>&lt;activity android:name=&quot;com.app.TestActivity&quot; android:launchMode=&quot;standard&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre><h4 id=\"二、四种模式详解\"><a href=\"#二、四种模式详解\" class=\"headerlink\" title=\"二、四种模式详解\"></a>二、四种模式详解</h4><ul>\n<li>standard</li>\n</ul>\n<p>standard,标准模式。是Activity的系统默认启动模式。每次启动一个Activity都会创建一个新的实例，不管该Activity的实例是否存在。</p>\n<ul>\n<li>singletop</li>\n</ul>\n<p>singletop,栈顶复用模式。这种模式下，如果启动的Activity就在栈顶，那么复用栈顶的Activity，并且调用onNewIntent()方法。通过这个方法，可以取到当前请求的数据。如果启动的Activity已存在，但是不在栈顶，那么就会重新创建新的实例。</p>\n<ul>\n<li>singletask</li>\n</ul>\n<p>singletask,栈内复用模式。在这种模式下，是单实例模式，在这种模式下，只要启动的Activity在任何一个任务栈中存在，就不会重新创建新的实例。和singletop一样，会调用onNewIntent方法。</p>\n<p>那么在启动的时候，先找有没有实例在Activity栈中，如果有那么就会将要启动的Activity置于栈顶，并且调用onNewIntent方法。如果没有那么就会创建新的实例压入栈中。</p>\n<p>需要注意的是，singletask默认是cleartop,会将栈内将要启动的Activity实例上面的Activity全部出栈。使启动的Activity实例位于栈顶。</p>\n<ul>\n<li>singleInstance</li>\n</ul>\n<p>singleInstance,单个实例模式。这种模式下，Activity只能单独的在一个任务栈中存在。当启动一个Activity启动模式为singleInstance时，系统会新建一个任务栈，该实例压入栈中，仅有该实例存在。</p>\n"},{"title":"Android 7.0 so库兼容问题","date":"2018-05-18T02:38:07.000Z","_content":"\n目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。\n\n系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，\n\n![加密库兼容问题](http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png)\n\n发扬面向百度编程的精神，百度到网上相关资料分析。\n\n问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。\n\n解决方案：\n\n可以采用gradle引用更高版本的包，\n\ncompile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ \n\t\n或者\n\ncompile ‘net.zetetic:android-database-sqlcipher:3.5.9’ \n\n\n对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。\n\n详见：https://blog.csdn.net/qklnmc/article/details/77967636\n\n","source":"_posts/Android-7-0-so库兼容问题.md","raw":"---\ntitle: Android 7.0 so库兼容问题\ndate: 2018-05-18 10:38:07\ntags: [Android]\n---\n\n目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。\n\n系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，\n\n![加密库兼容问题](http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png)\n\n发扬面向百度编程的精神，百度到网上相关资料分析。\n\n问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。\n\n解决方案：\n\n可以采用gradle引用更高版本的包，\n\ncompile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ \n\t\n或者\n\ncompile ‘net.zetetic:android-database-sqlcipher:3.5.9’ \n\n\n对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。\n\n详见：https://blog.csdn.net/qklnmc/article/details/77967636\n\n","slug":"Android-7-0-so库兼容问题","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tmv0005x3c0xffhcbpb","content":"<p>目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。</p>\n<p>系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png\" alt=\"加密库兼容问题\"></p>\n<p>发扬面向百度编程的精神，百度到网上相关资料分析。</p>\n<p>问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。</p>\n<p>解决方案：</p>\n<p>可以采用gradle引用更高版本的包，</p>\n<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ </p>\n<p>或者</p>\n<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9’ </p>\n<p>对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。</p>\n<p>详见：<a href=\"https://blog.csdn.net/qklnmc/article/details/77967636\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/qklnmc/article/details/77967636</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>目前做的项目中，是用sqlcipher来进行数据库加密的。在适配的过程中遇到了问题。</p>\n<p>系统为Android7.0时，在进入项目APP的时候，系统会弹出一个对话框。如图，</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/Screenshot_20180525-155021.png\" alt=\"加密库兼容问题\"></p>\n<p>发扬面向百度编程的精神，百度到网上相关资料分析。</p>\n<p>问题分析，引入的sqlicipher.so库版本太低了，项目中引用的是3.1.0的版本。Android7.0中会报问题，系统就会弹框提示。</p>\n<p>解决方案：</p>\n<p>可以采用gradle引用更高版本的包，</p>\n<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9@aar’ </p>\n<p>或者</p>\n<p>compile ‘net.zetetic:android-database-sqlcipher:3.5.9’ </p>\n<p>对比低版本的包。发现低版本中没有X86_64,可能问题出在这里。</p>\n<p>详见：<a href=\"https://blog.csdn.net/qklnmc/article/details/77967636\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/qklnmc/article/details/77967636</a></p>\n"},{"title":"Android Gradle构建入门 (一)","date":"2017-12-30T09:35:50.000Z","_content":"\n### Android Gradle入门\n\n##### 本文内容来自官方文档整理\n\n\n#### 一、查看生成的Gradle文件列表\n\n默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：\n\n![“asmodel”](http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png)\n\n\n\nAndroid项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。\n\n\n在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。\n\n* settings.gradle\n\n\nGradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：\n\n\tinclude ':app'\n\t\n这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。\n\n* gradle-wrapper.properties\n\n\ngradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：\n\n\tdistributionBase=GRADLE_USER_HOME\n\tdistributionPath=wrapper/dists\n\tzipStoreBase=GRADLE_USER_HOME\n\tzipStorePath=wrapper/dists\n\tdistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n\t\n前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。\n\n最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）\n\n\n#### 二、查看整个项目的build.gradle\n\nproject的build.geadle文件：\n\n\t// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\t\n\tbuildscript {\n\t    \n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t    dependencies {\n\t        classpath 'com.android.tools.build:gradle:3.0.0'\n\t        \n\t\n\t        // NOTE: Do not place your application dependencies here; they belong\n\t        // in the individual module build.gradle files\n\t    }\n\t}\n\t\n\tallprojects {\n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t}\n\t\n\ttask clean(type: Delete) {\n\t    delete rootProject.buildDir\n\t}\n\n\n各个代码块具体作用：\n\n1. buildscript - 下载插件\n2. dependencies - 标识Android插件\n3. allproject - \ttop-level and module projects的配置\n4. task clean - 特设任务\n\nGradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。\n\n当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。\n\nallprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从https://jcenter.bintray.com上的公共Bintray Artifactory存储库的google或jcenter下载。\n\n最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。\n\n#### 三、查看app module的build.gradle\n\n看一下 build.gradle\n\n\tapply plugin: 'com.android.application'\n\t\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n第一行：\n\n\tapply plugin: 'com.android.application'\n\t\n应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。\n\n\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n对这些属性进行简单的介绍：\n\n* compileSdkVersion：Android SDK版本\n* defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。\n\t* applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。\n\n\t\n\t* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\t\n\t* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n\t* versionName:版本名称值用于自己的内部版本跟踪。\n\n\t* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n\n\n\n在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。\n\n\t  buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\n\n继续往下面看，就是这个应用程序所依赖的库\n\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。\n\ntestImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。\n\nandroidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。\n\n\n\tfileTree(dir: 'libs', include: ['*.jar'])\n\t\n是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中\n\n\tcom.android.support:appcompat-v7:26.1.0\n\t\n将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。\n\n\tcom.android.support.constraint:constraint-layout:1.0.2\n\t\n将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。\n\n\n#### 四、运行标准的Gradle任务\n\nAndroid Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建\n\n\t$ ./gradlew build\n\t\n构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.\n\n* 可以在命令行中显示在项目中使用的support-annotations模块的版本。\n\n执行命令，可以看到结果：\n\n\t$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n\t:app:dependencies\n\t\n\t------------------------------------------------------------\n\tProject :app\n\t------------------------------------------------------------\n\t\n\treleaseCompileClasspath - Resolved configuration for compilation for variant: release\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    +--- com.android.support:support-annotations:26.1.0\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    +--- com.android.support:support-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n\t|    |    |         +--- android.arch.lifecycle:common:1.0.0\n\t|    |    |         \\--- android.arch.core:common:1.0.0\n\t|    |    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-ui:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0\n\t|    |         +--- com.android.support:support-compat:26.1.0 (*)\n\t|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n\t|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\t\\--- com.android.support.constraint:constraint-layout:1.0.2\n\t     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\n\n\n从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库\n\n\n* 另一种方式查看所需的版本\n\n执行命令及结果：\n\n\t$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n\t:app:dependencyInsight\n\tcom.android.support:support-annotations:26.1.0\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    \\--- releaseCompileClasspath\n\t+--- com.android.support:support-compat:26.1.0\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-fragment:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    +--- com.android.support:support-v4:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n\t|    \\--- com.android.support:support-core-ui:26.1.0\n\t|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n\t|         +--- com.android.support:support-v4:26.1.0 (*)\n\t|         \\--- com.android.support:support-fragment:26.1.0 (*)\n\t+--- com.android.support:support-core-ui:26.1.0 (*)\n\t+--- com.android.support:support-core-utils:26.1.0 (*)\n\t+--- com.android.support:support-media-compat:26.1.0 (*)\n\t\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\t\n\n这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。\n\n#### 五、查看Gradle窗口可执行的命令\n\n![\"gradle window\"](http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png)\n\n可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：\n\n\tExecuting tasks: [signingReport]\n\t\n\tConfiguration on demand is an incubating feature.\n\t:app:signingReport\n\tVariant: release\n\tConfig: none\n\t----------\n\tVariant: releaseUnitTest\n\tConfig: none\n\t----------\n\tVariant: debug\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugAndroidTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugUnitTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\t\n\tBUILD SUCCESSFUL in 14s\n\t1 actionable task: 1 executed\n\t\n\t\n从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）\n\n\n下面的install，可以通过installDebug来安装应用\n\n也可用命令行来执行：\n\n\t$ ./gradlew installDebug\n\t\n\n\n\n","source":"_posts/Android-Gradle构建入门(一).md","raw":"---\ntitle: Android Gradle构建入门 (一)\ndate: 2017-12-30 17:35:50\ntags: [Gradle]\n---\n\n### Android Gradle入门\n\n##### 本文内容来自官方文档整理\n\n\n#### 一、查看生成的Gradle文件列表\n\n默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：\n\n![“asmodel”](http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png)\n\n\n\nAndroid项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。\n\n\n在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。\n\n* settings.gradle\n\n\nGradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：\n\n\tinclude ':app'\n\t\n这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。\n\n* gradle-wrapper.properties\n\n\ngradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：\n\n\tdistributionBase=GRADLE_USER_HOME\n\tdistributionPath=wrapper/dists\n\tzipStoreBase=GRADLE_USER_HOME\n\tzipStorePath=wrapper/dists\n\tdistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n\t\n前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。\n\n最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）\n\n\n#### 二、查看整个项目的build.gradle\n\nproject的build.geadle文件：\n\n\t// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\t\n\tbuildscript {\n\t    \n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t    dependencies {\n\t        classpath 'com.android.tools.build:gradle:3.0.0'\n\t        \n\t\n\t        // NOTE: Do not place your application dependencies here; they belong\n\t        // in the individual module build.gradle files\n\t    }\n\t}\n\t\n\tallprojects {\n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t}\n\t\n\ttask clean(type: Delete) {\n\t    delete rootProject.buildDir\n\t}\n\n\n各个代码块具体作用：\n\n1. buildscript - 下载插件\n2. dependencies - 标识Android插件\n3. allproject - \ttop-level and module projects的配置\n4. task clean - 特设任务\n\nGradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。\n\n当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。\n\nallprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从https://jcenter.bintray.com上的公共Bintray Artifactory存储库的google或jcenter下载。\n\n最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。\n\n#### 三、查看app module的build.gradle\n\n看一下 build.gradle\n\n\tapply plugin: 'com.android.application'\n\t\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n第一行：\n\n\tapply plugin: 'com.android.application'\n\t\n应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。\n\n\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n对这些属性进行简单的介绍：\n\n* compileSdkVersion：Android SDK版本\n* defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。\n\t* applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。\n\n\t\n\t* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\t\n\t* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n\t* versionName:版本名称值用于自己的内部版本跟踪。\n\n\t* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n\n\n\n在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。\n\n\t  buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\n\n继续往下面看，就是这个应用程序所依赖的库\n\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。\n\ntestImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。\n\nandroidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。\n\n\n\tfileTree(dir: 'libs', include: ['*.jar'])\n\t\n是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中\n\n\tcom.android.support:appcompat-v7:26.1.0\n\t\n将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。\n\n\tcom.android.support.constraint:constraint-layout:1.0.2\n\t\n将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。\n\n\n#### 四、运行标准的Gradle任务\n\nAndroid Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建\n\n\t$ ./gradlew build\n\t\n构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.\n\n* 可以在命令行中显示在项目中使用的support-annotations模块的版本。\n\n执行命令，可以看到结果：\n\n\t$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n\t:app:dependencies\n\t\n\t------------------------------------------------------------\n\tProject :app\n\t------------------------------------------------------------\n\t\n\treleaseCompileClasspath - Resolved configuration for compilation for variant: release\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    +--- com.android.support:support-annotations:26.1.0\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    +--- com.android.support:support-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n\t|    |    |         +--- android.arch.lifecycle:common:1.0.0\n\t|    |    |         \\--- android.arch.core:common:1.0.0\n\t|    |    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-ui:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0\n\t|    |         +--- com.android.support:support-compat:26.1.0 (*)\n\t|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n\t|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\t\\--- com.android.support.constraint:constraint-layout:1.0.2\n\t     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\n\n\n从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库\n\n\n* 另一种方式查看所需的版本\n\n执行命令及结果：\n\n\t$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n\t:app:dependencyInsight\n\tcom.android.support:support-annotations:26.1.0\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    \\--- releaseCompileClasspath\n\t+--- com.android.support:support-compat:26.1.0\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-fragment:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    +--- com.android.support:support-v4:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n\t|    \\--- com.android.support:support-core-ui:26.1.0\n\t|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n\t|         +--- com.android.support:support-v4:26.1.0 (*)\n\t|         \\--- com.android.support:support-fragment:26.1.0 (*)\n\t+--- com.android.support:support-core-ui:26.1.0 (*)\n\t+--- com.android.support:support-core-utils:26.1.0 (*)\n\t+--- com.android.support:support-media-compat:26.1.0 (*)\n\t\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\t\n\n这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。\n\n#### 五、查看Gradle窗口可执行的命令\n\n![\"gradle window\"](http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png)\n\n可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：\n\n\tExecuting tasks: [signingReport]\n\t\n\tConfiguration on demand is an incubating feature.\n\t:app:signingReport\n\tVariant: release\n\tConfig: none\n\t----------\n\tVariant: releaseUnitTest\n\tConfig: none\n\t----------\n\tVariant: debug\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugAndroidTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugUnitTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\t\n\tBUILD SUCCESSFUL in 14s\n\t1 actionable task: 1 executed\n\t\n\t\n从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）\n\n\n下面的install，可以通过installDebug来安装应用\n\n也可用命令行来执行：\n\n\t$ ./gradlew installDebug\n\t\n\n\n\n","slug":"Android-Gradle构建入门(一)","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tmw0006x3c0oh44td37","content":"<h3 id=\"Android-Gradle入门\"><a href=\"#Android-Gradle入门\" class=\"headerlink\" title=\"Android Gradle入门\"></a>Android Gradle入门</h3><h5 id=\"本文内容来自官方文档整理\"><a href=\"#本文内容来自官方文档整理\" class=\"headerlink\" title=\"本文内容来自官方文档整理\"></a>本文内容来自官方文档整理</h5><h4 id=\"一、查看生成的Gradle文件列表\"><a href=\"#一、查看生成的Gradle文件列表\" class=\"headerlink\" title=\"一、查看生成的Gradle文件列表\"></a>一、查看生成的Gradle文件列表</h4><p>默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png\" alt=\"“asmodel”\"></p>\n<p>Android项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。</p>\n<p>在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。</p>\n<ul>\n<li>settings.gradle</li>\n</ul>\n<p>Gradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：</p>\n<pre><code>include &apos;:app&apos;\n</code></pre><p>这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。</p>\n<ul>\n<li>gradle-wrapper.properties</li>\n</ul>\n<p>gradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n</code></pre><p>前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。</p>\n<p>最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）</p>\n<h4 id=\"二、查看整个项目的build-gradle\"><a href=\"#二、查看整个项目的build-gradle\" class=\"headerlink\" title=\"二、查看整个项目的build.gradle\"></a>二、查看整个项目的build.gradle</h4><p>project的build.geadle文件：</p>\n<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;\n\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>各个代码块具体作用：</p>\n<ol>\n<li>buildscript - 下载插件</li>\n<li>dependencies - 标识Android插件</li>\n<li>allproject -     top-level and module projects的配置</li>\n<li>task clean - 特设任务</li>\n</ol>\n<p>Gradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。</p>\n<p>当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。</p>\n<p>allprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从<a href=\"https://jcenter.bintray.com上的公共Bintray\" target=\"_blank\" rel=\"external\">https://jcenter.bintray.com上的公共Bintray</a> Artifactory存储库的google或jcenter下载。</p>\n<p>最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。</p>\n<h4 id=\"三、查看app-module的build-gradle\"><a href=\"#三、查看app-module的build-gradle\" class=\"headerlink\" title=\"三、查看app module的build.gradle\"></a>三、查看app module的build.gradle</h4><p>看一下 build.gradle</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>第一行：</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n</code></pre><p>应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。</p>\n<pre><code>android {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n</code></pre><p>对这些属性进行简单的介绍：</p>\n<ul>\n<li>compileSdkVersion：Android SDK版本</li>\n<li>defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。<ul>\n<li>applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。</li>\n</ul>\n</li>\n</ul>\n<pre><code>* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\n* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n* versionName:版本名称值用于自己的内部版本跟踪。\n\n* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n</code></pre><p>在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。</p>\n<pre><code>buildTypes {\n      release {\n          minifyEnabled false\n          proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n      }\n  }\n</code></pre><p>继续往下面看，就是这个应用程序所依赖的库</p>\n<pre><code>dependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。</p>\n<p>testImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。</p>\n<p>androidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。</p>\n<pre><code>fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n</code></pre><p>是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中</p>\n<pre><code>com.android.support:appcompat-v7:26.1.0\n</code></pre><p>将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。</p>\n<pre><code>com.android.support.constraint:constraint-layout:1.0.2\n</code></pre><p>将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。</p>\n<h4 id=\"四、运行标准的Gradle任务\"><a href=\"#四、运行标准的Gradle任务\" class=\"headerlink\" title=\"四、运行标准的Gradle任务\"></a>四、运行标准的Gradle任务</h4><p>Android Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建</p>\n<pre><code>$ ./gradlew build\n</code></pre><p>构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.</p>\n<ul>\n<li>可以在命令行中显示在项目中使用的support-annotations模块的版本。</li>\n</ul>\n<p>执行命令，可以看到结果：</p>\n<pre><code>$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n:app:dependencies\n\n------------------------------------------------------------\nProject :app\n------------------------------------------------------------\n\nreleaseCompileClasspath - Resolved configuration for compilation for variant: release\n+--- com.android.support:appcompat-v7:26.1.0\n|    +--- com.android.support:support-annotations:26.1.0\n|    +--- com.android.support:support-v4:26.1.0\n|    |    +--- com.android.support:support-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n|    |    |         +--- android.arch.lifecycle:common:1.0.0\n|    |    |         \\--- android.arch.core:common:1.0.0\n|    |    +--- com.android.support:support-media-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-utils:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-ui:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0\n|    |         +--- com.android.support:support-compat:26.1.0 (*)\n|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:support-annotations:26.1.0\n|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    \\--- com.android.support:animated-vector-drawable:26.1.0\n|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\\--- com.android.support.constraint:constraint-layout:1.0.2\n     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库</p>\n<ul>\n<li>另一种方式查看所需的版本</li>\n</ul>\n<p>执行命令及结果：</p>\n<pre><code>$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n:app:dependencyInsight\ncom.android.support:support-annotations:26.1.0\n+--- com.android.support:appcompat-v7:26.1.0\n|    \\--- releaseCompileClasspath\n+--- com.android.support:support-compat:26.1.0\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-v4:26.1.0\n|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-media-compat:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-fragment:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-core-utils:26.1.0\n|    |    +--- com.android.support:support-v4:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n|    \\--- com.android.support:support-core-ui:26.1.0\n|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n|         +--- com.android.support:support-v4:26.1.0 (*)\n|         \\--- com.android.support:support-fragment:26.1.0 (*)\n+--- com.android.support:support-core-ui:26.1.0 (*)\n+--- com.android.support:support-core-utils:26.1.0 (*)\n+--- com.android.support:support-media-compat:26.1.0 (*)\n\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。</p>\n<h4 id=\"五、查看Gradle窗口可执行的命令\"><a href=\"#五、查看Gradle窗口可执行的命令\" class=\"headerlink\" title=\"五、查看Gradle窗口可执行的命令\"></a>五、查看Gradle窗口可执行的命令</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png\" alt=\"&quot;gradle window&quot;\"></p>\n<p>可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：</p>\n<pre><code>Executing tasks: [signingReport]\n\nConfiguration on demand is an incubating feature.\n:app:signingReport\nVariant: release\nConfig: none\n----------\nVariant: releaseUnitTest\nConfig: none\n----------\nVariant: debug\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugAndroidTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugUnitTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\n\nBUILD SUCCESSFUL in 14s\n1 actionable task: 1 executed\n</code></pre><p>从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）</p>\n<p>下面的install，可以通过installDebug来安装应用</p>\n<p>也可用命令行来执行：</p>\n<pre><code>$ ./gradlew installDebug\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android-Gradle入门\"><a href=\"#Android-Gradle入门\" class=\"headerlink\" title=\"Android Gradle入门\"></a>Android Gradle入门</h3><h5 id=\"本文内容来自官方文档整理\"><a href=\"#本文内容来自官方文档整理\" class=\"headerlink\" title=\"本文内容来自官方文档整理\"></a>本文内容来自官方文档整理</h5><h4 id=\"一、查看生成的Gradle文件列表\"><a href=\"#一、查看生成的Gradle文件列表\" class=\"headerlink\" title=\"一、查看生成的Gradle文件列表\"></a>一、查看生成的Gradle文件列表</h4><p>默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png\" alt=\"“asmodel”\"></p>\n<p>Android项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。</p>\n<p>在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。</p>\n<ul>\n<li>settings.gradle</li>\n</ul>\n<p>Gradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：</p>\n<pre><code>include &apos;:app&apos;\n</code></pre><p>这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。</p>\n<ul>\n<li>gradle-wrapper.properties</li>\n</ul>\n<p>gradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n</code></pre><p>前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。</p>\n<p>最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）</p>\n<h4 id=\"二、查看整个项目的build-gradle\"><a href=\"#二、查看整个项目的build-gradle\" class=\"headerlink\" title=\"二、查看整个项目的build.gradle\"></a>二、查看整个项目的build.gradle</h4><p>project的build.geadle文件：</p>\n<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;\n\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>各个代码块具体作用：</p>\n<ol>\n<li>buildscript - 下载插件</li>\n<li>dependencies - 标识Android插件</li>\n<li>allproject -     top-level and module projects的配置</li>\n<li>task clean - 特设任务</li>\n</ol>\n<p>Gradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。</p>\n<p>当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。</p>\n<p>allprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从<a href=\"https://jcenter.bintray.com上的公共Bintray\" target=\"_blank\" rel=\"external\">https://jcenter.bintray.com上的公共Bintray</a> Artifactory存储库的google或jcenter下载。</p>\n<p>最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。</p>\n<h4 id=\"三、查看app-module的build-gradle\"><a href=\"#三、查看app-module的build-gradle\" class=\"headerlink\" title=\"三、查看app module的build.gradle\"></a>三、查看app module的build.gradle</h4><p>看一下 build.gradle</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>第一行：</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n</code></pre><p>应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。</p>\n<pre><code>android {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n</code></pre><p>对这些属性进行简单的介绍：</p>\n<ul>\n<li>compileSdkVersion：Android SDK版本</li>\n<li>defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。<ul>\n<li>applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。</li>\n</ul>\n</li>\n</ul>\n<pre><code>* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\n* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n* versionName:版本名称值用于自己的内部版本跟踪。\n\n* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n</code></pre><p>在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。</p>\n<pre><code>buildTypes {\n      release {\n          minifyEnabled false\n          proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n      }\n  }\n</code></pre><p>继续往下面看，就是这个应用程序所依赖的库</p>\n<pre><code>dependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。</p>\n<p>testImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。</p>\n<p>androidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。</p>\n<pre><code>fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n</code></pre><p>是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中</p>\n<pre><code>com.android.support:appcompat-v7:26.1.0\n</code></pre><p>将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。</p>\n<pre><code>com.android.support.constraint:constraint-layout:1.0.2\n</code></pre><p>将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。</p>\n<h4 id=\"四、运行标准的Gradle任务\"><a href=\"#四、运行标准的Gradle任务\" class=\"headerlink\" title=\"四、运行标准的Gradle任务\"></a>四、运行标准的Gradle任务</h4><p>Android Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建</p>\n<pre><code>$ ./gradlew build\n</code></pre><p>构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.</p>\n<ul>\n<li>可以在命令行中显示在项目中使用的support-annotations模块的版本。</li>\n</ul>\n<p>执行命令，可以看到结果：</p>\n<pre><code>$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n:app:dependencies\n\n------------------------------------------------------------\nProject :app\n------------------------------------------------------------\n\nreleaseCompileClasspath - Resolved configuration for compilation for variant: release\n+--- com.android.support:appcompat-v7:26.1.0\n|    +--- com.android.support:support-annotations:26.1.0\n|    +--- com.android.support:support-v4:26.1.0\n|    |    +--- com.android.support:support-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n|    |    |         +--- android.arch.lifecycle:common:1.0.0\n|    |    |         \\--- android.arch.core:common:1.0.0\n|    |    +--- com.android.support:support-media-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-utils:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-ui:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0\n|    |         +--- com.android.support:support-compat:26.1.0 (*)\n|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:support-annotations:26.1.0\n|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    \\--- com.android.support:animated-vector-drawable:26.1.0\n|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\\--- com.android.support.constraint:constraint-layout:1.0.2\n     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库</p>\n<ul>\n<li>另一种方式查看所需的版本</li>\n</ul>\n<p>执行命令及结果：</p>\n<pre><code>$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n:app:dependencyInsight\ncom.android.support:support-annotations:26.1.0\n+--- com.android.support:appcompat-v7:26.1.0\n|    \\--- releaseCompileClasspath\n+--- com.android.support:support-compat:26.1.0\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-v4:26.1.0\n|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-media-compat:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-fragment:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-core-utils:26.1.0\n|    |    +--- com.android.support:support-v4:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n|    \\--- com.android.support:support-core-ui:26.1.0\n|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n|         +--- com.android.support:support-v4:26.1.0 (*)\n|         \\--- com.android.support:support-fragment:26.1.0 (*)\n+--- com.android.support:support-core-ui:26.1.0 (*)\n+--- com.android.support:support-core-utils:26.1.0 (*)\n+--- com.android.support:support-media-compat:26.1.0 (*)\n\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。</p>\n<h4 id=\"五、查看Gradle窗口可执行的命令\"><a href=\"#五、查看Gradle窗口可执行的命令\" class=\"headerlink\" title=\"五、查看Gradle窗口可执行的命令\"></a>五、查看Gradle窗口可执行的命令</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png\" alt=\"&quot;gradle window&quot;\"></p>\n<p>可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：</p>\n<pre><code>Executing tasks: [signingReport]\n\nConfiguration on demand is an incubating feature.\n:app:signingReport\nVariant: release\nConfig: none\n----------\nVariant: releaseUnitTest\nConfig: none\n----------\nVariant: debug\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugAndroidTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugUnitTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\n\nBUILD SUCCESSFUL in 14s\n1 actionable task: 1 executed\n</code></pre><p>从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）</p>\n<p>下面的install，可以通过installDebug来安装应用</p>\n<p>也可用命令行来执行：</p>\n<pre><code>$ ./gradlew installDebug\n</code></pre>"},{"title":"阿里百川Hotfix 1.4.0 Android接入","date":"2017-07-12T09:33:45.000Z","_content":"\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","source":"_posts/Android-MVPB.md","raw":"---\ntitle: 阿里百川Hotfix 1.4.0 Android接入\ndate: 2017-07-12 17:33:45\ntags: [Android]\n---\n\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","slug":"Android-MVPB","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tmy0007x3c0tfu0zgi8","content":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n"},{"title":"Android Studio3.0+ Trace分析","date":"2018-11-07T03:04:26.000Z","_content":"\n\n#### 一、简要说明\n\n在进行性能优化的时候，很多情况下需要去看方法耗时。这个时候我们就需要通过Trace来查看方法具体耗时情况。\n\n#### 二、具体使用方法\n\n##### 1.使用DDMS工具来查看trace进行分析\n\n在Android Studio3.0 之前，在AS IDE面板中->Tools->Android Device Monitor 打开即可使用，通过点击Start Method Profiling(为红色)按钮开始进行方法调用跟踪(点击后会变为黑色)，停止时再点击停止，即可生成trace文件进行分析。\n\n需要注意的是，在AS3.0+ DDMS从面板上移除了，官方给的说法是：\n\nHowever, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher.\n\n那就手动的去启动就OK了。（在Terminal中输入命令 monitor 启动DDMS）\n\n##### 2.通过代码进行追踪\n\n在需要分析的代码中添加\n\n开始\n\n\tDebug.startMethodTracing()\n\n结束\n\n\tDebug.stopMethodTracing()\n\t\n\t\n这样就会生成.trace文件了。\n\n#### 三、分析trace文件\n\n在面板中会有各种数据，这个时候就需要搞清楚各个参数所代表的具体含义了。\n\n\n最关心的数据有：\n很重要的指标：Calls + Recur Calls / Total , 最重要的指标： Cpu Time / Call\n因为我们最关心的有两点，一是调用次数不多，但每次调用却需要花费很长时间的函数。这个可以从Cpu Time / Call反映出来。另外一个是那些自身占用时间不长，但调用却非常频繁的函数。这个可以从**Calls + Recur Calls / Total **反映出来。\n\n当体验卡顿的时候，我们可以借助TraceView来定位问题\n","source":"_posts/Android-Studio3-0-Trace分析.md","raw":"---\ntitle: Android Studio3.0+ Trace分析\ndate: 2018-11-07 11:04:26\ntags: [Android性能优化]\n---\n\n\n#### 一、简要说明\n\n在进行性能优化的时候，很多情况下需要去看方法耗时。这个时候我们就需要通过Trace来查看方法具体耗时情况。\n\n#### 二、具体使用方法\n\n##### 1.使用DDMS工具来查看trace进行分析\n\n在Android Studio3.0 之前，在AS IDE面板中->Tools->Android Device Monitor 打开即可使用，通过点击Start Method Profiling(为红色)按钮开始进行方法调用跟踪(点击后会变为黑色)，停止时再点击停止，即可生成trace文件进行分析。\n\n需要注意的是，在AS3.0+ DDMS从面板上移除了，官方给的说法是：\n\nHowever, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher.\n\n那就手动的去启动就OK了。（在Terminal中输入命令 monitor 启动DDMS）\n\n##### 2.通过代码进行追踪\n\n在需要分析的代码中添加\n\n开始\n\n\tDebug.startMethodTracing()\n\n结束\n\n\tDebug.stopMethodTracing()\n\t\n\t\n这样就会生成.trace文件了。\n\n#### 三、分析trace文件\n\n在面板中会有各种数据，这个时候就需要搞清楚各个参数所代表的具体含义了。\n\n\n最关心的数据有：\n很重要的指标：Calls + Recur Calls / Total , 最重要的指标： Cpu Time / Call\n因为我们最关心的有两点，一是调用次数不多，但每次调用却需要花费很长时间的函数。这个可以从Cpu Time / Call反映出来。另外一个是那些自身占用时间不长，但调用却非常频繁的函数。这个可以从**Calls + Recur Calls / Total **反映出来。\n\n当体验卡顿的时候，我们可以借助TraceView来定位问题\n","slug":"Android-Studio3-0-Trace分析","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn1000ax3c0qxfksgk3","content":"<h4 id=\"一、简要说明\"><a href=\"#一、简要说明\" class=\"headerlink\" title=\"一、简要说明\"></a>一、简要说明</h4><p>在进行性能优化的时候，很多情况下需要去看方法耗时。这个时候我们就需要通过Trace来查看方法具体耗时情况。</p>\n<h4 id=\"二、具体使用方法\"><a href=\"#二、具体使用方法\" class=\"headerlink\" title=\"二、具体使用方法\"></a>二、具体使用方法</h4><h5 id=\"1-使用DDMS工具来查看trace进行分析\"><a href=\"#1-使用DDMS工具来查看trace进行分析\" class=\"headerlink\" title=\"1.使用DDMS工具来查看trace进行分析\"></a>1.使用DDMS工具来查看trace进行分析</h5><p>在Android Studio3.0 之前，在AS IDE面板中-&gt;Tools-&gt;Android Device Monitor 打开即可使用，通过点击Start Method Profiling(为红色)按钮开始进行方法调用跟踪(点击后会变为黑色)，停止时再点击停止，即可生成trace文件进行分析。</p>\n<p>需要注意的是，在AS3.0+ DDMS从面板上移除了，官方给的说法是：</p>\n<p>However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher.</p>\n<p>那就手动的去启动就OK了。（在Terminal中输入命令 monitor 启动DDMS）</p>\n<h5 id=\"2-通过代码进行追踪\"><a href=\"#2-通过代码进行追踪\" class=\"headerlink\" title=\"2.通过代码进行追踪\"></a>2.通过代码进行追踪</h5><p>在需要分析的代码中添加</p>\n<p>开始</p>\n<pre><code>Debug.startMethodTracing()\n</code></pre><p>结束</p>\n<pre><code>Debug.stopMethodTracing()\n</code></pre><p>这样就会生成.trace文件了。</p>\n<h4 id=\"三、分析trace文件\"><a href=\"#三、分析trace文件\" class=\"headerlink\" title=\"三、分析trace文件\"></a>三、分析trace文件</h4><p>在面板中会有各种数据，这个时候就需要搞清楚各个参数所代表的具体含义了。</p>\n<p>最关心的数据有：<br>很重要的指标：Calls + Recur Calls / Total , 最重要的指标： Cpu Time / Call<br>因为我们最关心的有两点，一是调用次数不多，但每次调用却需要花费很长时间的函数。这个可以从Cpu Time / Call反映出来。另外一个是那些自身占用时间不长，但调用却非常频繁的函数。这个可以从<strong>Calls + Recur Calls / Total </strong>反映出来。</p>\n<p>当体验卡顿的时候，我们可以借助TraceView来定位问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、简要说明\"><a href=\"#一、简要说明\" class=\"headerlink\" title=\"一、简要说明\"></a>一、简要说明</h4><p>在进行性能优化的时候，很多情况下需要去看方法耗时。这个时候我们就需要通过Trace来查看方法具体耗时情况。</p>\n<h4 id=\"二、具体使用方法\"><a href=\"#二、具体使用方法\" class=\"headerlink\" title=\"二、具体使用方法\"></a>二、具体使用方法</h4><h5 id=\"1-使用DDMS工具来查看trace进行分析\"><a href=\"#1-使用DDMS工具来查看trace进行分析\" class=\"headerlink\" title=\"1.使用DDMS工具来查看trace进行分析\"></a>1.使用DDMS工具来查看trace进行分析</h5><p>在Android Studio3.0 之前，在AS IDE面板中-&gt;Tools-&gt;Android Device Monitor 打开即可使用，通过点击Start Method Profiling(为红色)按钮开始进行方法调用跟踪(点击后会变为黑色)，停止时再点击停止，即可生成trace文件进行分析。</p>\n<p>需要注意的是，在AS3.0+ DDMS从面板上移除了，官方给的说法是：</p>\n<p>However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher.</p>\n<p>那就手动的去启动就OK了。（在Terminal中输入命令 monitor 启动DDMS）</p>\n<h5 id=\"2-通过代码进行追踪\"><a href=\"#2-通过代码进行追踪\" class=\"headerlink\" title=\"2.通过代码进行追踪\"></a>2.通过代码进行追踪</h5><p>在需要分析的代码中添加</p>\n<p>开始</p>\n<pre><code>Debug.startMethodTracing()\n</code></pre><p>结束</p>\n<pre><code>Debug.stopMethodTracing()\n</code></pre><p>这样就会生成.trace文件了。</p>\n<h4 id=\"三、分析trace文件\"><a href=\"#三、分析trace文件\" class=\"headerlink\" title=\"三、分析trace文件\"></a>三、分析trace文件</h4><p>在面板中会有各种数据，这个时候就需要搞清楚各个参数所代表的具体含义了。</p>\n<p>最关心的数据有：<br>很重要的指标：Calls + Recur Calls / Total , 最重要的指标： Cpu Time / Call<br>因为我们最关心的有两点，一是调用次数不多，但每次调用却需要花费很长时间的函数。这个可以从Cpu Time / Call反映出来。另外一个是那些自身占用时间不长，但调用却非常频繁的函数。这个可以从<strong>Calls + Recur Calls / Total </strong>反映出来。</p>\n<p>当体验卡顿的时候，我们可以借助TraceView来定位问题</p>\n"},{"title":"Android View事件分发机制","date":"2017-10-11T09:27:08.000Z","_content":"\n### 一、点击事件的传递规则\n\n   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。\n   \n#### 1.MotionEvent\n   \n  常见的动作：\n  \n  常见的动作常量：\n  \n  * public static final int ACTION_DOWN = 0;单点触摸动作\n    \n  * public static final int ACTION_UP = 1;单点触摸离开动作\n  * public static final int ACTION_MOVE = 2;触摸点移动动作\n  * public static final int ACTION_CANCEL = 3;触摸动作取消\n  * public static final int ACTION_OUTSIDE = 4;触摸动作超出边界\n  * public static final int ACTION_POINTER_DOWN = 5;多点触摸动作\n  * public static final int ACTION_POINTER_UP       = 6;多点离开动作\n\n\n\t主要就是：\n\t\n\t* ACTION_DOWN--手指刚接触屏幕\n\t* ACTION_MOVE--手指在屏幕上滑动\n\t* ACTION_UP--手指离开屏幕\n\n\t\t\n#### 2.点击事件的分发中最重要的三个方法\n\n* dispatchTouchEvent(MotionEvent event)--事件分发\n\n\t* 用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。\n\t\t\n* onInterceptTouchEvent(MotionEvent event)--事件拦截\n\n\t* 用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。\n\t\t\n* onTouchEvent(MotionEvent event)--事件消费\n\n\t* 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件\n\n#### 3. 伪代码\n\n\t\tpublic boolean dispatchTouchEvent(MotionEvent ev){\n\t\t\tboolean touch = false;\n\t\t\tif(onInterceptTouchEvent(ev)){\n\t\t\t\ttouch = onTouchEvent(ev);\n\t\t\t}else{\n\t\t\t\ttouch = child.dispatchTouchEvent(ev);\n\t\t\t}\n\t\t\treturn touch;\n\t\t}\n     \n   \n* 点击事件的传递规则：\n\n  * 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用\t \n  \n  * 首先判断自身是否处理，处理的话就会调用onInterceptTouchEvent(MotionEvent event),来判断是否处理，自身处理的话，就会调用onTouchEvent(MotionEvent event)，自己就把这次点击事件处理了\n \n  * 如果自身不处理，就不拦截，交给子View去处理。子View处理同样按照ViewGroup自身处理一致。子View不处理的话，最后则调用ViewGroup自身的onTouchEvent(MotionEvent event)消费掉此次点击事件\n\n    经典的伪代码如上。\n      \n      \n#### 4.同一次点击事件只能被一个 View 消费\n\n  安卓为了保证所有的事件都是被一个 View 消费的，对第一次的事件( ACTION_DOWN )进行了特殊判断，View 只有消费了 ACTION_DOWN 事件，才能接收到后续的事件(可点击控件会默认消费所有事件)，并且会将后续所有事件传递过来，不会再传递给其他 View，除非上层 View 进行了拦截。\n如果上层 View 拦截了当前正在处理的事件，会收到一个 ACTION_CANCEL，表示当前事件已经结束，后续事件不会再传递过来。\n\n\n借用GcsSloop源码分析：\n\n\t\n\tpublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t  \t// 调试用\n\t    if (mInputEventConsistencyVerifier != null) {\n\t        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n\t    }\n\t\n\t  \t// 判断事件是否是针对可访问的焦点视图(很晚才添加的内容，个人猜测和屏幕辅助相关，方便盲人等使用设备)\n\t    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n\t        ev.setTargetAccessibilityFocus(false);\n\t    }\n\t\n\t    boolean handled = false;\n\t    if (onFilterTouchEventForSecurity(ev)) {\n\t        final int action = ev.getAction();\n\t        final int actionMasked = action & MotionEvent.ACTION_MASK;\n\t\n\t        // 处理第一次ACTION_DOWN.\n\t        if (actionMasked == MotionEvent.ACTION_DOWN) {\n\t            // 清除之前所有的状态\n\t            cancelAndClearTouchTargets(ev);\n\t            resetTouchState();\n\t        }\n\t\n\t        // 检查是否需要拦截.\n\t        final boolean intercepted;\n\t        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n\t            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n\t            if (!disallowIntercept) {\n\t                intercepted = onInterceptTouchEvent(ev);\t// 询问是否拦截\n\t                ev.setAction(action); \t\t\t\t\t\t// 恢复操作，防止被更改\n\t            } else {\n\t                intercepted = false;\n\t            }\n\t        } else {\n\t          \t// 没有目标来处理该事件，而且也不是一个新的事件事件(ACTION_DOWN), 进行拦截。\n\t            intercepted = true;\n\t        }\n\t\n\t      \t// 判断事件是否是针对可访问的焦点视图\n\t        if (intercepted || mFirstTouchTarget != null) {\n\t            ev.setTargetAccessibilityFocus(false);\n\t        }\n\t\n\t        // 检查事件是否被取消(ACTION_CANCEL).\n\t        final boolean canceled = resetCancelNextUpFlag(this)\n\t                || actionMasked == MotionEvent.ACTION_CANCEL;\n\t\n\t        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n\t        TouchTarget newTouchTarget = null;\n\t        boolean alreadyDispatchedToNewTouchTarget = false;\n\t      \t\n\t      \t// 如果没有取消也没有被拦截\t(进入事件分发)\n\t        if (!canceled && !intercepted) {\n\t\n\t            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的视图。\n\t          \t// 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。 \n\t            // 我们检测并避免保持这种状态，因为这些事非常罕见。\n\t            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n\t                    ? findChildWithAccessibilityFocus() : null;\n\t\n\t            if (actionMasked == MotionEvent.ACTION_DOWN\n\t                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n\t                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\t                final int actionIndex = ev.getActionIndex();\n\t                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n\t                        : TouchTarget.ALL_POINTER_IDS;\n\t\n\t                // 清除此指针ID的早期触摸目标，防止不同步。\n\t                removePointersFromTouchTargets(idBitsToAssign);\n\t\n\t                final int childrenCount = mChildrenCount;\n\t                if (newTouchTarget == null && childrenCount != 0) {\n\t                    final float x = ev.getX(actionIndex);\t// 获取触摸位置坐标\n\t                    final float y = ev.getY(actionIndex);\n\t                    // 查找可以接受事件的 ChildView\n\t                    final ArrayList<View> preorderedList = buildOrderedChildList();\n\t                    final boolean customOrder = preorderedList == null\n\t                            && isChildrenDrawingOrderEnabled();\n\t                    final View[] children = mChildren;\n\t                  \t// ▼注意，从最后向前扫描\n\t                    for (int i = childrenCount - 1; i >= 0; i--) {\n\t                        final int childIndex = customOrder\n\t                                ? getChildDrawingOrder(childrenCount, i) : i;\n\t                        final View child = (preorderedList == null)\n\t                                ? children[childIndex] : preorderedList.get(childIndex);\n\t\n\t                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，\n\t                      \t// 如果不处理，我们将执行正常的分派。 \n\t                      \t// 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。\n\t                        if (childWithAccessibilityFocus != null) {\n\t                            if (childWithAccessibilityFocus != child) {\n\t                                continue;\n\t                            }\n\t                            childWithAccessibilityFocus = null;\n\t                            i = childrenCount - 1;\n\t                        }\n\t\n\t                      \t// 检查View是否允许接受事件(即处于显示状态(VISIBLE)或者正在播放动画)\n\t                      \t// 检查触摸位置是否在View区域内\n\t                        if (!canViewReceivePointerEvents(child)\n\t                                || !isTransformedTouchPointInView(x, y, child, null)) {\n\t                            ev.setTargetAccessibilityFocus(false);\n\t                            continue;\n\t                        }\n\t\n\t                      \t// getTouchTarget 中判断了 child 是否包含在 mFirstTouchTarget 中\n\t                      \t// 如果有返回 target，如果没有返回 null \n\t                        newTouchTarget = getTouchTarget(child);\n\t                        if (newTouchTarget != null) {\n\t                            // ChildView 已经准备好接受在其区域内的事件。\n\t                            newTouchTarget.pointerIdBits |= idBitsToAssign;\n\t                            break;\t// ◀︎已经找到目标View，跳出循环\n\t                        }\n\t\n\t                        resetCancelNextUpFlag(child);\n\t                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n\t                            mLastTouchDownTime = ev.getDownTime();\n\t                            if (preorderedList != null) {\n\t                                for (int j = 0; j < childrenCount; j++) {\n\t                                    if (children[childIndex] == mChildren[j]) {\n\t                                        mLastTouchDownIndex = j;\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            } else {\n\t                                mLastTouchDownIndex = childIndex;\n\t                            }\n\t                            mLastTouchDownX = ev.getX();\n\t                            mLastTouchDownY = ev.getY();\n\t                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n\t                            alreadyDispatchedToNewTouchTarget = true;\n\t                            break;\n\t                        }\n\t                      \n\t                        ev.setTargetAccessibilityFocus(false);\n\t                    }\n\t                    if (preorderedList != null) preorderedList.clear();\n\t                }\n\t\n\t                if (newTouchTarget == null && mFirstTouchTarget != null) {\n\t                    // 没有找到 ChildView 接收事件\n\t                    newTouchTarget = mFirstTouchTarget;\n\t                    while (newTouchTarget.next != null) {\n\t                        newTouchTarget = newTouchTarget.next;\n\t                    }\n\t                    newTouchTarget.pointerIdBits |= idBitsToAssign;\n\t                }\n\t            }\n\t        }\n\t\n\t        // 分发 TouchTarget\n\t        if (mFirstTouchTarget == null) {\n\t            // 没有 TouchTarget，将当前 ViewGroup 当作普通的 View 处理。\n\t            handled = dispatchTransformedTouchEvent(ev, canceled, null,\n\t                    TouchTarget.ALL_POINTER_IDS);\n\t        } else {\n\t            // 分发TouchTarget，如果我们已经分发过，则避免分配给新的目标。 \n\t          \t// 如有必要，取消分发。\n\t            TouchTarget predecessor = null;\n\t            TouchTarget target = mFirstTouchTarget;\n\t            while (target != null) {\n\t                final TouchTarget next = target.next;\n\t                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n\t                    handled = true;\n\t                } else {\n\t                    final boolean cancelChild = resetCancelNextUpFlag(target.child)\n\t                            || intercepted;\n\t                    if (dispatchTransformedTouchEvent(ev, cancelChild,\n\t                            target.child, target.pointerIdBits)) {\n\t                        handled = true;\n\t                    }\n\t                    if (cancelChild) {\n\t                        if (predecessor == null) {\n\t                            mFirstTouchTarget = next;\n\t                        } else {\n\t                            predecessor.next = next;\n\t                        }\n\t                        target.recycle();\n\t                        target = next;\n\t                        continue;\n\t                    }\n\t                }\n\t                predecessor = target;\n\t                target = next;\n\t            }\n\t        }\n\t\n\t        // 如果需要，更新指针的触摸目标列表或取消。\n\t        if (canceled\n\t                || actionMasked == MotionEvent.ACTION_UP\n\t                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\t            resetTouchState();\n\t        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n\t            final int actionIndex = ev.getActionIndex();\n\t            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n\t            removePointersFromTouchTargets(idBitsToRemove);\n\t        }\n\t    }\n\t\n\t    if (!handled && mInputEventConsistencyVerifier != null) {\n\t        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n\t    }\n\t    return handled;\n\t}\n\t\n\t\n源码注释已经很详细了。\n\n\n\n\n\n### 二、小结\n\n#### 1. 同一个事件是从DOWN开始到UP结束的\n#### 2. 一个事件最终只能由一个View拦截和消费掉\n#### 3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\n#### 4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。\n#### 5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\n#### 6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。\n#### 7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\n#### 8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\n#### 9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\n#### 10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。","source":"_posts/Android-View事件分发机制.md","raw":"---\ntitle: Android View事件分发机制\ndate: 2017-10-11 17:27:08\ntags: [View事件分发机制]\n---\n\n### 一、点击事件的传递规则\n\n   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。\n   \n#### 1.MotionEvent\n   \n  常见的动作：\n  \n  常见的动作常量：\n  \n  * public static final int ACTION_DOWN = 0;单点触摸动作\n    \n  * public static final int ACTION_UP = 1;单点触摸离开动作\n  * public static final int ACTION_MOVE = 2;触摸点移动动作\n  * public static final int ACTION_CANCEL = 3;触摸动作取消\n  * public static final int ACTION_OUTSIDE = 4;触摸动作超出边界\n  * public static final int ACTION_POINTER_DOWN = 5;多点触摸动作\n  * public static final int ACTION_POINTER_UP       = 6;多点离开动作\n\n\n\t主要就是：\n\t\n\t* ACTION_DOWN--手指刚接触屏幕\n\t* ACTION_MOVE--手指在屏幕上滑动\n\t* ACTION_UP--手指离开屏幕\n\n\t\t\n#### 2.点击事件的分发中最重要的三个方法\n\n* dispatchTouchEvent(MotionEvent event)--事件分发\n\n\t* 用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。\n\t\t\n* onInterceptTouchEvent(MotionEvent event)--事件拦截\n\n\t* 用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。\n\t\t\n* onTouchEvent(MotionEvent event)--事件消费\n\n\t* 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件\n\n#### 3. 伪代码\n\n\t\tpublic boolean dispatchTouchEvent(MotionEvent ev){\n\t\t\tboolean touch = false;\n\t\t\tif(onInterceptTouchEvent(ev)){\n\t\t\t\ttouch = onTouchEvent(ev);\n\t\t\t}else{\n\t\t\t\ttouch = child.dispatchTouchEvent(ev);\n\t\t\t}\n\t\t\treturn touch;\n\t\t}\n     \n   \n* 点击事件的传递规则：\n\n  * 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用\t \n  \n  * 首先判断自身是否处理，处理的话就会调用onInterceptTouchEvent(MotionEvent event),来判断是否处理，自身处理的话，就会调用onTouchEvent(MotionEvent event)，自己就把这次点击事件处理了\n \n  * 如果自身不处理，就不拦截，交给子View去处理。子View处理同样按照ViewGroup自身处理一致。子View不处理的话，最后则调用ViewGroup自身的onTouchEvent(MotionEvent event)消费掉此次点击事件\n\n    经典的伪代码如上。\n      \n      \n#### 4.同一次点击事件只能被一个 View 消费\n\n  安卓为了保证所有的事件都是被一个 View 消费的，对第一次的事件( ACTION_DOWN )进行了特殊判断，View 只有消费了 ACTION_DOWN 事件，才能接收到后续的事件(可点击控件会默认消费所有事件)，并且会将后续所有事件传递过来，不会再传递给其他 View，除非上层 View 进行了拦截。\n如果上层 View 拦截了当前正在处理的事件，会收到一个 ACTION_CANCEL，表示当前事件已经结束，后续事件不会再传递过来。\n\n\n借用GcsSloop源码分析：\n\n\t\n\tpublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t  \t// 调试用\n\t    if (mInputEventConsistencyVerifier != null) {\n\t        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n\t    }\n\t\n\t  \t// 判断事件是否是针对可访问的焦点视图(很晚才添加的内容，个人猜测和屏幕辅助相关，方便盲人等使用设备)\n\t    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\n\t        ev.setTargetAccessibilityFocus(false);\n\t    }\n\t\n\t    boolean handled = false;\n\t    if (onFilterTouchEventForSecurity(ev)) {\n\t        final int action = ev.getAction();\n\t        final int actionMasked = action & MotionEvent.ACTION_MASK;\n\t\n\t        // 处理第一次ACTION_DOWN.\n\t        if (actionMasked == MotionEvent.ACTION_DOWN) {\n\t            // 清除之前所有的状态\n\t            cancelAndClearTouchTargets(ev);\n\t            resetTouchState();\n\t        }\n\t\n\t        // 检查是否需要拦截.\n\t        final boolean intercepted;\n\t        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n\t            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n\t            if (!disallowIntercept) {\n\t                intercepted = onInterceptTouchEvent(ev);\t// 询问是否拦截\n\t                ev.setAction(action); \t\t\t\t\t\t// 恢复操作，防止被更改\n\t            } else {\n\t                intercepted = false;\n\t            }\n\t        } else {\n\t          \t// 没有目标来处理该事件，而且也不是一个新的事件事件(ACTION_DOWN), 进行拦截。\n\t            intercepted = true;\n\t        }\n\t\n\t      \t// 判断事件是否是针对可访问的焦点视图\n\t        if (intercepted || mFirstTouchTarget != null) {\n\t            ev.setTargetAccessibilityFocus(false);\n\t        }\n\t\n\t        // 检查事件是否被取消(ACTION_CANCEL).\n\t        final boolean canceled = resetCancelNextUpFlag(this)\n\t                || actionMasked == MotionEvent.ACTION_CANCEL;\n\t\n\t        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\n\t        TouchTarget newTouchTarget = null;\n\t        boolean alreadyDispatchedToNewTouchTarget = false;\n\t      \t\n\t      \t// 如果没有取消也没有被拦截\t(进入事件分发)\n\t        if (!canceled && !intercepted) {\n\t\n\t            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的视图。\n\t          \t// 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。 \n\t            // 我们检测并避免保持这种状态，因为这些事非常罕见。\n\t            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n\t                    ? findChildWithAccessibilityFocus() : null;\n\t\n\t            if (actionMasked == MotionEvent.ACTION_DOWN\n\t                    || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n\t                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\t                final int actionIndex = ev.getActionIndex();\n\t                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\n\t                        : TouchTarget.ALL_POINTER_IDS;\n\t\n\t                // 清除此指针ID的早期触摸目标，防止不同步。\n\t                removePointersFromTouchTargets(idBitsToAssign);\n\t\n\t                final int childrenCount = mChildrenCount;\n\t                if (newTouchTarget == null && childrenCount != 0) {\n\t                    final float x = ev.getX(actionIndex);\t// 获取触摸位置坐标\n\t                    final float y = ev.getY(actionIndex);\n\t                    // 查找可以接受事件的 ChildView\n\t                    final ArrayList<View> preorderedList = buildOrderedChildList();\n\t                    final boolean customOrder = preorderedList == null\n\t                            && isChildrenDrawingOrderEnabled();\n\t                    final View[] children = mChildren;\n\t                  \t// ▼注意，从最后向前扫描\n\t                    for (int i = childrenCount - 1; i >= 0; i--) {\n\t                        final int childIndex = customOrder\n\t                                ? getChildDrawingOrder(childrenCount, i) : i;\n\t                        final View child = (preorderedList == null)\n\t                                ? children[childIndex] : preorderedList.get(childIndex);\n\t\n\t                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，\n\t                      \t// 如果不处理，我们将执行正常的分派。 \n\t                      \t// 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。\n\t                        if (childWithAccessibilityFocus != null) {\n\t                            if (childWithAccessibilityFocus != child) {\n\t                                continue;\n\t                            }\n\t                            childWithAccessibilityFocus = null;\n\t                            i = childrenCount - 1;\n\t                        }\n\t\n\t                      \t// 检查View是否允许接受事件(即处于显示状态(VISIBLE)或者正在播放动画)\n\t                      \t// 检查触摸位置是否在View区域内\n\t                        if (!canViewReceivePointerEvents(child)\n\t                                || !isTransformedTouchPointInView(x, y, child, null)) {\n\t                            ev.setTargetAccessibilityFocus(false);\n\t                            continue;\n\t                        }\n\t\n\t                      \t// getTouchTarget 中判断了 child 是否包含在 mFirstTouchTarget 中\n\t                      \t// 如果有返回 target，如果没有返回 null \n\t                        newTouchTarget = getTouchTarget(child);\n\t                        if (newTouchTarget != null) {\n\t                            // ChildView 已经准备好接受在其区域内的事件。\n\t                            newTouchTarget.pointerIdBits |= idBitsToAssign;\n\t                            break;\t// ◀︎已经找到目标View，跳出循环\n\t                        }\n\t\n\t                        resetCancelNextUpFlag(child);\n\t                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n\t                            mLastTouchDownTime = ev.getDownTime();\n\t                            if (preorderedList != null) {\n\t                                for (int j = 0; j < childrenCount; j++) {\n\t                                    if (children[childIndex] == mChildren[j]) {\n\t                                        mLastTouchDownIndex = j;\n\t                                        break;\n\t                                    }\n\t                                }\n\t                            } else {\n\t                                mLastTouchDownIndex = childIndex;\n\t                            }\n\t                            mLastTouchDownX = ev.getX();\n\t                            mLastTouchDownY = ev.getY();\n\t                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n\t                            alreadyDispatchedToNewTouchTarget = true;\n\t                            break;\n\t                        }\n\t                      \n\t                        ev.setTargetAccessibilityFocus(false);\n\t                    }\n\t                    if (preorderedList != null) preorderedList.clear();\n\t                }\n\t\n\t                if (newTouchTarget == null && mFirstTouchTarget != null) {\n\t                    // 没有找到 ChildView 接收事件\n\t                    newTouchTarget = mFirstTouchTarget;\n\t                    while (newTouchTarget.next != null) {\n\t                        newTouchTarget = newTouchTarget.next;\n\t                    }\n\t                    newTouchTarget.pointerIdBits |= idBitsToAssign;\n\t                }\n\t            }\n\t        }\n\t\n\t        // 分发 TouchTarget\n\t        if (mFirstTouchTarget == null) {\n\t            // 没有 TouchTarget，将当前 ViewGroup 当作普通的 View 处理。\n\t            handled = dispatchTransformedTouchEvent(ev, canceled, null,\n\t                    TouchTarget.ALL_POINTER_IDS);\n\t        } else {\n\t            // 分发TouchTarget，如果我们已经分发过，则避免分配给新的目标。 \n\t          \t// 如有必要，取消分发。\n\t            TouchTarget predecessor = null;\n\t            TouchTarget target = mFirstTouchTarget;\n\t            while (target != null) {\n\t                final TouchTarget next = target.next;\n\t                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\n\t                    handled = true;\n\t                } else {\n\t                    final boolean cancelChild = resetCancelNextUpFlag(target.child)\n\t                            || intercepted;\n\t                    if (dispatchTransformedTouchEvent(ev, cancelChild,\n\t                            target.child, target.pointerIdBits)) {\n\t                        handled = true;\n\t                    }\n\t                    if (cancelChild) {\n\t                        if (predecessor == null) {\n\t                            mFirstTouchTarget = next;\n\t                        } else {\n\t                            predecessor.next = next;\n\t                        }\n\t                        target.recycle();\n\t                        target = next;\n\t                        continue;\n\t                    }\n\t                }\n\t                predecessor = target;\n\t                target = next;\n\t            }\n\t        }\n\t\n\t        // 如果需要，更新指针的触摸目标列表或取消。\n\t        if (canceled\n\t                || actionMasked == MotionEvent.ACTION_UP\n\t                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\t            resetTouchState();\n\t        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\n\t            final int actionIndex = ev.getActionIndex();\n\t            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\n\t            removePointersFromTouchTargets(idBitsToRemove);\n\t        }\n\t    }\n\t\n\t    if (!handled && mInputEventConsistencyVerifier != null) {\n\t        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n\t    }\n\t    return handled;\n\t}\n\t\n\t\n源码注释已经很详细了。\n\n\n\n\n\n### 二、小结\n\n#### 1. 同一个事件是从DOWN开始到UP结束的\n#### 2. 一个事件最终只能由一个View拦截和消费掉\n#### 3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\n#### 4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。\n#### 5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\n#### 6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。\n#### 7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\n#### 8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\n#### 9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\n#### 10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。","slug":"Android-View事件分发机制","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn2000bx3c0gro81ovy","content":"<h3 id=\"一、点击事件的传递规则\"><a href=\"#一、点击事件的传递规则\" class=\"headerlink\" title=\"一、点击事件的传递规则\"></a>一、点击事件的传递规则</h3><p>   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。</p>\n<h4 id=\"1-MotionEvent\"><a href=\"#1-MotionEvent\" class=\"headerlink\" title=\"1.MotionEvent\"></a>1.MotionEvent</h4><p>  常见的动作：</p>\n<p>  常见的动作常量：</p>\n<ul>\n<li><p>public static final int ACTION_DOWN = 0;单点触摸动作</p>\n</li>\n<li><p>public static final int ACTION_UP = 1;单点触摸离开动作</p>\n</li>\n<li>public static final int ACTION_MOVE = 2;触摸点移动动作</li>\n<li>public static final int ACTION_CANCEL = 3;触摸动作取消</li>\n<li>public static final int ACTION_OUTSIDE = 4;触摸动作超出边界</li>\n<li>public static final int ACTION_POINTER_DOWN = 5;多点触摸动作</li>\n<li>public static final int ACTION_POINTER_UP       = 6;多点离开动作</li>\n</ul>\n<pre><code>主要就是：\n\n* ACTION_DOWN--手指刚接触屏幕\n* ACTION_MOVE--手指在屏幕上滑动\n* ACTION_UP--手指离开屏幕\n</code></pre><h4 id=\"2-点击事件的分发中最重要的三个方法\"><a href=\"#2-点击事件的分发中最重要的三个方法\" class=\"headerlink\" title=\"2.点击事件的分发中最重要的三个方法\"></a>2.点击事件的分发中最重要的三个方法</h4><ul>\n<li><p>dispatchTouchEvent(MotionEvent event)–事件分发</p>\n<ul>\n<li>用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。</li>\n</ul>\n</li>\n<li><p>onInterceptTouchEvent(MotionEvent event)–事件拦截</p>\n<ul>\n<li>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。</li>\n</ul>\n</li>\n<li><p>onTouchEvent(MotionEvent event)–事件消费</p>\n<ul>\n<li>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-伪代码\"><a href=\"#3-伪代码\" class=\"headerlink\" title=\"3. 伪代码\"></a>3. 伪代码</h4><pre><code>public boolean dispatchTouchEvent(MotionEvent ev){\n    boolean touch = false;\n    if(onInterceptTouchEvent(ev)){\n        touch = onTouchEvent(ev);\n    }else{\n        touch = child.dispatchTouchEvent(ev);\n    }\n    return touch;\n}\n</code></pre><ul>\n<li><p>点击事件的传递规则：</p>\n<ul>\n<li><p>对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用     </p>\n</li>\n<li><p>首先判断自身是否处理，处理的话就会调用onInterceptTouchEvent(MotionEvent event),来判断是否处理，自身处理的话，就会调用onTouchEvent(MotionEvent event)，自己就把这次点击事件处理了</p>\n</li>\n<li><p>如果自身不处理，就不拦截，交给子View去处理。子View处理同样按照ViewGroup自身处理一致。子View不处理的话，最后则调用ViewGroup自身的onTouchEvent(MotionEvent event)消费掉此次点击事件</p>\n<p>经典的伪代码如上。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-同一次点击事件只能被一个-View-消费\"><a href=\"#4-同一次点击事件只能被一个-View-消费\" class=\"headerlink\" title=\"4.同一次点击事件只能被一个 View 消费\"></a>4.同一次点击事件只能被一个 View 消费</h4><p>  安卓为了保证所有的事件都是被一个 View 消费的，对第一次的事件( ACTION_DOWN )进行了特殊判断，View 只有消费了 ACTION_DOWN 事件，才能接收到后续的事件(可点击控件会默认消费所有事件)，并且会将后续所有事件传递过来，不会再传递给其他 View，除非上层 View 进行了拦截。<br>如果上层 View 拦截了当前正在处理的事件，会收到一个 ACTION_CANCEL，表示当前事件已经结束，后续事件不会再传递过来。</p>\n<p>借用GcsSloop源码分析：</p>\n<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {\n      // 调试用\n    if (mInputEventConsistencyVerifier != null) {\n        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n    }\n\n      // 判断事件是否是针对可访问的焦点视图(很晚才添加的内容，个人猜测和屏幕辅助相关，方便盲人等使用设备)\n    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {\n        ev.setTargetAccessibilityFocus(false);\n    }\n\n    boolean handled = false;\n    if (onFilterTouchEventForSecurity(ev)) {\n        final int action = ev.getAction();\n        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;\n\n        // 处理第一次ACTION_DOWN.\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // 清除之前所有的状态\n            cancelAndClearTouchTargets(ev);\n            resetTouchState();\n        }\n\n        // 检查是否需要拦截.\n        final boolean intercepted;\n        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;\n            if (!disallowIntercept) {\n                intercepted = onInterceptTouchEvent(ev);    // 询问是否拦截\n                ev.setAction(action);                         // 恢复操作，防止被更改\n            } else {\n                intercepted = false;\n            }\n        } else {\n              // 没有目标来处理该事件，而且也不是一个新的事件事件(ACTION_DOWN), 进行拦截。\n            intercepted = true;\n        }\n\n          // 判断事件是否是针对可访问的焦点视图\n        if (intercepted || mFirstTouchTarget != null) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        // 检查事件是否被取消(ACTION_CANCEL).\n        final boolean canceled = resetCancelNextUpFlag(this)\n                || actionMasked == MotionEvent.ACTION_CANCEL;\n\n        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;\n        TouchTarget newTouchTarget = null;\n        boolean alreadyDispatchedToNewTouchTarget = false;\n\n          // 如果没有取消也没有被拦截    (进入事件分发)\n        if (!canceled &amp;&amp; !intercepted) {\n\n            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的视图。\n              // 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。 \n            // 我们检测并避免保持这种状态，因为这些事非常罕见。\n            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                    ? findChildWithAccessibilityFocus() : null;\n\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)\n                        : TouchTarget.ALL_POINTER_IDS;\n\n                // 清除此指针ID的早期触摸目标，防止不同步。\n                removePointersFromTouchTargets(idBitsToAssign);\n\n                final int childrenCount = mChildrenCount;\n                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {\n                    final float x = ev.getX(actionIndex);    // 获取触摸位置坐标\n                    final float y = ev.getY(actionIndex);\n                    // 查找可以接受事件的 ChildView\n                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();\n                    final boolean customOrder = preorderedList == null\n                            &amp;&amp; isChildrenDrawingOrderEnabled();\n                    final View[] children = mChildren;\n                      // ▼注意，从最后向前扫描\n                    for (int i = childrenCount - 1; i &gt;= 0; i--) {\n                        final int childIndex = customOrder\n                                ? getChildDrawingOrder(childrenCount, i) : i;\n                        final View child = (preorderedList == null)\n                                ? children[childIndex] : preorderedList.get(childIndex);\n\n                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，\n                          // 如果不处理，我们将执行正常的分派。 \n                          // 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。\n                        if (childWithAccessibilityFocus != null) {\n                            if (childWithAccessibilityFocus != child) {\n                                continue;\n                            }\n                            childWithAccessibilityFocus = null;\n                            i = childrenCount - 1;\n                        }\n\n                          // 检查View是否允许接受事件(即处于显示状态(VISIBLE)或者正在播放动画)\n                          // 检查触摸位置是否在View区域内\n                        if (!canViewReceivePointerEvents(child)\n                                || !isTransformedTouchPointInView(x, y, child, null)) {\n                            ev.setTargetAccessibilityFocus(false);\n                            continue;\n                        }\n\n                          // getTouchTarget 中判断了 child 是否包含在 mFirstTouchTarget 中\n                          // 如果有返回 target，如果没有返回 null \n                        newTouchTarget = getTouchTarget(child);\n                        if (newTouchTarget != null) {\n                            // ChildView 已经准备好接受在其区域内的事件。\n                            newTouchTarget.pointerIdBits |= idBitsToAssign;\n                            break;    // ◀︎已经找到目标View，跳出循环\n                        }\n\n                        resetCancelNextUpFlag(child);\n                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                            mLastTouchDownTime = ev.getDownTime();\n                            if (preorderedList != null) {\n                                for (int j = 0; j &lt; childrenCount; j++) {\n                                    if (children[childIndex] == mChildren[j]) {\n                                        mLastTouchDownIndex = j;\n                                        break;\n                                    }\n                                }\n                            } else {\n                                mLastTouchDownIndex = childIndex;\n                            }\n                            mLastTouchDownX = ev.getX();\n                            mLastTouchDownY = ev.getY();\n                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                            alreadyDispatchedToNewTouchTarget = true;\n                            break;\n                        }\n\n                        ev.setTargetAccessibilityFocus(false);\n                    }\n                    if (preorderedList != null) preorderedList.clear();\n                }\n\n                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {\n                    // 没有找到 ChildView 接收事件\n                    newTouchTarget = mFirstTouchTarget;\n                    while (newTouchTarget.next != null) {\n                        newTouchTarget = newTouchTarget.next;\n                    }\n                    newTouchTarget.pointerIdBits |= idBitsToAssign;\n                }\n            }\n        }\n\n        // 分发 TouchTarget\n        if (mFirstTouchTarget == null) {\n            // 没有 TouchTarget，将当前 ViewGroup 当作普通的 View 处理。\n            handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                    TouchTarget.ALL_POINTER_IDS);\n        } else {\n            // 分发TouchTarget，如果我们已经分发过，则避免分配给新的目标。 \n              // 如有必要，取消分发。\n            TouchTarget predecessor = null;\n            TouchTarget target = mFirstTouchTarget;\n            while (target != null) {\n                final TouchTarget next = target.next;\n                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {\n                    handled = true;\n                } else {\n                    final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                            || intercepted;\n                    if (dispatchTransformedTouchEvent(ev, cancelChild,\n                            target.child, target.pointerIdBits)) {\n                        handled = true;\n                    }\n                    if (cancelChild) {\n                        if (predecessor == null) {\n                            mFirstTouchTarget = next;\n                        } else {\n                            predecessor.next = next;\n                        }\n                        target.recycle();\n                        target = next;\n                        continue;\n                    }\n                }\n                predecessor = target;\n                target = next;\n            }\n        }\n\n        // 如果需要，更新指针的触摸目标列表或取消。\n        if (canceled\n                || actionMasked == MotionEvent.ACTION_UP\n                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n            resetTouchState();\n        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {\n            final int actionIndex = ev.getActionIndex();\n            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);\n            removePointersFromTouchTargets(idBitsToRemove);\n        }\n    }\n\n    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {\n        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n    }\n    return handled;\n}\n</code></pre><p>源码注释已经很详细了。</p>\n<h3 id=\"二、小结\"><a href=\"#二、小结\" class=\"headerlink\" title=\"二、小结\"></a>二、小结</h3><h4 id=\"1-同一个事件是从DOWN开始到UP结束的\"><a href=\"#1-同一个事件是从DOWN开始到UP结束的\" class=\"headerlink\" title=\"1. 同一个事件是从DOWN开始到UP结束的\"></a>1. 同一个事件是从DOWN开始到UP结束的</h4><h4 id=\"2-一个事件最终只能由一个View拦截和消费掉\"><a href=\"#2-一个事件最终只能由一个View拦截和消费掉\" class=\"headerlink\" title=\"2. 一个事件最终只能由一个View拦截和消费掉\"></a>2. 一个事件最终只能由一个View拦截和消费掉</h4><h4 id=\"3-某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\"><a href=\"#3-某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\" class=\"headerlink\" title=\"3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\"></a>3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了</h4><h4 id=\"4-如果一个View拦截了事件，但是如果它不消耗ACTION-DOWN事件，那么同一事件序列就不再会交由该View处理了。\"><a href=\"#4-如果一个View拦截了事件，但是如果它不消耗ACTION-DOWN事件，那么同一事件序列就不再会交由该View处理了。\" class=\"headerlink\" title=\"4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。\"></a>4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。</h4><h4 id=\"5-ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\"><a href=\"#5-ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\" class=\"headerlink\" title=\"5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\"></a>5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false</h4><h4 id=\"6-事件是否被消费由返回值决定，true-表示消费，false-表示不消费，与是否使用了事件无关。\"><a href=\"#6-事件是否被消费由返回值决定，true-表示消费，false-表示不消费，与是否使用了事件无关。\" class=\"headerlink\" title=\"6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。\"></a>6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。</h4><h4 id=\"7-View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\"><a href=\"#7-View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\" class=\"headerlink\" title=\"7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\"></a>7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用</h4><h4 id=\"8-View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\"><a href=\"#8-View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\" class=\"headerlink\" title=\"8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\"></a>8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。</h4><h4 id=\"9-事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\"><a href=\"#9-事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\" class=\"headerlink\" title=\"9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\"></a>9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View</h4><h4 id=\"10-如果当前正在处理的事件被上层-View-拦截，会收到一个-ACTION-CANCEL，后续事件不会再传递过来。\"><a href=\"#10-如果当前正在处理的事件被上层-View-拦截，会收到一个-ACTION-CANCEL，后续事件不会再传递过来。\" class=\"headerlink\" title=\"10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。\"></a>10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、点击事件的传递规则\"><a href=\"#一、点击事件的传递规则\" class=\"headerlink\" title=\"一、点击事件的传递规则\"></a>一、点击事件的传递规则</h3><p>   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。</p>\n<h4 id=\"1-MotionEvent\"><a href=\"#1-MotionEvent\" class=\"headerlink\" title=\"1.MotionEvent\"></a>1.MotionEvent</h4><p>  常见的动作：</p>\n<p>  常见的动作常量：</p>\n<ul>\n<li><p>public static final int ACTION_DOWN = 0;单点触摸动作</p>\n</li>\n<li><p>public static final int ACTION_UP = 1;单点触摸离开动作</p>\n</li>\n<li>public static final int ACTION_MOVE = 2;触摸点移动动作</li>\n<li>public static final int ACTION_CANCEL = 3;触摸动作取消</li>\n<li>public static final int ACTION_OUTSIDE = 4;触摸动作超出边界</li>\n<li>public static final int ACTION_POINTER_DOWN = 5;多点触摸动作</li>\n<li>public static final int ACTION_POINTER_UP       = 6;多点离开动作</li>\n</ul>\n<pre><code>主要就是：\n\n* ACTION_DOWN--手指刚接触屏幕\n* ACTION_MOVE--手指在屏幕上滑动\n* ACTION_UP--手指离开屏幕\n</code></pre><h4 id=\"2-点击事件的分发中最重要的三个方法\"><a href=\"#2-点击事件的分发中最重要的三个方法\" class=\"headerlink\" title=\"2.点击事件的分发中最重要的三个方法\"></a>2.点击事件的分发中最重要的三个方法</h4><ul>\n<li><p>dispatchTouchEvent(MotionEvent event)–事件分发</p>\n<ul>\n<li>用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。</li>\n</ul>\n</li>\n<li><p>onInterceptTouchEvent(MotionEvent event)–事件拦截</p>\n<ul>\n<li>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。</li>\n</ul>\n</li>\n<li><p>onTouchEvent(MotionEvent event)–事件消费</p>\n<ul>\n<li>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-伪代码\"><a href=\"#3-伪代码\" class=\"headerlink\" title=\"3. 伪代码\"></a>3. 伪代码</h4><pre><code>public boolean dispatchTouchEvent(MotionEvent ev){\n    boolean touch = false;\n    if(onInterceptTouchEvent(ev)){\n        touch = onTouchEvent(ev);\n    }else{\n        touch = child.dispatchTouchEvent(ev);\n    }\n    return touch;\n}\n</code></pre><ul>\n<li><p>点击事件的传递规则：</p>\n<ul>\n<li><p>对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用     </p>\n</li>\n<li><p>首先判断自身是否处理，处理的话就会调用onInterceptTouchEvent(MotionEvent event),来判断是否处理，自身处理的话，就会调用onTouchEvent(MotionEvent event)，自己就把这次点击事件处理了</p>\n</li>\n<li><p>如果自身不处理，就不拦截，交给子View去处理。子View处理同样按照ViewGroup自身处理一致。子View不处理的话，最后则调用ViewGroup自身的onTouchEvent(MotionEvent event)消费掉此次点击事件</p>\n<p>经典的伪代码如上。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-同一次点击事件只能被一个-View-消费\"><a href=\"#4-同一次点击事件只能被一个-View-消费\" class=\"headerlink\" title=\"4.同一次点击事件只能被一个 View 消费\"></a>4.同一次点击事件只能被一个 View 消费</h4><p>  安卓为了保证所有的事件都是被一个 View 消费的，对第一次的事件( ACTION_DOWN )进行了特殊判断，View 只有消费了 ACTION_DOWN 事件，才能接收到后续的事件(可点击控件会默认消费所有事件)，并且会将后续所有事件传递过来，不会再传递给其他 View，除非上层 View 进行了拦截。<br>如果上层 View 拦截了当前正在处理的事件，会收到一个 ACTION_CANCEL，表示当前事件已经结束，后续事件不会再传递过来。</p>\n<p>借用GcsSloop源码分析：</p>\n<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {\n      // 调试用\n    if (mInputEventConsistencyVerifier != null) {\n        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);\n    }\n\n      // 判断事件是否是针对可访问的焦点视图(很晚才添加的内容，个人猜测和屏幕辅助相关，方便盲人等使用设备)\n    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {\n        ev.setTargetAccessibilityFocus(false);\n    }\n\n    boolean handled = false;\n    if (onFilterTouchEventForSecurity(ev)) {\n        final int action = ev.getAction();\n        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;\n\n        // 处理第一次ACTION_DOWN.\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // 清除之前所有的状态\n            cancelAndClearTouchTargets(ev);\n            resetTouchState();\n        }\n\n        // 检查是否需要拦截.\n        final boolean intercepted;\n        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;\n            if (!disallowIntercept) {\n                intercepted = onInterceptTouchEvent(ev);    // 询问是否拦截\n                ev.setAction(action);                         // 恢复操作，防止被更改\n            } else {\n                intercepted = false;\n            }\n        } else {\n              // 没有目标来处理该事件，而且也不是一个新的事件事件(ACTION_DOWN), 进行拦截。\n            intercepted = true;\n        }\n\n          // 判断事件是否是针对可访问的焦点视图\n        if (intercepted || mFirstTouchTarget != null) {\n            ev.setTargetAccessibilityFocus(false);\n        }\n\n        // 检查事件是否被取消(ACTION_CANCEL).\n        final boolean canceled = resetCancelNextUpFlag(this)\n                || actionMasked == MotionEvent.ACTION_CANCEL;\n\n        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;\n        TouchTarget newTouchTarget = null;\n        boolean alreadyDispatchedToNewTouchTarget = false;\n\n          // 如果没有取消也没有被拦截    (进入事件分发)\n        if (!canceled &amp;&amp; !intercepted) {\n\n            // 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的视图。\n              // 如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。 \n            // 我们检测并避免保持这种状态，因为这些事非常罕见。\n            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\n                    ? findChildWithAccessibilityFocus() : null;\n\n            if (actionMasked == MotionEvent.ACTION_DOWN\n                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n                final int actionIndex = ev.getActionIndex();\n                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)\n                        : TouchTarget.ALL_POINTER_IDS;\n\n                // 清除此指针ID的早期触摸目标，防止不同步。\n                removePointersFromTouchTargets(idBitsToAssign);\n\n                final int childrenCount = mChildrenCount;\n                if (newTouchTarget == null &amp;&amp; childrenCount != 0) {\n                    final float x = ev.getX(actionIndex);    // 获取触摸位置坐标\n                    final float y = ev.getY(actionIndex);\n                    // 查找可以接受事件的 ChildView\n                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();\n                    final boolean customOrder = preorderedList == null\n                            &amp;&amp; isChildrenDrawingOrderEnabled();\n                    final View[] children = mChildren;\n                      // ▼注意，从最后向前扫描\n                    for (int i = childrenCount - 1; i &gt;= 0; i--) {\n                        final int childIndex = customOrder\n                                ? getChildDrawingOrder(childrenCount, i) : i;\n                        final View child = (preorderedList == null)\n                                ? children[childIndex] : preorderedList.get(childIndex);\n\n                        // 如果有一个视图具有可访问性焦点，我们希望它首先获取事件，\n                          // 如果不处理，我们将执行正常的分派。 \n                          // 尽管这可能会分发两次，但它能保证在给定的时间内更安全的执行。\n                        if (childWithAccessibilityFocus != null) {\n                            if (childWithAccessibilityFocus != child) {\n                                continue;\n                            }\n                            childWithAccessibilityFocus = null;\n                            i = childrenCount - 1;\n                        }\n\n                          // 检查View是否允许接受事件(即处于显示状态(VISIBLE)或者正在播放动画)\n                          // 检查触摸位置是否在View区域内\n                        if (!canViewReceivePointerEvents(child)\n                                || !isTransformedTouchPointInView(x, y, child, null)) {\n                            ev.setTargetAccessibilityFocus(false);\n                            continue;\n                        }\n\n                          // getTouchTarget 中判断了 child 是否包含在 mFirstTouchTarget 中\n                          // 如果有返回 target，如果没有返回 null \n                        newTouchTarget = getTouchTarget(child);\n                        if (newTouchTarget != null) {\n                            // ChildView 已经准备好接受在其区域内的事件。\n                            newTouchTarget.pointerIdBits |= idBitsToAssign;\n                            break;    // ◀︎已经找到目标View，跳出循环\n                        }\n\n                        resetCancelNextUpFlag(child);\n                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                            mLastTouchDownTime = ev.getDownTime();\n                            if (preorderedList != null) {\n                                for (int j = 0; j &lt; childrenCount; j++) {\n                                    if (children[childIndex] == mChildren[j]) {\n                                        mLastTouchDownIndex = j;\n                                        break;\n                                    }\n                                }\n                            } else {\n                                mLastTouchDownIndex = childIndex;\n                            }\n                            mLastTouchDownX = ev.getX();\n                            mLastTouchDownY = ev.getY();\n                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                            alreadyDispatchedToNewTouchTarget = true;\n                            break;\n                        }\n\n                        ev.setTargetAccessibilityFocus(false);\n                    }\n                    if (preorderedList != null) preorderedList.clear();\n                }\n\n                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {\n                    // 没有找到 ChildView 接收事件\n                    newTouchTarget = mFirstTouchTarget;\n                    while (newTouchTarget.next != null) {\n                        newTouchTarget = newTouchTarget.next;\n                    }\n                    newTouchTarget.pointerIdBits |= idBitsToAssign;\n                }\n            }\n        }\n\n        // 分发 TouchTarget\n        if (mFirstTouchTarget == null) {\n            // 没有 TouchTarget，将当前 ViewGroup 当作普通的 View 处理。\n            handled = dispatchTransformedTouchEvent(ev, canceled, null,\n                    TouchTarget.ALL_POINTER_IDS);\n        } else {\n            // 分发TouchTarget，如果我们已经分发过，则避免分配给新的目标。 \n              // 如有必要，取消分发。\n            TouchTarget predecessor = null;\n            TouchTarget target = mFirstTouchTarget;\n            while (target != null) {\n                final TouchTarget next = target.next;\n                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {\n                    handled = true;\n                } else {\n                    final boolean cancelChild = resetCancelNextUpFlag(target.child)\n                            || intercepted;\n                    if (dispatchTransformedTouchEvent(ev, cancelChild,\n                            target.child, target.pointerIdBits)) {\n                        handled = true;\n                    }\n                    if (cancelChild) {\n                        if (predecessor == null) {\n                            mFirstTouchTarget = next;\n                        } else {\n                            predecessor.next = next;\n                        }\n                        target.recycle();\n                        target = next;\n                        continue;\n                    }\n                }\n                predecessor = target;\n                target = next;\n            }\n        }\n\n        // 如果需要，更新指针的触摸目标列表或取消。\n        if (canceled\n                || actionMasked == MotionEvent.ACTION_UP\n                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n            resetTouchState();\n        } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {\n            final int actionIndex = ev.getActionIndex();\n            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);\n            removePointersFromTouchTargets(idBitsToRemove);\n        }\n    }\n\n    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {\n        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\n    }\n    return handled;\n}\n</code></pre><p>源码注释已经很详细了。</p>\n<h3 id=\"二、小结\"><a href=\"#二、小结\" class=\"headerlink\" title=\"二、小结\"></a>二、小结</h3><h4 id=\"1-同一个事件是从DOWN开始到UP结束的\"><a href=\"#1-同一个事件是从DOWN开始到UP结束的\" class=\"headerlink\" title=\"1. 同一个事件是从DOWN开始到UP结束的\"></a>1. 同一个事件是从DOWN开始到UP结束的</h4><h4 id=\"2-一个事件最终只能由一个View拦截和消费掉\"><a href=\"#2-一个事件最终只能由一个View拦截和消费掉\" class=\"headerlink\" title=\"2. 一个事件最终只能由一个View拦截和消费掉\"></a>2. 一个事件最终只能由一个View拦截和消费掉</h4><h4 id=\"3-某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\"><a href=\"#3-某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\" class=\"headerlink\" title=\"3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了\"></a>3. 某个View一旦拦截了，那么久都由它来处理，并且它的onInterceptTouchEvent不会再被调用。因为事件交给要拦截的View处理，就不需要再调用onInterceptTouchEvent去询问是否要拦截事件了</h4><h4 id=\"4-如果一个View拦截了事件，但是如果它不消耗ACTION-DOWN事件，那么同一事件序列就不再会交由该View处理了。\"><a href=\"#4-如果一个View拦截了事件，但是如果它不消耗ACTION-DOWN事件，那么同一事件序列就不再会交由该View处理了。\" class=\"headerlink\" title=\"4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。\"></a>4. 如果一个View拦截了事件，但是如果它不消耗ACTION_DOWN事件，那么同一事件序列就不再会交由该View处理了。</h4><h4 id=\"5-ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\"><a href=\"#5-ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\" class=\"headerlink\" title=\"5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false\"></a>5. ViewGroup默认是不拦截任何事件的，源码中ViewGroup的onInterceptTouchEvent默认返回false</h4><h4 id=\"6-事件是否被消费由返回值决定，true-表示消费，false-表示不消费，与是否使用了事件无关。\"><a href=\"#6-事件是否被消费由返回值决定，true-表示消费，false-表示不消费，与是否使用了事件无关。\" class=\"headerlink\" title=\"6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。\"></a>6. 事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。</h4><h4 id=\"7-View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\"><a href=\"#7-View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\" class=\"headerlink\" title=\"7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用\"></a>7. View没有onInterceptTouchEvent方法，一旦事件分发到View，那么它的onTouchEven就会被调用</h4><h4 id=\"8-View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\"><a href=\"#8-View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\" class=\"headerlink\" title=\"8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。\"></a>8. View的onTouchEvent方法默认会消耗事件即返回true，除非是不可点击的。</h4><h4 id=\"9-事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\"><a href=\"#9-事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\" class=\"headerlink\" title=\"9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View\"></a>9. 事件的传递过程是由外向内的，即先传给父元素，然后再由父元素分发给子View</h4><h4 id=\"10-如果当前正在处理的事件被上层-View-拦截，会收到一个-ACTION-CANCEL，后续事件不会再传递过来。\"><a href=\"#10-如果当前正在处理的事件被上层-View-拦截，会收到一个-ACTION-CANCEL，后续事件不会再传递过来。\" class=\"headerlink\" title=\"10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。\"></a>10. 如果当前正在处理的事件被上层 View 拦截，会收到一个 ACTION_CANCEL，后续事件不会再传递过来。</h4>"},{"title":"Android四大组件之BroadCast","date":"2018-09-17T05:40:28.000Z","_content":"\n### Android四大组件之BroadCast\n\n#### 一、广播概述\n\nAndroid应用可以从Android系统和其他Android应用发送或接收广播消息，是观察者设计模式，即一对多的关系。例如，应用程序还可以发送自定义广播，以通知其他应用程序可能感兴趣的内容（例如，已下载了一些新数据）。\n\n广播是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的广播进行过滤接收并响应的一类组件；\n\nBroadcastReceiver自身并不实现图形用户界面，但是当它收到某个通知后，BroadcastReceiver可以启动Activity作为响应，或者通过NotificationMananger提醒用户，或者启动Service等等。\n\n经常说”发送广播“和”接收广播“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。\n\n\n#### 二、广播分类\n\nAndroid中的BroadCast类型主要分为5类:\n\n* Normal BroadCast(普通广播)\n* System BroadCast(系统广播)\n* Ordered BroadCast(有序广播)\n* Sticky BroadCast(粘性广播)\n* Local BroadCast(App应用内广播)\n\n\n#### 三、广播的注册和接收\n\n广播的注册分为两种：静态注册和动态注册\n\n##### 1.静态注册\n\n静态注册就是在AndroidManifest中注册，\n\n\t<receiver \n    //此广播接收者类是MyBroadCastReceiver\n    android:name=\".MyBroadCastReceiver\" >\n    //用于接收网络状态改变时发出的广播\n    <intent-filter>\n        <action android:name=\"com.test.mybroadcast\" />\n    </intent-filter>\n\t</receiver>\n\t\n\t\n##### 2.动态注册\n\n需要在代码中实现\n\n    IntentFilter intentFilter = new IntentFilter();\n    intentFilter.addAction(\"com.action.myreceiver\");\n    myReceiver = new MyReceiver();\n    registerReceiver(myReceiver, intentFilter);\n\n注意：动态注册后记得解绑注册。\n\n\n#### 四、常用广播的简单使用\n\n##### 1.普通广播\n\n普通广播的使用，在第三点中已举例说明，不再重复。\n\n##### 2.系统广播\n\nAndroid中内置了一些系统广播。常见的有开关机、网络、电话短信、拍照等等。\n\n例如：\n\n* 监听网络变化\tandroid.net.conn.CONNECTIVITY_CHANGE\n\n* 关闭或打开飞行模式\tIntent.ACTION_AIRPLANE_MODE_CHANGED\n\n* 充电时或电量发生变化\tIntent.ACTION_BATTERY_CHANGED\n\n* 电池电量低\tIntent.ACTION_BATTERY_LOW\n\n* 电池电量充足（即从电量低变化到饱满时会发出广播\tIntent.ACTION_BATTERY_OKAY\n\n* 系统启动完成后(仅广播一次)\tIntent.ACTION_BOOT_COMPLETED\n\n* 按下照相时的拍照按键(硬件按键)时\tIntent.ACTION_CAMERA_BUTTON\n\n* 屏幕锁屏\tIntent.ACTION_CLOSE_SYSTEM_DIALOGS\n\n* 设备当前设置被改变时(界面语言、设备方向等)\tIntent.ACTION_CONFIGURATION_CHANGED\n\n* 插入耳机时\tIntent.ACTION_HEADSET_PLUG\n\n* 插入外部储存装置（如SD卡）\tIntent.ACTION_MEDIA_CHECKING\n\n* 成功安装APK\tIntent.ACTION_PACKAGE_ADDED\n\n* 成功删除APK\tIntent.ACTION_PACKAGE_REMOVED\n\n* 重启设备\tIntent.ACTION_REBOOT\n\n* 屏幕被关闭\tIntent.ACTION_SCREEN_OFF\n\n* 屏幕被打开\tIntent.ACTION_SCREEN_ON\n\n* 关闭系统时\tIntent.ACTION_SHUTDOWN\n\n* 重启设备\tIntent.ACTION_REBOOT\n\n\n##### 3.有序广播\n\n有序广播，也比较常用。发送广播和普通广播的区别是有序广播 通过sendOrderedBroadCast发送广播。\n有序广播的顺序，体现在广播接收者中，是按照广播接收者的优先顺序来的，优先级在清单文件中广播接收者的intent-filter中通过设置priority属性来定义。\n例如：\n\t\n\t<intent-filter android:priority=\"2000\">\n\t\npriority值越大，表示优先级越高\n\n当优先级最高的广播接收者接收到广播后，可以通过setResult继续传递广播，也可以通过abortBroadcast()中断广播的继续传播\n\n代码示例：\n\n\t<receiver\n        android:name=\".MyOrderedReceiver\"\n        android:enabled=\"true\"\n        android:exported=\"true\">\n        <intent-filter android:priority=\"1000\">\n            <action android:name=\"com.neil.ordered\" />\n        </intent-filter>\n    </receiver>\n    <receiver\n        android:name=\".MySecondOrderedReceiver\"\n        android:enabled=\"true\"\n        android:exported=\"true\">\n        <intent-filter android:priority=\"500\">\n            <action android:name=\"com.neil.ordered\" />\n        </intent-filter>\n    </receiver>\n    \n   \n 发送广播：\n \n\tvoid sendOrderedBroadcast (Intent intent, \n\t                String receiverPermission)\n\t                \n接收广播和普通广播一样，只是按照优先级有接收的先后顺序。\n\n##### 4.粘性广播\n\n注册与接收和普通广播是一样的，但是需要添加权限，否则会抛出异常。\n\n\n\t<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n\n和普通广播的区别是，sendStickyBroadcast它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。比较简单，就不举例说明了。\n\n##### 5.应用内广播\n\n应用内广播更加安全。用法基本一样，只是应用内广播是通过LocalBroadcastManager来实现的。示例如下：\n\n首先还是注册和解绑的操作，\n        \t\n\tLocalBroadcastManager.getInstance(this).registerReceiver(localBroadcastDemo,intentFilter);\n\n\tLocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadcastDemo);\n\n\n组装好Intent后，发送广播。\n\n\tLocalBroadcastManager.getInstance(MainActivity.this).sendBroadcast(intent);\n\t\n广播接收者和普通广播一样。\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n","source":"_posts/Android四大组件之BroadCast.md","raw":"---\ntitle: Android四大组件之BroadCast\ndate: 2018-09-17 13:40:28\ntags: [Android四大组件]\n---\n\n### Android四大组件之BroadCast\n\n#### 一、广播概述\n\nAndroid应用可以从Android系统和其他Android应用发送或接收广播消息，是观察者设计模式，即一对多的关系。例如，应用程序还可以发送自定义广播，以通知其他应用程序可能感兴趣的内容（例如，已下载了一些新数据）。\n\n广播是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的广播进行过滤接收并响应的一类组件；\n\nBroadcastReceiver自身并不实现图形用户界面，但是当它收到某个通知后，BroadcastReceiver可以启动Activity作为响应，或者通过NotificationMananger提醒用户，或者启动Service等等。\n\n经常说”发送广播“和”接收广播“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。\n\n\n#### 二、广播分类\n\nAndroid中的BroadCast类型主要分为5类:\n\n* Normal BroadCast(普通广播)\n* System BroadCast(系统广播)\n* Ordered BroadCast(有序广播)\n* Sticky BroadCast(粘性广播)\n* Local BroadCast(App应用内广播)\n\n\n#### 三、广播的注册和接收\n\n广播的注册分为两种：静态注册和动态注册\n\n##### 1.静态注册\n\n静态注册就是在AndroidManifest中注册，\n\n\t<receiver \n    //此广播接收者类是MyBroadCastReceiver\n    android:name=\".MyBroadCastReceiver\" >\n    //用于接收网络状态改变时发出的广播\n    <intent-filter>\n        <action android:name=\"com.test.mybroadcast\" />\n    </intent-filter>\n\t</receiver>\n\t\n\t\n##### 2.动态注册\n\n需要在代码中实现\n\n    IntentFilter intentFilter = new IntentFilter();\n    intentFilter.addAction(\"com.action.myreceiver\");\n    myReceiver = new MyReceiver();\n    registerReceiver(myReceiver, intentFilter);\n\n注意：动态注册后记得解绑注册。\n\n\n#### 四、常用广播的简单使用\n\n##### 1.普通广播\n\n普通广播的使用，在第三点中已举例说明，不再重复。\n\n##### 2.系统广播\n\nAndroid中内置了一些系统广播。常见的有开关机、网络、电话短信、拍照等等。\n\n例如：\n\n* 监听网络变化\tandroid.net.conn.CONNECTIVITY_CHANGE\n\n* 关闭或打开飞行模式\tIntent.ACTION_AIRPLANE_MODE_CHANGED\n\n* 充电时或电量发生变化\tIntent.ACTION_BATTERY_CHANGED\n\n* 电池电量低\tIntent.ACTION_BATTERY_LOW\n\n* 电池电量充足（即从电量低变化到饱满时会发出广播\tIntent.ACTION_BATTERY_OKAY\n\n* 系统启动完成后(仅广播一次)\tIntent.ACTION_BOOT_COMPLETED\n\n* 按下照相时的拍照按键(硬件按键)时\tIntent.ACTION_CAMERA_BUTTON\n\n* 屏幕锁屏\tIntent.ACTION_CLOSE_SYSTEM_DIALOGS\n\n* 设备当前设置被改变时(界面语言、设备方向等)\tIntent.ACTION_CONFIGURATION_CHANGED\n\n* 插入耳机时\tIntent.ACTION_HEADSET_PLUG\n\n* 插入外部储存装置（如SD卡）\tIntent.ACTION_MEDIA_CHECKING\n\n* 成功安装APK\tIntent.ACTION_PACKAGE_ADDED\n\n* 成功删除APK\tIntent.ACTION_PACKAGE_REMOVED\n\n* 重启设备\tIntent.ACTION_REBOOT\n\n* 屏幕被关闭\tIntent.ACTION_SCREEN_OFF\n\n* 屏幕被打开\tIntent.ACTION_SCREEN_ON\n\n* 关闭系统时\tIntent.ACTION_SHUTDOWN\n\n* 重启设备\tIntent.ACTION_REBOOT\n\n\n##### 3.有序广播\n\n有序广播，也比较常用。发送广播和普通广播的区别是有序广播 通过sendOrderedBroadCast发送广播。\n有序广播的顺序，体现在广播接收者中，是按照广播接收者的优先顺序来的，优先级在清单文件中广播接收者的intent-filter中通过设置priority属性来定义。\n例如：\n\t\n\t<intent-filter android:priority=\"2000\">\n\t\npriority值越大，表示优先级越高\n\n当优先级最高的广播接收者接收到广播后，可以通过setResult继续传递广播，也可以通过abortBroadcast()中断广播的继续传播\n\n代码示例：\n\n\t<receiver\n        android:name=\".MyOrderedReceiver\"\n        android:enabled=\"true\"\n        android:exported=\"true\">\n        <intent-filter android:priority=\"1000\">\n            <action android:name=\"com.neil.ordered\" />\n        </intent-filter>\n    </receiver>\n    <receiver\n        android:name=\".MySecondOrderedReceiver\"\n        android:enabled=\"true\"\n        android:exported=\"true\">\n        <intent-filter android:priority=\"500\">\n            <action android:name=\"com.neil.ordered\" />\n        </intent-filter>\n    </receiver>\n    \n   \n 发送广播：\n \n\tvoid sendOrderedBroadcast (Intent intent, \n\t                String receiverPermission)\n\t                \n接收广播和普通广播一样，只是按照优先级有接收的先后顺序。\n\n##### 4.粘性广播\n\n注册与接收和普通广播是一样的，但是需要添加权限，否则会抛出异常。\n\n\n\t<uses-permission android:name=\"android.permission.BROADCAST_STICKY\" />\n\n和普通广播的区别是，sendStickyBroadcast它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。比较简单，就不举例说明了。\n\n##### 5.应用内广播\n\n应用内广播更加安全。用法基本一样，只是应用内广播是通过LocalBroadcastManager来实现的。示例如下：\n\n首先还是注册和解绑的操作，\n        \t\n\tLocalBroadcastManager.getInstance(this).registerReceiver(localBroadcastDemo,intentFilter);\n\n\tLocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadcastDemo);\n\n\n组装好Intent后，发送广播。\n\n\tLocalBroadcastManager.getInstance(MainActivity.this).sendBroadcast(intent);\n\t\n广播接收者和普通广播一样。\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n","slug":"Android四大组件之BroadCast","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn3000dx3c06m7x1lew","content":"<h3 id=\"Android四大组件之BroadCast\"><a href=\"#Android四大组件之BroadCast\" class=\"headerlink\" title=\"Android四大组件之BroadCast\"></a>Android四大组件之BroadCast</h3><h4 id=\"一、广播概述\"><a href=\"#一、广播概述\" class=\"headerlink\" title=\"一、广播概述\"></a>一、广播概述</h4><p>Android应用可以从Android系统和其他Android应用发送或接收广播消息，是观察者设计模式，即一对多的关系。例如，应用程序还可以发送自定义广播，以通知其他应用程序可能感兴趣的内容（例如，已下载了一些新数据）。</p>\n<p>广播是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的广播进行过滤接收并响应的一类组件；</p>\n<p>BroadcastReceiver自身并不实现图形用户界面，但是当它收到某个通知后，BroadcastReceiver可以启动Activity作为响应，或者通过NotificationMananger提醒用户，或者启动Service等等。</p>\n<p>经常说”发送广播“和”接收广播“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。</p>\n<h4 id=\"二、广播分类\"><a href=\"#二、广播分类\" class=\"headerlink\" title=\"二、广播分类\"></a>二、广播分类</h4><p>Android中的BroadCast类型主要分为5类:</p>\n<ul>\n<li>Normal BroadCast(普通广播)</li>\n<li>System BroadCast(系统广播)</li>\n<li>Ordered BroadCast(有序广播)</li>\n<li>Sticky BroadCast(粘性广播)</li>\n<li>Local BroadCast(App应用内广播)</li>\n</ul>\n<h4 id=\"三、广播的注册和接收\"><a href=\"#三、广播的注册和接收\" class=\"headerlink\" title=\"三、广播的注册和接收\"></a>三、广播的注册和接收</h4><p>广播的注册分为两种：静态注册和动态注册</p>\n<h5 id=\"1-静态注册\"><a href=\"#1-静态注册\" class=\"headerlink\" title=\"1.静态注册\"></a>1.静态注册</h5><p>静态注册就是在AndroidManifest中注册，</p>\n<pre><code>&lt;receiver \n//此广播接收者类是MyBroadCastReceiver\nandroid:name=&quot;.MyBroadCastReceiver&quot; &gt;\n//用于接收网络状态改变时发出的广播\n&lt;intent-filter&gt;\n    &lt;action android:name=&quot;com.test.mybroadcast&quot; /&gt;\n&lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>需要在代码中实现</p>\n<pre><code>IntentFilter intentFilter = new IntentFilter();\nintentFilter.addAction(&quot;com.action.myreceiver&quot;);\nmyReceiver = new MyReceiver();\nregisterReceiver(myReceiver, intentFilter);\n</code></pre><p>注意：动态注册后记得解绑注册。</p>\n<h4 id=\"四、常用广播的简单使用\"><a href=\"#四、常用广播的简单使用\" class=\"headerlink\" title=\"四、常用广播的简单使用\"></a>四、常用广播的简单使用</h4><h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>普通广播的使用，在第三点中已举例说明，不再重复。</p>\n<h5 id=\"2-系统广播\"><a href=\"#2-系统广播\" class=\"headerlink\" title=\"2.系统广播\"></a>2.系统广播</h5><p>Android中内置了一些系统广播。常见的有开关机、网络、电话短信、拍照等等。</p>\n<p>例如：</p>\n<ul>\n<li><p>监听网络变化    android.net.conn.CONNECTIVITY_CHANGE</p>\n</li>\n<li><p>关闭或打开飞行模式    Intent.ACTION_AIRPLANE_MODE_CHANGED</p>\n</li>\n<li><p>充电时或电量发生变化    Intent.ACTION_BATTERY_CHANGED</p>\n</li>\n<li><p>电池电量低    Intent.ACTION_BATTERY_LOW</p>\n</li>\n<li><p>电池电量充足（即从电量低变化到饱满时会发出广播    Intent.ACTION_BATTERY_OKAY</p>\n</li>\n<li><p>系统启动完成后(仅广播一次)    Intent.ACTION_BOOT_COMPLETED</p>\n</li>\n<li><p>按下照相时的拍照按键(硬件按键)时    Intent.ACTION_CAMERA_BUTTON</p>\n</li>\n<li><p>屏幕锁屏    Intent.ACTION_CLOSE_SYSTEM_DIALOGS</p>\n</li>\n<li><p>设备当前设置被改变时(界面语言、设备方向等)    Intent.ACTION_CONFIGURATION_CHANGED</p>\n</li>\n<li><p>插入耳机时    Intent.ACTION_HEADSET_PLUG</p>\n</li>\n<li><p>插入外部储存装置（如SD卡）    Intent.ACTION_MEDIA_CHECKING</p>\n</li>\n<li><p>成功安装APK    Intent.ACTION_PACKAGE_ADDED</p>\n</li>\n<li><p>成功删除APK    Intent.ACTION_PACKAGE_REMOVED</p>\n</li>\n<li><p>重启设备    Intent.ACTION_REBOOT</p>\n</li>\n<li><p>屏幕被关闭    Intent.ACTION_SCREEN_OFF</p>\n</li>\n<li><p>屏幕被打开    Intent.ACTION_SCREEN_ON</p>\n</li>\n<li><p>关闭系统时    Intent.ACTION_SHUTDOWN</p>\n</li>\n<li><p>重启设备    Intent.ACTION_REBOOT</p>\n</li>\n</ul>\n<h5 id=\"3-有序广播\"><a href=\"#3-有序广播\" class=\"headerlink\" title=\"3.有序广播\"></a>3.有序广播</h5><p>有序广播，也比较常用。发送广播和普通广播的区别是有序广播 通过sendOrderedBroadCast发送广播。<br>有序广播的顺序，体现在广播接收者中，是按照广播接收者的优先顺序来的，优先级在清单文件中广播接收者的intent-filter中通过设置priority属性来定义。<br>例如：</p>\n<pre><code>&lt;intent-filter android:priority=&quot;2000&quot;&gt;\n</code></pre><p>priority值越大，表示优先级越高</p>\n<p>当优先级最高的广播接收者接收到广播后，可以通过setResult继续传递广播，也可以通过abortBroadcast()中断广播的继续传播</p>\n<p>代码示例：</p>\n<pre><code>&lt;receiver\n    android:name=&quot;.MyOrderedReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter android:priority=&quot;1000&quot;&gt;\n        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n&lt;receiver\n    android:name=&quot;.MySecondOrderedReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter android:priority=&quot;500&quot;&gt;\n        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p> 发送广播：</p>\n<pre><code>void sendOrderedBroadcast (Intent intent, \n                String receiverPermission)\n</code></pre><p>接收广播和普通广播一样，只是按照优先级有接收的先后顺序。</p>\n<h5 id=\"4-粘性广播\"><a href=\"#4-粘性广播\" class=\"headerlink\" title=\"4.粘性广播\"></a>4.粘性广播</h5><p>注册与接收和普通广播是一样的，但是需要添加权限，否则会抛出异常。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;\n</code></pre><p>和普通广播的区别是，sendStickyBroadcast它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。比较简单，就不举例说明了。</p>\n<h5 id=\"5-应用内广播\"><a href=\"#5-应用内广播\" class=\"headerlink\" title=\"5.应用内广播\"></a>5.应用内广播</h5><p>应用内广播更加安全。用法基本一样，只是应用内广播是通过LocalBroadcastManager来实现的。示例如下：</p>\n<p>首先还是注册和解绑的操作，</p>\n<pre><code>LocalBroadcastManager.getInstance(this).registerReceiver(localBroadcastDemo,intentFilter);\n\nLocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadcastDemo);\n</code></pre><p>组装好Intent后，发送广播。</p>\n<pre><code>LocalBroadcastManager.getInstance(MainActivity.this).sendBroadcast(intent);\n</code></pre><p>广播接收者和普通广播一样。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android四大组件之BroadCast\"><a href=\"#Android四大组件之BroadCast\" class=\"headerlink\" title=\"Android四大组件之BroadCast\"></a>Android四大组件之BroadCast</h3><h4 id=\"一、广播概述\"><a href=\"#一、广播概述\" class=\"headerlink\" title=\"一、广播概述\"></a>一、广播概述</h4><p>Android应用可以从Android系统和其他Android应用发送或接收广播消息，是观察者设计模式，即一对多的关系。例如，应用程序还可以发送自定义广播，以通知其他应用程序可能感兴趣的内容（例如，已下载了一些新数据）。</p>\n<p>广播是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver是对发送出来的广播进行过滤接收并响应的一类组件；</p>\n<p>BroadcastReceiver自身并不实现图形用户界面，但是当它收到某个通知后，BroadcastReceiver可以启动Activity作为响应，或者通过NotificationMananger提醒用户，或者启动Service等等。</p>\n<p>经常说”发送广播“和”接收广播“，表面上看广播作为Android广播机制中的实体，实际上这一实体本身是并不是以所谓的”广播“对象存在的，而是以”意图“（Intent）去表示。定义广播的定义过程，实际就是相应广播”意图“的定义过程，然后通过广播发送者将此”意图“发送出去。被相应的BroadcastReceiver接收后将会回调onReceive()函数。</p>\n<h4 id=\"二、广播分类\"><a href=\"#二、广播分类\" class=\"headerlink\" title=\"二、广播分类\"></a>二、广播分类</h4><p>Android中的BroadCast类型主要分为5类:</p>\n<ul>\n<li>Normal BroadCast(普通广播)</li>\n<li>System BroadCast(系统广播)</li>\n<li>Ordered BroadCast(有序广播)</li>\n<li>Sticky BroadCast(粘性广播)</li>\n<li>Local BroadCast(App应用内广播)</li>\n</ul>\n<h4 id=\"三、广播的注册和接收\"><a href=\"#三、广播的注册和接收\" class=\"headerlink\" title=\"三、广播的注册和接收\"></a>三、广播的注册和接收</h4><p>广播的注册分为两种：静态注册和动态注册</p>\n<h5 id=\"1-静态注册\"><a href=\"#1-静态注册\" class=\"headerlink\" title=\"1.静态注册\"></a>1.静态注册</h5><p>静态注册就是在AndroidManifest中注册，</p>\n<pre><code>&lt;receiver \n//此广播接收者类是MyBroadCastReceiver\nandroid:name=&quot;.MyBroadCastReceiver&quot; &gt;\n//用于接收网络状态改变时发出的广播\n&lt;intent-filter&gt;\n    &lt;action android:name=&quot;com.test.mybroadcast&quot; /&gt;\n&lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><h5 id=\"2-动态注册\"><a href=\"#2-动态注册\" class=\"headerlink\" title=\"2.动态注册\"></a>2.动态注册</h5><p>需要在代码中实现</p>\n<pre><code>IntentFilter intentFilter = new IntentFilter();\nintentFilter.addAction(&quot;com.action.myreceiver&quot;);\nmyReceiver = new MyReceiver();\nregisterReceiver(myReceiver, intentFilter);\n</code></pre><p>注意：动态注册后记得解绑注册。</p>\n<h4 id=\"四、常用广播的简单使用\"><a href=\"#四、常用广播的简单使用\" class=\"headerlink\" title=\"四、常用广播的简单使用\"></a>四、常用广播的简单使用</h4><h5 id=\"1-普通广播\"><a href=\"#1-普通广播\" class=\"headerlink\" title=\"1.普通广播\"></a>1.普通广播</h5><p>普通广播的使用，在第三点中已举例说明，不再重复。</p>\n<h5 id=\"2-系统广播\"><a href=\"#2-系统广播\" class=\"headerlink\" title=\"2.系统广播\"></a>2.系统广播</h5><p>Android中内置了一些系统广播。常见的有开关机、网络、电话短信、拍照等等。</p>\n<p>例如：</p>\n<ul>\n<li><p>监听网络变化    android.net.conn.CONNECTIVITY_CHANGE</p>\n</li>\n<li><p>关闭或打开飞行模式    Intent.ACTION_AIRPLANE_MODE_CHANGED</p>\n</li>\n<li><p>充电时或电量发生变化    Intent.ACTION_BATTERY_CHANGED</p>\n</li>\n<li><p>电池电量低    Intent.ACTION_BATTERY_LOW</p>\n</li>\n<li><p>电池电量充足（即从电量低变化到饱满时会发出广播    Intent.ACTION_BATTERY_OKAY</p>\n</li>\n<li><p>系统启动完成后(仅广播一次)    Intent.ACTION_BOOT_COMPLETED</p>\n</li>\n<li><p>按下照相时的拍照按键(硬件按键)时    Intent.ACTION_CAMERA_BUTTON</p>\n</li>\n<li><p>屏幕锁屏    Intent.ACTION_CLOSE_SYSTEM_DIALOGS</p>\n</li>\n<li><p>设备当前设置被改变时(界面语言、设备方向等)    Intent.ACTION_CONFIGURATION_CHANGED</p>\n</li>\n<li><p>插入耳机时    Intent.ACTION_HEADSET_PLUG</p>\n</li>\n<li><p>插入外部储存装置（如SD卡）    Intent.ACTION_MEDIA_CHECKING</p>\n</li>\n<li><p>成功安装APK    Intent.ACTION_PACKAGE_ADDED</p>\n</li>\n<li><p>成功删除APK    Intent.ACTION_PACKAGE_REMOVED</p>\n</li>\n<li><p>重启设备    Intent.ACTION_REBOOT</p>\n</li>\n<li><p>屏幕被关闭    Intent.ACTION_SCREEN_OFF</p>\n</li>\n<li><p>屏幕被打开    Intent.ACTION_SCREEN_ON</p>\n</li>\n<li><p>关闭系统时    Intent.ACTION_SHUTDOWN</p>\n</li>\n<li><p>重启设备    Intent.ACTION_REBOOT</p>\n</li>\n</ul>\n<h5 id=\"3-有序广播\"><a href=\"#3-有序广播\" class=\"headerlink\" title=\"3.有序广播\"></a>3.有序广播</h5><p>有序广播，也比较常用。发送广播和普通广播的区别是有序广播 通过sendOrderedBroadCast发送广播。<br>有序广播的顺序，体现在广播接收者中，是按照广播接收者的优先顺序来的，优先级在清单文件中广播接收者的intent-filter中通过设置priority属性来定义。<br>例如：</p>\n<pre><code>&lt;intent-filter android:priority=&quot;2000&quot;&gt;\n</code></pre><p>priority值越大，表示优先级越高</p>\n<p>当优先级最高的广播接收者接收到广播后，可以通过setResult继续传递广播，也可以通过abortBroadcast()中断广播的继续传播</p>\n<p>代码示例：</p>\n<pre><code>&lt;receiver\n    android:name=&quot;.MyOrderedReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter android:priority=&quot;1000&quot;&gt;\n        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n&lt;receiver\n    android:name=&quot;.MySecondOrderedReceiver&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;&gt;\n    &lt;intent-filter android:priority=&quot;500&quot;&gt;\n        &lt;action android:name=&quot;com.neil.ordered&quot; /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre><p> 发送广播：</p>\n<pre><code>void sendOrderedBroadcast (Intent intent, \n                String receiverPermission)\n</code></pre><p>接收广播和普通广播一样，只是按照优先级有接收的先后顺序。</p>\n<h5 id=\"4-粘性广播\"><a href=\"#4-粘性广播\" class=\"headerlink\" title=\"4.粘性广播\"></a>4.粘性广播</h5><p>注册与接收和普通广播是一样的，但是需要添加权限，否则会抛出异常。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;\n</code></pre><p>和普通广播的区别是，sendStickyBroadcast它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。比较简单，就不举例说明了。</p>\n<h5 id=\"5-应用内广播\"><a href=\"#5-应用内广播\" class=\"headerlink\" title=\"5.应用内广播\"></a>5.应用内广播</h5><p>应用内广播更加安全。用法基本一样，只是应用内广播是通过LocalBroadcastManager来实现的。示例如下：</p>\n<p>首先还是注册和解绑的操作，</p>\n<pre><code>LocalBroadcastManager.getInstance(this).registerReceiver(localBroadcastDemo,intentFilter);\n\nLocalBroadcastManager.getInstance(this).unregisterReceiver(localBroadcastDemo);\n</code></pre><p>组装好Intent后，发送广播。</p>\n<pre><code>LocalBroadcastManager.getInstance(MainActivity.this).sendBroadcast(intent);\n</code></pre><p>广播接收者和普通广播一样。</p>\n"},{"title":"Android四大组件之ContentProvider","date":"2018-09-18T07:20:49.000Z","_content":"\n### 一、简介\n\nContentProvider为不同的软件之间数据共享，提供统一的接口\n\n内容提供器（ContentProvider）主要用于在不同的应用程序之间实现数据共享的功能。它提供一整套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。\n\n内容提供器非常类似于数据库，可以使用insert()、update()、delete()、query()方法进行插入更新删除查询数据，大多数情况下，此数据存储在SqliteS数据库中。\n\n不过和Sqlite不同的是，内容提供器的几种增删改查的方法是不接受表名参数的，而是使用Uri。\n\n### 二、内容Uri\n\nContentProvider的内容Uri格式是固定的，下面详细介绍一下。\n\n\tcontent://<authority>/<data_path>\n\t\n\t例如：content://com.neil.myprovider/table_contact/666\n\t\n* content://是通用前缀，表示该Uri用于ContentProvider定位资源。\n\n*  authority：授权信息，以区别不同的ContentProvider.\n\n*  path:表名，用来区分ContentProvider中的不同的表\n\n### 三、基本使用\n\n内容提供者是android应用程序的基本构建块之一，它们封装数据并将封装的数据通过单一的ContentResolver接口提供给应用程序。当你需要在多个应用之间共享数据的时候就需要用到内容提供者。例如，手机中的联系人数据会被多个应用所用到所以必须要用内容提供者存储起来。如果你不需要在多个应用之间共享数据，你可以使用一个数据库，直接通过SQLite数据库。 当通过contentresolver发送一个请求时，系统会检查给定的URI并把请求传给有注册授权的Contentprovider。 UriMatcher类有助于解析uri。\n\n需要实现的方法有：\n\n\tpublic boolean onCreate() 在创建ContentProvider时调用\n\t\n\tpublic Cursor query(Uri, String[], String, String[], String) 用于查询指定Uri的ContentProvider，返回一个Cursor\n\t\n\tpublic Uri insert(Uri, ContentValues) 用于添加数据到指定Uri的ContentProvider中，(外部应用向ContentProvider中添加数据)\n\t\n\tpublic int update(Uri, ContentValues, String, String[]) 用于更新指定Uri的ContentProvider中的数据\n\t\n\tpublic int delete(Uri, String, String[]) 用于从指定Uri的ContentProvider中删除数据\n\t\n\tpublic String getType(Uri) 用于返回指定的Uri中的数据的MIME类型\n\t\n\n\n需要在AndroidManifest.xml中进行声明。\n","source":"_posts/Android四大组件之ContentProvider.md","raw":"---\ntitle: Android四大组件之ContentProvider\ndate: 2018-09-18 15:20:49\ntags: [Android四大组件]\n---\n\n### 一、简介\n\nContentProvider为不同的软件之间数据共享，提供统一的接口\n\n内容提供器（ContentProvider）主要用于在不同的应用程序之间实现数据共享的功能。它提供一整套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。\n\n内容提供器非常类似于数据库，可以使用insert()、update()、delete()、query()方法进行插入更新删除查询数据，大多数情况下，此数据存储在SqliteS数据库中。\n\n不过和Sqlite不同的是，内容提供器的几种增删改查的方法是不接受表名参数的，而是使用Uri。\n\n### 二、内容Uri\n\nContentProvider的内容Uri格式是固定的，下面详细介绍一下。\n\n\tcontent://<authority>/<data_path>\n\t\n\t例如：content://com.neil.myprovider/table_contact/666\n\t\n* content://是通用前缀，表示该Uri用于ContentProvider定位资源。\n\n*  authority：授权信息，以区别不同的ContentProvider.\n\n*  path:表名，用来区分ContentProvider中的不同的表\n\n### 三、基本使用\n\n内容提供者是android应用程序的基本构建块之一，它们封装数据并将封装的数据通过单一的ContentResolver接口提供给应用程序。当你需要在多个应用之间共享数据的时候就需要用到内容提供者。例如，手机中的联系人数据会被多个应用所用到所以必须要用内容提供者存储起来。如果你不需要在多个应用之间共享数据，你可以使用一个数据库，直接通过SQLite数据库。 当通过contentresolver发送一个请求时，系统会检查给定的URI并把请求传给有注册授权的Contentprovider。 UriMatcher类有助于解析uri。\n\n需要实现的方法有：\n\n\tpublic boolean onCreate() 在创建ContentProvider时调用\n\t\n\tpublic Cursor query(Uri, String[], String, String[], String) 用于查询指定Uri的ContentProvider，返回一个Cursor\n\t\n\tpublic Uri insert(Uri, ContentValues) 用于添加数据到指定Uri的ContentProvider中，(外部应用向ContentProvider中添加数据)\n\t\n\tpublic int update(Uri, ContentValues, String, String[]) 用于更新指定Uri的ContentProvider中的数据\n\t\n\tpublic int delete(Uri, String, String[]) 用于从指定Uri的ContentProvider中删除数据\n\t\n\tpublic String getType(Uri) 用于返回指定的Uri中的数据的MIME类型\n\t\n\n\n需要在AndroidManifest.xml中进行声明。\n","slug":"Android四大组件之ContentProvider","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn4000fx3c0m3lbcarq","content":"<h3 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h3><p>ContentProvider为不同的软件之间数据共享，提供统一的接口</p>\n<p>内容提供器（ContentProvider）主要用于在不同的应用程序之间实现数据共享的功能。它提供一整套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。</p>\n<p>内容提供器非常类似于数据库，可以使用insert()、update()、delete()、query()方法进行插入更新删除查询数据，大多数情况下，此数据存储在SqliteS数据库中。</p>\n<p>不过和Sqlite不同的是，内容提供器的几种增删改查的方法是不接受表名参数的，而是使用Uri。</p>\n<h3 id=\"二、内容Uri\"><a href=\"#二、内容Uri\" class=\"headerlink\" title=\"二、内容Uri\"></a>二、内容Uri</h3><p>ContentProvider的内容Uri格式是固定的，下面详细介绍一下。</p>\n<pre><code>content://&lt;authority&gt;/&lt;data_path&gt;\n\n例如：content://com.neil.myprovider/table_contact/666\n</code></pre><ul>\n<li><p>content://是通用前缀，表示该Uri用于ContentProvider定位资源。</p>\n</li>\n<li><p>authority：授权信息，以区别不同的ContentProvider.</p>\n</li>\n<li><p>path:表名，用来区分ContentProvider中的不同的表</p>\n</li>\n</ul>\n<h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>内容提供者是android应用程序的基本构建块之一，它们封装数据并将封装的数据通过单一的ContentResolver接口提供给应用程序。当你需要在多个应用之间共享数据的时候就需要用到内容提供者。例如，手机中的联系人数据会被多个应用所用到所以必须要用内容提供者存储起来。如果你不需要在多个应用之间共享数据，你可以使用一个数据库，直接通过SQLite数据库。 当通过contentresolver发送一个请求时，系统会检查给定的URI并把请求传给有注册授权的Contentprovider。 UriMatcher类有助于解析uri。</p>\n<p>需要实现的方法有：</p>\n<pre><code>public boolean onCreate() 在创建ContentProvider时调用\n\npublic Cursor query(Uri, String[], String, String[], String) 用于查询指定Uri的ContentProvider，返回一个Cursor\n\npublic Uri insert(Uri, ContentValues) 用于添加数据到指定Uri的ContentProvider中，(外部应用向ContentProvider中添加数据)\n\npublic int update(Uri, ContentValues, String, String[]) 用于更新指定Uri的ContentProvider中的数据\n\npublic int delete(Uri, String, String[]) 用于从指定Uri的ContentProvider中删除数据\n\npublic String getType(Uri) 用于返回指定的Uri中的数据的MIME类型\n</code></pre><p>需要在AndroidManifest.xml中进行声明。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h3><p>ContentProvider为不同的软件之间数据共享，提供统一的接口</p>\n<p>内容提供器（ContentProvider）主要用于在不同的应用程序之间实现数据共享的功能。它提供一整套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。</p>\n<p>内容提供器非常类似于数据库，可以使用insert()、update()、delete()、query()方法进行插入更新删除查询数据，大多数情况下，此数据存储在SqliteS数据库中。</p>\n<p>不过和Sqlite不同的是，内容提供器的几种增删改查的方法是不接受表名参数的，而是使用Uri。</p>\n<h3 id=\"二、内容Uri\"><a href=\"#二、内容Uri\" class=\"headerlink\" title=\"二、内容Uri\"></a>二、内容Uri</h3><p>ContentProvider的内容Uri格式是固定的，下面详细介绍一下。</p>\n<pre><code>content://&lt;authority&gt;/&lt;data_path&gt;\n\n例如：content://com.neil.myprovider/table_contact/666\n</code></pre><ul>\n<li><p>content://是通用前缀，表示该Uri用于ContentProvider定位资源。</p>\n</li>\n<li><p>authority：授权信息，以区别不同的ContentProvider.</p>\n</li>\n<li><p>path:表名，用来区分ContentProvider中的不同的表</p>\n</li>\n</ul>\n<h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>内容提供者是android应用程序的基本构建块之一，它们封装数据并将封装的数据通过单一的ContentResolver接口提供给应用程序。当你需要在多个应用之间共享数据的时候就需要用到内容提供者。例如，手机中的联系人数据会被多个应用所用到所以必须要用内容提供者存储起来。如果你不需要在多个应用之间共享数据，你可以使用一个数据库，直接通过SQLite数据库。 当通过contentresolver发送一个请求时，系统会检查给定的URI并把请求传给有注册授权的Contentprovider。 UriMatcher类有助于解析uri。</p>\n<p>需要实现的方法有：</p>\n<pre><code>public boolean onCreate() 在创建ContentProvider时调用\n\npublic Cursor query(Uri, String[], String, String[], String) 用于查询指定Uri的ContentProvider，返回一个Cursor\n\npublic Uri insert(Uri, ContentValues) 用于添加数据到指定Uri的ContentProvider中，(外部应用向ContentProvider中添加数据)\n\npublic int update(Uri, ContentValues, String, String[]) 用于更新指定Uri的ContentProvider中的数据\n\npublic int delete(Uri, String, String[]) 用于从指定Uri的ContentProvider中删除数据\n\npublic String getType(Uri) 用于返回指定的Uri中的数据的MIME类型\n</code></pre><p>需要在AndroidManifest.xml中进行声明。</p>\n"},{"title":"Android屏幕适配解决方案(1)","date":"2017-07-20T03:23:22.000Z","_content":"\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","source":"_posts/Android屏幕适配解决方案(1).md","raw":"---\ntitle: Android屏幕适配解决方案(1)\ndate: 2017-07-20 11:23:22\ntags: [Android]\n---\n\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","slug":"Android屏幕适配解决方案(1)","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn5000ix3c0si2atm9l","content":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n"},{"title":"Android四大组件之Service","date":"2018-04-16T02:09:43.000Z","_content":"### 一、Service简介\n\n##### Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n\n###### 服务基本上分为两种形式：\n\t\n* 启动\n\n * 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。\n\n* 绑定\n\n * 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。\n\n 两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。\n \n --\n \n 需要注意的是：\n \n 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。\n\n --\n \n \n### 二、如何创建\n\n#### 1.基础\n\n要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：\n\n * onStartCommand()\n\n  * 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）\n\n * onBind()\n \n  * 当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。\n  \n * onCreate()\n\n  * 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。\n\n* onDestory()\n\n * 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。\n\n\n######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。\n\n######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。\n\n\n仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务\n\n\n#### 2.清单文件中声明服务\n\n如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。\n\n要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：\n\n\t<manifest ... >\n\t  ...\n\t  <application ... >\n\t      <service android:name=\".ExampleService\" />\n\t      ...\n\t  </application>\n\t</manifest>\n\n\n还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。\n\n为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。\n\n此外，还可以通过添加 android:exported 属性并将其设置为 \"false\"，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。\n\n#### 3. 创建启动服务\n\n启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。\n\n服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。\n\n应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。\n\n例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。\n\n\n\n--\n\n注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。\n\n--\n\n\n两种方式：\n\n * Service\n\n  * 这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。\n\n * IntentService\n\n  * 这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。\n\n#### 4.IntentService\n\n由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。\n\nIntentService 执行以下操作：\n\n * 创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。\n\n * 创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。\n\n * 在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。\n\n * 提供 onBind() 的默认实现（返回 null）。\n\n * 提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。\n\n综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。\n\n举个例子：\n\n\tpublic class HelloIntentService extends IntentService {\n\t\n\t  /**\n\t   * A constructor is required, and must call the super IntentService(String)\n\t   * constructor with a name for the worker thread.\n\t   */\n\t  public HelloIntentService() {\n\t      super(\"HelloIntentService\");\n\t  }\n\t\n\t  /**\n\t   * The IntentService calls this method from the default worker thread with\n\t   * the intent that started the service. When this method returns, IntentService\n\t   * stops the service, as appropriate.\n\t   */\n\t  @Override\n\t  protected void onHandleIntent(Intent intent) {\n\t      // Normally we would do some work here, like download a file.\n\t      // For our sample, we just sleep for 5 seconds.\n\t      try {\n\t          Thread.sleep(5000);\n\t      } catch (InterruptedException e) {\n\t          // Restore interrupt status.\n\t          Thread.currentThread().interrupt();\n\t      }\n\t  }\n\t}\n\n只需要一个构造函数和一个 onHandleIntent() 实现即可。\n\n\n两种方式的生命周期如下：\n\n![service_lifecycle](http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png)\n","source":"_posts/Android四大组件之Service.md","raw":"---\ntitle: Android四大组件之Service\ndate: 2018-04-16 10:09:43\ntags: [Android四大组件]\n---\n### 一、Service简介\n\n##### Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\n\n\n###### 服务基本上分为两种形式：\n\t\n* 启动\n\n * 当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。\n\n* 绑定\n\n * 当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。\n\n 两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。\n \n --\n \n 需要注意的是：\n \n 服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。\n\n --\n \n \n### 二、如何创建\n\n#### 1.基础\n\n要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：\n\n * onStartCommand()\n\n  * 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）\n\n * onBind()\n \n  * 当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。\n  \n * onCreate()\n\n  * 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。\n\n* onDestory()\n\n * 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。\n\n\n######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。\n\n######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。\n\n\n仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务\n\n\n#### 2.清单文件中声明服务\n\n如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。\n\n要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：\n\n\t<manifest ... >\n\t  ...\n\t  <application ... >\n\t      <service android:name=\".ExampleService\" />\n\t      ...\n\t  </application>\n\t</manifest>\n\n\n还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。\n\n为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。\n\n此外，还可以通过添加 android:exported 属性并将其设置为 \"false\"，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。\n\n#### 3. 创建启动服务\n\n启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。\n\n服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。\n\n应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。\n\n例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。\n\n\n\n--\n\n注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。\n\n--\n\n\n两种方式：\n\n * Service\n\n  * 这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。\n\n * IntentService\n\n  * 这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。\n\n#### 4.IntentService\n\n由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。\n\nIntentService 执行以下操作：\n\n * 创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。\n\n * 创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。\n\n * 在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。\n\n * 提供 onBind() 的默认实现（返回 null）。\n\n * 提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。\n\n综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。\n\n举个例子：\n\n\tpublic class HelloIntentService extends IntentService {\n\t\n\t  /**\n\t   * A constructor is required, and must call the super IntentService(String)\n\t   * constructor with a name for the worker thread.\n\t   */\n\t  public HelloIntentService() {\n\t      super(\"HelloIntentService\");\n\t  }\n\t\n\t  /**\n\t   * The IntentService calls this method from the default worker thread with\n\t   * the intent that started the service. When this method returns, IntentService\n\t   * stops the service, as appropriate.\n\t   */\n\t  @Override\n\t  protected void onHandleIntent(Intent intent) {\n\t      // Normally we would do some work here, like download a file.\n\t      // For our sample, we just sleep for 5 seconds.\n\t      try {\n\t          Thread.sleep(5000);\n\t      } catch (InterruptedException e) {\n\t          // Restore interrupt status.\n\t          Thread.currentThread().interrupt();\n\t      }\n\t  }\n\t}\n\n只需要一个构造函数和一个 onHandleIntent() 实现即可。\n\n\n两种方式的生命周期如下：\n\n![service_lifecycle](http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png)\n","slug":"Android四大组件之Service","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn6000kx3c023w0pe41","content":"<h3 id=\"一、Service简介\"><a href=\"#一、Service简介\" class=\"headerlink\" title=\"一、Service简介\"></a>一、Service简介</h3><h5 id=\"Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。\"><a href=\"#Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。\" class=\"headerlink\" title=\"Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\"></a>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</h5><h6 id=\"服务基本上分为两种形式：\"><a href=\"#服务基本上分为两种形式：\" class=\"headerlink\" title=\"服务基本上分为两种形式：\"></a>服务基本上分为两种形式：</h6><ul>\n<li><p>启动</p>\n<ul>\n<li>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</li>\n</ul>\n</li>\n<li><p>绑定</p>\n<ul>\n<li>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</li>\n</ul>\n<p>两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>\n<p>–</p>\n<p>需要注意的是：</p>\n<p>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>\n<p>–</p>\n</li>\n</ul>\n<h3 id=\"二、如何创建\"><a href=\"#二、如何创建\" class=\"headerlink\" title=\"二、如何创建\"></a>二、如何创建</h3><h4 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1.基础\"></a>1.基础</h4><p>要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：</p>\n<ul>\n<li><p>onStartCommand()</p>\n<ul>\n<li>当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）</li>\n</ul>\n</li>\n<li><p>onBind()</p>\n<ul>\n<li>当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。</li>\n</ul>\n</li>\n<li><p>onCreate()</p>\n<ul>\n<li>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>onDestory()</p>\n<ul>\n<li>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</li>\n</ul>\n</li>\n</ul>\n<p>######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。</p>\n<p>######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>\n<p>仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务</p>\n<h4 id=\"2-清单文件中声明服务\"><a href=\"#2-清单文件中声明服务\" class=\"headerlink\" title=\"2.清单文件中声明服务\"></a>2.清单文件中声明服务</h4><p>如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。</p>\n<p>要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：</application></service></p>\n<pre><code>&lt;manifest ... &gt;\n  ...\n  &lt;application ... &gt;\n      &lt;service android:name=&quot;.ExampleService&quot; /&gt;\n      ...\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre><p>还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。</service></p>\n<p>为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。</p>\n<p>此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。</p>\n<h4 id=\"3-创建启动服务\"><a href=\"#3-创建启动服务\" class=\"headerlink\" title=\"3. 创建启动服务\"></a>3. 创建启动服务</h4><p>启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。</p>\n<p>服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。</p>\n<p>应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。</p>\n<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。</p>\n<p>–</p>\n<p>注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。</p>\n<p>–</p>\n<p>两种方式：</p>\n<ul>\n<li><p>Service</p>\n<ul>\n<li>这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。</li>\n</ul>\n</li>\n<li><p>IntentService</p>\n<ul>\n<li>这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-IntentService\"><a href=\"#4-IntentService\" class=\"headerlink\" title=\"4.IntentService\"></a>4.IntentService</h4><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。</p>\n<p>IntentService 执行以下操作：</p>\n<ul>\n<li><p>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</p>\n</li>\n<li><p>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。</p>\n</li>\n<li><p>在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。</p>\n</li>\n<li><p>提供 onBind() 的默认实现（返回 null）。</p>\n</li>\n<li><p>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</p>\n</li>\n</ul>\n<p>综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p>\n<p>举个例子：</p>\n<pre><code>public class HelloIntentService extends IntentService {\n\n  /**\n   * A constructor is required, and must call the super IntentService(String)\n   * constructor with a name for the worker thread.\n   */\n  public HelloIntentService() {\n      super(&quot;HelloIntentService&quot;);\n  }\n\n  /**\n   * The IntentService calls this method from the default worker thread with\n   * the intent that started the service. When this method returns, IntentService\n   * stops the service, as appropriate.\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // Normally we would do some work here, like download a file.\n      // For our sample, we just sleep for 5 seconds.\n      try {\n          Thread.sleep(5000);\n      } catch (InterruptedException e) {\n          // Restore interrupt status.\n          Thread.currentThread().interrupt();\n      }\n  }\n}\n</code></pre><p>只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>\n<p>两种方式的生命周期如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png\" alt=\"service_lifecycle\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Service简介\"><a href=\"#一、Service简介\" class=\"headerlink\" title=\"一、Service简介\"></a>一、Service简介</h3><h5 id=\"Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。\"><a href=\"#Service-是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。-此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信-IPC-。-例如，服务可以处理网络事务、播放音乐，执行文件-I-O-或与内容提供程序交互，而所有这一切均可在后台进行。\" class=\"headerlink\" title=\"Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。\"></a>Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。</h5><h6 id=\"服务基本上分为两种形式：\"><a href=\"#服务基本上分为两种形式：\" class=\"headerlink\" title=\"服务基本上分为两种形式：\"></a>服务基本上分为两种形式：</h6><ul>\n<li><p>启动</p>\n<ul>\n<li>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。</li>\n</ul>\n</li>\n<li><p>绑定</p>\n<ul>\n<li>当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</li>\n</ul>\n<p>两种形式是可以共存的，无论应用是处于启动状态还是绑定状态，抑或处于启动并且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用服务（即使此服务来自另一应用）。 不过，可以通过清单文件将服务声明为私有服务，并阻止其他应用访问。</p>\n<p>–</p>\n<p>需要注意的是：</p>\n<p>服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何 CPU 密集型工作或阻止性操作（例如 MP3 播放或联网），则应在服务内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。</p>\n<p>–</p>\n</li>\n</ul>\n<h3 id=\"二、如何创建\"><a href=\"#二、如何创建\" class=\"headerlink\" title=\"二、如何创建\"></a>二、如何创建</h3><h4 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1.基础\"></a>1.基础</h4><p>要创建服务，必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，需要重写一些回调方法，以处理服务生命周期的某些关键方面并提供一种机制将组件绑定到服务（如适用）。 应重写的最重要的回调方法包括：</p>\n<ul>\n<li><p>onStartCommand()</p>\n<ul>\n<li>当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果实现此方法，则在服务工作完成后，需要通过调用 stopSelf() 或 stopService() 来停止服务。（如果只想提供绑定，则无需实现此方法。）</li>\n</ul>\n</li>\n<li><p>onBind()</p>\n<ul>\n<li>当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果并不希望允许绑定，则应返回 null。</li>\n</ul>\n</li>\n<li><p>onCreate()</p>\n<ul>\n<li>首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。如果服务已在运行，则不会调用此方法。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>onDestory()</p>\n<ul>\n<li>当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等。 这是服务接收的最后一个调用。</li>\n</ul>\n</li>\n</ul>\n<p>######如果组件通过调用 startService() 启动服务（这会导致对 onStartCommand() 的调用），则服务将一直运行，直到服务使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。</p>\n<p>######如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁它。</p>\n<p>仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止服务。如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止；如果将服务声明为在前台运行（稍后讨论），则它几乎永远不会终止。或者，如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止；如果服务是启动服务，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务</p>\n<h4 id=\"2-清单文件中声明服务\"><a href=\"#2-清单文件中声明服务\" class=\"headerlink\" title=\"2.清单文件中声明服务\"></a>2.清单文件中声明服务</h4><p>如同 Activity（以及其他组件）一样，必须在应用的清单文件中声明所有服务。</p>\n<p>要声明服务，请添加 <service> 元素作为 <application> 元素的子元素。例如：</application></service></p>\n<pre><code>&lt;manifest ... &gt;\n  ...\n  &lt;application ... &gt;\n      &lt;service android:name=&quot;.ExampleService&quot; /&gt;\n      ...\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre><p>还可将其他属性包括在 <service> 元素中，以定义一些特性，如启动服务及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定服务的类名。</service></p>\n<p>为了确保应用的安全性，始终使用显式 Intent 启动或绑定 Service，且不要为服务声明 Intent 过滤器。 启动哪个服务存在一定的不确定性，而如果对这种不确定性的考量非常有必要，则可为服务提供 Intent 过滤器并从 Intent 中排除相应的组件名称，但随后必须使用 setPackage() 方法设置 Intent 的软件包，这样可以充分消除目标服务的不确定性。</p>\n<p>此外，还可以通过添加 android:exported 属性并将其设置为 “false”，确保服务仅适用于应用。这可以有效阻止其他应用启动服务，即便在使用显式 Intent 时也如此。</p>\n<h4 id=\"3-创建启动服务\"><a href=\"#3-创建启动服务\" class=\"headerlink\" title=\"3. 创建启动服务\"></a>3. 创建启动服务</h4><p>启动服务由另一个组件通过调用 startService() 启动，这会导致调用服务的 onStartCommand() 方法。</p>\n<p>服务启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动服务的组件已被销毁也不受影响。 因此，服务应通过调用 stopSelf() 结束工作来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。</p>\n<p>应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务通过 onStartCommand() 方法接收此 Intent。</p>\n<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 startService() 传递一个 Intent，为该服务提供要保存的数据。服务通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，服务会自行停止运行并随即被销毁。</p>\n<p>–</p>\n<p>注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果服务在用户与来自同一应用的 Activity 进行交互时执行密集型或阻止性操作，则会降低 Activity 性能。 为了避免影响应用性能，应在服务内启动新线程。</p>\n<p>–</p>\n<p>两种方式：</p>\n<ul>\n<li><p>Service</p>\n<ul>\n<li>这是适用于所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。</li>\n</ul>\n</li>\n<li><p>IntentService</p>\n<ul>\n<li>这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果不要求服务同时处理多个请求，这是最好的选择。 只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，就能够执行后台工作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-IntentService\"><a href=\"#4-IntentService\" class=\"headerlink\" title=\"4.IntentService\"></a>4.IntentService</h4><p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务也许是最好的选择。</p>\n<p>IntentService 执行以下操作：</p>\n<ul>\n<li><p>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</p>\n</li>\n<li><p>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样就永远不必担心多线程问题。</p>\n</li>\n<li><p>在处理完所有启动请求后停止服务，因此永远不必调用 stopSelf()。</p>\n</li>\n<li><p>提供 onBind() 的默认实现（返回 null）。</p>\n</li>\n<li><p>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</p>\n</li>\n</ul>\n<p>综上所述，只需实现 onHandleIntent() 来完成客户端提供的工作即可。</p>\n<p>举个例子：</p>\n<pre><code>public class HelloIntentService extends IntentService {\n\n  /**\n   * A constructor is required, and must call the super IntentService(String)\n   * constructor with a name for the worker thread.\n   */\n  public HelloIntentService() {\n      super(&quot;HelloIntentService&quot;);\n  }\n\n  /**\n   * The IntentService calls this method from the default worker thread with\n   * the intent that started the service. When this method returns, IntentService\n   * stops the service, as appropriate.\n   */\n  @Override\n  protected void onHandleIntent(Intent intent) {\n      // Normally we would do some work here, like download a file.\n      // For our sample, we just sleep for 5 seconds.\n      try {\n          Thread.sleep(5000);\n      } catch (InterruptedException e) {\n          // Restore interrupt status.\n          Thread.currentThread().interrupt();\n      }\n  }\n}\n</code></pre><p>只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>\n<p>两种方式的生命周期如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/service_lifecycle.png\" alt=\"service_lifecycle\"></p>\n"},{"title":"Android常见内存泄漏及解决办法","date":"2018-03-13T08:12:15.000Z","_content":"\n#### Why?\n\n当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。\n\n内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。\n\n\n#### How?\n\n主要几点：\n\n * Context\n * 内部类（handler等）\n * Cursor\n * Adapter\n * Bitmap\n\n##### 1. 单例造成的内存泄漏\n\n单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 \n\n例如：\n\n\tpublic class AppManager {\n\t    private static AppManager instance;\n\t    private Context context;\n\t    private AppManager(Context context) {\n\t        this.context = context;\n\t    }\n\t    public static AppManager getInstance(Context context) {\n\t        if (instance != null) {\n\t            instance = new AppManager(context);\n\t        }\n\t        return instance;\n\t    }\n\t}\n\t\n\t\n   * 传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 \n\n   \n   * 传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 \n\n   \n   \n 正确的单例：\n \n\t public class AppManager {\n\t    private static AppManager instance;\n\t    private Context context;\n\t    private AppManager(Context context) {\n\t        this.context = context.getApplicationContext();\n\t    }\n\t    public static AppManager getInstance(Context context) {\n\t        if (instance != null) {\n\t            instance = new AppManager(context);\n\t        }\n\t        return instance;\n\t    }\n\t}\n\t\n\t\n\t\n##### 2.非静态内部类创建静态实例造成的内存泄漏\n\n在实际的项目开发中，有时候我们需要频繁的启动某个页面（Activity），启动的时候总是需要初始化一些资源，为了避免重复创建相同资源，常常会使用静态对象去保存这些值，这种情况下，也很容易照成内存泄漏。我们举个例子：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t    private static TestResource mResource = null;\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        if(mManager == null){\n\t            mManager = new TestResource();\n\t        }\n\t        //...\n\t    }\n\t    private class TestResource {\n\t        //...\n\t    }\n\t}\n\t\n\t\n我们创建了一个静态的资源对象mResouce，每次Activity启动都会使用该资源的数据，避免了重复创建。但是这样会造成内存泄漏\n\n* 非静态内部类默认会持有外部类的引用\n* 又使用了该非静态内部类创建了一个静态的实例\n* 该静态实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。\n\n\n解决办法：\n\n* 将内部类testResource改成静态内部类\n* 将testResource抽取出来，封装成一个单例\n\n\n\t\tpublic class MainActivity extends AppCompatActivity {\n\t\t    private static TestResource mResource = null;\n\t\t    @Override\n\t\t    protected void onCreate(Bundle savedInstanceState) {\n\t\t        super.onCreate(savedInstanceState);\n\t\t        setContentView(R.layout.activity_main);\n\t\t        if(mManager == null){\n\t\t            mManager = new TestResource();\n\t\t        }\n\t\t        //...\n\t\t    }\n\t\t    private static class TestResource {\n\t\t        //...\n\t\t    }\n\t\t}\n\t\t\n\t\t\n##### 3. handler导致内存泄漏\n\n举例如下\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t    private Handler mHandler = new Handler() {\n\t        @Override\n\t        public void handleMessage(Message msg) {\n\t            //...\n\t        }\n\t    };\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        loadData();\n\t    }\n\t    private void loadData(){\n\t        //...request\n\t        Message message = Message.obtain();\n\t        mHandler.sendMessage(message);\n\t    }\n\t}\n\t\n由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏\n\n\n解决方案：\n\n * 在Activity onDestroy的时候，也应该对消息队列中的消息移除。\n\n\n\t\t @Override\n\t\tpublic void onDestroy() {\n\t\t   //三种均可\n\t\t    mHandler.removeMessages(message);\n\t\t    mHandler.removeCallbacks(Runnable);\n\t\t    mHandler.removeCallbacksAndMessages(null);\n\t\t}\n\t\t\n\t\t\n##### 4.资源未关闭导致内存泄漏\n\nBraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。","source":"_posts/Android常见内存泄漏及解决办法.md","raw":"---\ntitle: Android常见内存泄漏及解决办法\ndate: 2018-03-13 16:12:15\ntags: Android进阶\n---\n\n#### Why?\n\n当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。\n\n内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。\n\n\n#### How?\n\n主要几点：\n\n * Context\n * 内部类（handler等）\n * Cursor\n * Adapter\n * Bitmap\n\n##### 1. 单例造成的内存泄漏\n\n单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 \n\n例如：\n\n\tpublic class AppManager {\n\t    private static AppManager instance;\n\t    private Context context;\n\t    private AppManager(Context context) {\n\t        this.context = context;\n\t    }\n\t    public static AppManager getInstance(Context context) {\n\t        if (instance != null) {\n\t            instance = new AppManager(context);\n\t        }\n\t        return instance;\n\t    }\n\t}\n\t\n\t\n   * 传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 \n\n   \n   * 传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 \n\n   \n   \n 正确的单例：\n \n\t public class AppManager {\n\t    private static AppManager instance;\n\t    private Context context;\n\t    private AppManager(Context context) {\n\t        this.context = context.getApplicationContext();\n\t    }\n\t    public static AppManager getInstance(Context context) {\n\t        if (instance != null) {\n\t            instance = new AppManager(context);\n\t        }\n\t        return instance;\n\t    }\n\t}\n\t\n\t\n\t\n##### 2.非静态内部类创建静态实例造成的内存泄漏\n\n在实际的项目开发中，有时候我们需要频繁的启动某个页面（Activity），启动的时候总是需要初始化一些资源，为了避免重复创建相同资源，常常会使用静态对象去保存这些值，这种情况下，也很容易照成内存泄漏。我们举个例子：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t    private static TestResource mResource = null;\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        if(mManager == null){\n\t            mManager = new TestResource();\n\t        }\n\t        //...\n\t    }\n\t    private class TestResource {\n\t        //...\n\t    }\n\t}\n\t\n\t\n我们创建了一个静态的资源对象mResouce，每次Activity启动都会使用该资源的数据，避免了重复创建。但是这样会造成内存泄漏\n\n* 非静态内部类默认会持有外部类的引用\n* 又使用了该非静态内部类创建了一个静态的实例\n* 该静态实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。\n\n\n解决办法：\n\n* 将内部类testResource改成静态内部类\n* 将testResource抽取出来，封装成一个单例\n\n\n\t\tpublic class MainActivity extends AppCompatActivity {\n\t\t    private static TestResource mResource = null;\n\t\t    @Override\n\t\t    protected void onCreate(Bundle savedInstanceState) {\n\t\t        super.onCreate(savedInstanceState);\n\t\t        setContentView(R.layout.activity_main);\n\t\t        if(mManager == null){\n\t\t            mManager = new TestResource();\n\t\t        }\n\t\t        //...\n\t\t    }\n\t\t    private static class TestResource {\n\t\t        //...\n\t\t    }\n\t\t}\n\t\t\n\t\t\n##### 3. handler导致内存泄漏\n\n举例如下\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t    private Handler mHandler = new Handler() {\n\t        @Override\n\t        public void handleMessage(Message msg) {\n\t            //...\n\t        }\n\t    };\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        loadData();\n\t    }\n\t    private void loadData(){\n\t        //...request\n\t        Message message = Message.obtain();\n\t        mHandler.sendMessage(message);\n\t    }\n\t}\n\t\n由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏\n\n\n解决方案：\n\n * 在Activity onDestroy的时候，也应该对消息队列中的消息移除。\n\n\n\t\t @Override\n\t\tpublic void onDestroy() {\n\t\t   //三种均可\n\t\t    mHandler.removeMessages(message);\n\t\t    mHandler.removeCallbacks(Runnable);\n\t\t    mHandler.removeCallbacksAndMessages(null);\n\t\t}\n\t\t\n\t\t\n##### 4.资源未关闭导致内存泄漏\n\nBraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。","slug":"Android常见内存泄漏及解决办法","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tn8000nx3c070kxf5tp","content":"<h4 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why?\"></a>Why?</h4><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>\n<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>\n<h4 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How?\"></a>How?</h4><p>主要几点：</p>\n<ul>\n<li>Context</li>\n<li>内部类（handler等）</li>\n<li>Cursor</li>\n<li>Adapter</li>\n<li>Bitmap</li>\n</ul>\n<h5 id=\"1-单例造成的内存泄漏\"><a href=\"#1-单例造成的内存泄漏\" class=\"headerlink\" title=\"1. 单例造成的内存泄漏\"></a>1. 单例造成的内存泄漏</h5><p>单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 </p>\n<p>例如：</p>\n<pre><code>public class AppManager {\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context) {\n        this.context = context;\n    }\n    public static AppManager getInstance(Context context) {\n        if (instance != null) {\n            instance = new AppManager(context);\n        }\n        return instance;\n    }\n}\n</code></pre><ul>\n<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 </li>\n</ul>\n<ul>\n<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 </li>\n</ul>\n<p> 正确的单例：</p>\n<pre><code> public class AppManager {\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context) {\n        this.context = context.getApplicationContext();\n    }\n    public static AppManager getInstance(Context context) {\n        if (instance != null) {\n            instance = new AppManager(context);\n        }\n        return instance;\n    }\n}\n</code></pre><h5 id=\"2-非静态内部类创建静态实例造成的内存泄漏\"><a href=\"#2-非静态内部类创建静态实例造成的内存泄漏\" class=\"headerlink\" title=\"2.非静态内部类创建静态实例造成的内存泄漏\"></a>2.非静态内部类创建静态实例造成的内存泄漏</h5><p>在实际的项目开发中，有时候我们需要频繁的启动某个页面（Activity），启动的时候总是需要初始化一些资源，为了避免重复创建相同资源，常常会使用静态对象去保存这些值，这种情况下，也很容易照成内存泄漏。我们举个例子：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private static TestResource mResource = null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        if(mManager == null){\n            mManager = new TestResource();\n        }\n        //...\n    }\n    private class TestResource {\n        //...\n    }\n}\n</code></pre><p>我们创建了一个静态的资源对象mResouce，每次Activity启动都会使用该资源的数据，避免了重复创建。但是这样会造成内存泄漏</p>\n<ul>\n<li>非静态内部类默认会持有外部类的引用</li>\n<li>又使用了该非静态内部类创建了一个静态的实例</li>\n<li>该静态实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</li>\n</ul>\n<p>解决办法：</p>\n<ul>\n<li>将内部类testResource改成静态内部类</li>\n<li>将testResource抽取出来，封装成一个单例</li>\n</ul>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private static TestResource mResource = null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        if(mManager == null){\n            mManager = new TestResource();\n        }\n        //...\n    }\n    private static class TestResource {\n        //...\n    }\n}\n</code></pre><h5 id=\"3-handler导致内存泄漏\"><a href=\"#3-handler导致内存泄漏\" class=\"headerlink\" title=\"3. handler导致内存泄漏\"></a>3. handler导致内存泄漏</h5><p>举例如下</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            //...\n        }\n    };\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        loadData();\n    }\n    private void loadData(){\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n}\n</code></pre><p>由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏</p>\n<p>解决方案：</p>\n<ul>\n<li>在Activity onDestroy的时候，也应该对消息队列中的消息移除。</li>\n</ul>\n<pre><code> @Override\npublic void onDestroy() {\n   //三种均可\n    mHandler.removeMessages(message);\n    mHandler.removeCallbacks(Runnable);\n    mHandler.removeCallbacksAndMessages(null);\n}\n</code></pre><h5 id=\"4-资源未关闭导致内存泄漏\"><a href=\"#4-资源未关闭导致内存泄漏\" class=\"headerlink\" title=\"4.资源未关闭导致内存泄漏\"></a>4.资源未关闭导致内存泄漏</h5><p>BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why?\"></a>Why?</h4><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>\n<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>\n<h4 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How?\"></a>How?</h4><p>主要几点：</p>\n<ul>\n<li>Context</li>\n<li>内部类（handler等）</li>\n<li>Cursor</li>\n<li>Adapter</li>\n<li>Bitmap</li>\n</ul>\n<h5 id=\"1-单例造成的内存泄漏\"><a href=\"#1-单例造成的内存泄漏\" class=\"headerlink\" title=\"1. 单例造成的内存泄漏\"></a>1. 单例造成的内存泄漏</h5><p>单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 </p>\n<p>例如：</p>\n<pre><code>public class AppManager {\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context) {\n        this.context = context;\n    }\n    public static AppManager getInstance(Context context) {\n        if (instance != null) {\n            instance = new AppManager(context);\n        }\n        return instance;\n    }\n}\n</code></pre><ul>\n<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 </li>\n</ul>\n<ul>\n<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 </li>\n</ul>\n<p> 正确的单例：</p>\n<pre><code> public class AppManager {\n    private static AppManager instance;\n    private Context context;\n    private AppManager(Context context) {\n        this.context = context.getApplicationContext();\n    }\n    public static AppManager getInstance(Context context) {\n        if (instance != null) {\n            instance = new AppManager(context);\n        }\n        return instance;\n    }\n}\n</code></pre><h5 id=\"2-非静态内部类创建静态实例造成的内存泄漏\"><a href=\"#2-非静态内部类创建静态实例造成的内存泄漏\" class=\"headerlink\" title=\"2.非静态内部类创建静态实例造成的内存泄漏\"></a>2.非静态内部类创建静态实例造成的内存泄漏</h5><p>在实际的项目开发中，有时候我们需要频繁的启动某个页面（Activity），启动的时候总是需要初始化一些资源，为了避免重复创建相同资源，常常会使用静态对象去保存这些值，这种情况下，也很容易照成内存泄漏。我们举个例子：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private static TestResource mResource = null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        if(mManager == null){\n            mManager = new TestResource();\n        }\n        //...\n    }\n    private class TestResource {\n        //...\n    }\n}\n</code></pre><p>我们创建了一个静态的资源对象mResouce，每次Activity启动都会使用该资源的数据，避免了重复创建。但是这样会造成内存泄漏</p>\n<ul>\n<li>非静态内部类默认会持有外部类的引用</li>\n<li>又使用了该非静态内部类创建了一个静态的实例</li>\n<li>该静态实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</li>\n</ul>\n<p>解决办法：</p>\n<ul>\n<li>将内部类testResource改成静态内部类</li>\n<li>将testResource抽取出来，封装成一个单例</li>\n</ul>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private static TestResource mResource = null;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        if(mManager == null){\n            mManager = new TestResource();\n        }\n        //...\n    }\n    private static class TestResource {\n        //...\n    }\n}\n</code></pre><h5 id=\"3-handler导致内存泄漏\"><a href=\"#3-handler导致内存泄漏\" class=\"headerlink\" title=\"3. handler导致内存泄漏\"></a>3. handler导致内存泄漏</h5><p>举例如下</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private Handler mHandler = new Handler() {\n        @Override\n        public void handleMessage(Message msg) {\n            //...\n        }\n    };\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        loadData();\n    }\n    private void loadData(){\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n}\n</code></pre><p>由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏</p>\n<p>解决方案：</p>\n<ul>\n<li>在Activity onDestroy的时候，也应该对消息队列中的消息移除。</li>\n</ul>\n<pre><code> @Override\npublic void onDestroy() {\n   //三种均可\n    mHandler.removeMessages(message);\n    mHandler.removeCallbacks(Runnable);\n    mHandler.removeCallbacksAndMessages(null);\n}\n</code></pre><h5 id=\"4-资源未关闭导致内存泄漏\"><a href=\"#4-资源未关闭导致内存泄漏\" class=\"headerlink\" title=\"4.资源未关闭导致内存泄漏\"></a>4.资源未关闭导致内存泄漏</h5><p>BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>\n"},{"title":"Android过度绘制","date":"2018-07-27T03:17:23.000Z","_content":"\n#### 一、基础知识\n\nandroid 的渲染主要分为两个组件：1.CPU 2.GPU，由这两者共同完成在屏幕上绘制 。 \n\n* CPU：中央处理器,它集成了运算,缓冲,控制等单元,包括绘图功能.CPU将对象处理为多维图形,纹理(Bitmaps、Drawables等都是一起打包到统一的纹理)。 \n\n\n* GPU：一个类似于CPU的专门用来处理Graphics的处理器,用来帮助加快格栅化操作,当然,也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 \n\n* OpenGL ES：手持嵌入式设备的3DAPI,跨平台的、功能完善的2D和3D图形应用程序接口API,有一套固定渲染管线流程。 \n\n* DisplayList：把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 \n\n* 栅格化：将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上。 \n\n* 垂直同步VSYNC：让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前，要等待屏幕绘制完成前一帧。下面的三张图分别是GPU和硬件同步所发生的情况,Refresh Rate:屏幕一秒内刷新屏幕的次数,由硬件决定,例如60Hz.而Frame Rate:GPU一秒绘制操作的帧数,单位fps。\n#### 二、什么是过度绘制？\n\n过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源，绘制示意图如下图所示\n\n![overdraw](https://ws1.sinaimg.cn/large/005GVP9ggy1fxtli7690sj30ad0biab1.jpg)\n\n\n* 原色：没有过度绘制 \n\n* 蓝色：1 次过度绘制 \n\n* 绿色：2 次过度绘制 \n\n* 粉色：3 次过度绘制 \n\n* 红色：4 次及以上过度绘制\n\n\n#### 三、过度绘制优化\n\n##### 1. 去除Activity自带的默认window背景\n\n一般应用默认继承的主题都会有一个默认的 windowBackground ，比如默认的 Light 主题：\n\n\t<style name=\"Theme.Light\"> \n\t<item name=\"isLightTheme\">true</item> \n\t<item name=\"windowBackground\">@drawable/screen_background_selector_light</item>\n\t ...\n\t  </style>\n\t  \n但是一般界面都会自己设置界面的背景颜色或者列表页则由 item 的背景来决定，所以默认的 Window 背景基本用不上，如果不移除就会导致所有界面都多 1 次绘制。\n\n可以在应用的主题中添加如下的一行属性来移除默认的 Window 背景：\n\n\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n\t <!-- 或者 --> \n\t <item name=\"android:windowBackground\">@null</item>\n\t \n\t \n或者在 BaseActivity 的 onCreate() 方法中使用下面的代码移除：\n\n\t getWindow().setBackgroundDrawable(null); \n\t 或者\n\t getWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\n\n移除默认的 Window 背景的工作在项目初期做最好，因为有可能有的界面未设置背景色，这就会导致该界面显示成黑色的背景，如下所示，如果是后期移除的，就需要检查移除默认 Window 背景之后的界面是否显示正常。\n\n\n##### 2.移除不必要的背景\n\n还是上面的那个界面，因为移除了默认的 Window 背景，所以在布局中设置背景为白色：","source":"_posts/Android过度绘制.md","raw":"---\ntitle: Android过度绘制\ndate: 2018-07-27 11:17:23\ntags: [Android]\n---\n\n#### 一、基础知识\n\nandroid 的渲染主要分为两个组件：1.CPU 2.GPU，由这两者共同完成在屏幕上绘制 。 \n\n* CPU：中央处理器,它集成了运算,缓冲,控制等单元,包括绘图功能.CPU将对象处理为多维图形,纹理(Bitmaps、Drawables等都是一起打包到统一的纹理)。 \n\n\n* GPU：一个类似于CPU的专门用来处理Graphics的处理器,用来帮助加快格栅化操作,当然,也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 \n\n* OpenGL ES：手持嵌入式设备的3DAPI,跨平台的、功能完善的2D和3D图形应用程序接口API,有一套固定渲染管线流程。 \n\n* DisplayList：把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 \n\n* 栅格化：将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上。 \n\n* 垂直同步VSYNC：让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前，要等待屏幕绘制完成前一帧。下面的三张图分别是GPU和硬件同步所发生的情况,Refresh Rate:屏幕一秒内刷新屏幕的次数,由硬件决定,例如60Hz.而Frame Rate:GPU一秒绘制操作的帧数,单位fps。\n#### 二、什么是过度绘制？\n\n过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源，绘制示意图如下图所示\n\n![overdraw](https://ws1.sinaimg.cn/large/005GVP9ggy1fxtli7690sj30ad0biab1.jpg)\n\n\n* 原色：没有过度绘制 \n\n* 蓝色：1 次过度绘制 \n\n* 绿色：2 次过度绘制 \n\n* 粉色：3 次过度绘制 \n\n* 红色：4 次及以上过度绘制\n\n\n#### 三、过度绘制优化\n\n##### 1. 去除Activity自带的默认window背景\n\n一般应用默认继承的主题都会有一个默认的 windowBackground ，比如默认的 Light 主题：\n\n\t<style name=\"Theme.Light\"> \n\t<item name=\"isLightTheme\">true</item> \n\t<item name=\"windowBackground\">@drawable/screen_background_selector_light</item>\n\t ...\n\t  </style>\n\t  \n但是一般界面都会自己设置界面的背景颜色或者列表页则由 item 的背景来决定，所以默认的 Window 背景基本用不上，如果不移除就会导致所有界面都多 1 次绘制。\n\n可以在应用的主题中添加如下的一行属性来移除默认的 Window 背景：\n\n\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n\t <!-- 或者 --> \n\t <item name=\"android:windowBackground\">@null</item>\n\t \n\t \n或者在 BaseActivity 的 onCreate() 方法中使用下面的代码移除：\n\n\t getWindow().setBackgroundDrawable(null); \n\t 或者\n\t getWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\n\n移除默认的 Window 背景的工作在项目初期做最好，因为有可能有的界面未设置背景色，这就会导致该界面显示成黑色的背景，如下所示，如果是后期移除的，就需要检查移除默认 Window 背景之后的界面是否显示正常。\n\n\n##### 2.移除不必要的背景\n\n还是上面的那个界面，因为移除了默认的 Window 背景，所以在布局中设置背景为白色：","slug":"Android过度绘制","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tna000px3c0nbfqo9nu","content":"<h4 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h4><p>android 的渲染主要分为两个组件：1.CPU 2.GPU，由这两者共同完成在屏幕上绘制 。 </p>\n<ul>\n<li>CPU：中央处理器,它集成了运算,缓冲,控制等单元,包括绘图功能.CPU将对象处理为多维图形,纹理(Bitmaps、Drawables等都是一起打包到统一的纹理)。 </li>\n</ul>\n<ul>\n<li><p>GPU：一个类似于CPU的专门用来处理Graphics的处理器,用来帮助加快格栅化操作,当然,也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 </p>\n</li>\n<li><p>OpenGL ES：手持嵌入式设备的3DAPI,跨平台的、功能完善的2D和3D图形应用程序接口API,有一套固定渲染管线流程。 </p>\n</li>\n<li><p>DisplayList：把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 </p>\n</li>\n<li><p>栅格化：将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上。 </p>\n</li>\n<li><p>垂直同步VSYNC：让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前，要等待屏幕绘制完成前一帧。下面的三张图分别是GPU和硬件同步所发生的情况,Refresh Rate:屏幕一秒内刷新屏幕的次数,由硬件决定,例如60Hz.而Frame Rate:GPU一秒绘制操作的帧数,单位fps。</p>\n<h4 id=\"二、什么是过度绘制？\"><a href=\"#二、什么是过度绘制？\" class=\"headerlink\" title=\"二、什么是过度绘制？\"></a>二、什么是过度绘制？</h4></li>\n</ul>\n<p>过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源，绘制示意图如下图所示</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/005GVP9ggy1fxtli7690sj30ad0biab1.jpg\" alt=\"overdraw\"></p>\n<ul>\n<li><p>原色：没有过度绘制 </p>\n</li>\n<li><p>蓝色：1 次过度绘制 </p>\n</li>\n<li><p>绿色：2 次过度绘制 </p>\n</li>\n<li><p>粉色：3 次过度绘制 </p>\n</li>\n<li><p>红色：4 次及以上过度绘制</p>\n</li>\n</ul>\n<h4 id=\"三、过度绘制优化\"><a href=\"#三、过度绘制优化\" class=\"headerlink\" title=\"三、过度绘制优化\"></a>三、过度绘制优化</h4><h5 id=\"1-去除Activity自带的默认window背景\"><a href=\"#1-去除Activity自带的默认window背景\" class=\"headerlink\" title=\"1. 去除Activity自带的默认window背景\"></a>1. 去除Activity自带的默认window背景</h5><p>一般应用默认继承的主题都会有一个默认的 windowBackground ，比如默认的 Light 主题：</p>\n<pre><code>&lt;style name=&quot;Theme.Light&quot;&gt; \n&lt;item name=&quot;isLightTheme&quot;&gt;true&lt;/item&gt; \n&lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;\n ...\n  &lt;/style&gt;\n</code></pre><p>但是一般界面都会自己设置界面的背景颜色或者列表页则由 item 的背景来决定，所以默认的 Window 背景基本用不上，如果不移除就会导致所有界面都多 1 次绘制。</p>\n<p>可以在应用的主题中添加如下的一行属性来移除默认的 Window 背景：</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n &lt;!-- 或者 --&gt; \n &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n</code></pre><p>或者在 BaseActivity 的 onCreate() 方法中使用下面的代码移除：</p>\n<pre><code>getWindow().setBackgroundDrawable(null); \n或者\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n</code></pre><p>移除默认的 Window 背景的工作在项目初期做最好，因为有可能有的界面未设置背景色，这就会导致该界面显示成黑色的背景，如下所示，如果是后期移除的，就需要检查移除默认 Window 背景之后的界面是否显示正常。</p>\n<h5 id=\"2-移除不必要的背景\"><a href=\"#2-移除不必要的背景\" class=\"headerlink\" title=\"2.移除不必要的背景\"></a>2.移除不必要的背景</h5><p>还是上面的那个界面，因为移除了默认的 Window 背景，所以在布局中设置背景为白色：</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h4><p>android 的渲染主要分为两个组件：1.CPU 2.GPU，由这两者共同完成在屏幕上绘制 。 </p>\n<ul>\n<li>CPU：中央处理器,它集成了运算,缓冲,控制等单元,包括绘图功能.CPU将对象处理为多维图形,纹理(Bitmaps、Drawables等都是一起打包到统一的纹理)。 </li>\n</ul>\n<ul>\n<li><p>GPU：一个类似于CPU的专门用来处理Graphics的处理器,用来帮助加快格栅化操作,当然,也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 </p>\n</li>\n<li><p>OpenGL ES：手持嵌入式设备的3DAPI,跨平台的、功能完善的2D和3D图形应用程序接口API,有一套固定渲染管线流程。 </p>\n</li>\n<li><p>DisplayList：把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 </p>\n</li>\n<li><p>栅格化：将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上。 </p>\n</li>\n<li><p>垂直同步VSYNC：让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前，要等待屏幕绘制完成前一帧。下面的三张图分别是GPU和硬件同步所发生的情况,Refresh Rate:屏幕一秒内刷新屏幕的次数,由硬件决定,例如60Hz.而Frame Rate:GPU一秒绘制操作的帧数,单位fps。</p>\n<h4 id=\"二、什么是过度绘制？\"><a href=\"#二、什么是过度绘制？\" class=\"headerlink\" title=\"二、什么是过度绘制？\"></a>二、什么是过度绘制？</h4></li>\n</ul>\n<p>过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源，绘制示意图如下图所示</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/005GVP9ggy1fxtli7690sj30ad0biab1.jpg\" alt=\"overdraw\"></p>\n<ul>\n<li><p>原色：没有过度绘制 </p>\n</li>\n<li><p>蓝色：1 次过度绘制 </p>\n</li>\n<li><p>绿色：2 次过度绘制 </p>\n</li>\n<li><p>粉色：3 次过度绘制 </p>\n</li>\n<li><p>红色：4 次及以上过度绘制</p>\n</li>\n</ul>\n<h4 id=\"三、过度绘制优化\"><a href=\"#三、过度绘制优化\" class=\"headerlink\" title=\"三、过度绘制优化\"></a>三、过度绘制优化</h4><h5 id=\"1-去除Activity自带的默认window背景\"><a href=\"#1-去除Activity自带的默认window背景\" class=\"headerlink\" title=\"1. 去除Activity自带的默认window背景\"></a>1. 去除Activity自带的默认window背景</h5><p>一般应用默认继承的主题都会有一个默认的 windowBackground ，比如默认的 Light 主题：</p>\n<pre><code>&lt;style name=&quot;Theme.Light&quot;&gt; \n&lt;item name=&quot;isLightTheme&quot;&gt;true&lt;/item&gt; \n&lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;\n ...\n  &lt;/style&gt;\n</code></pre><p>但是一般界面都会自己设置界面的背景颜色或者列表页则由 item 的背景来决定，所以默认的 Window 背景基本用不上，如果不移除就会导致所有界面都多 1 次绘制。</p>\n<p>可以在应用的主题中添加如下的一行属性来移除默认的 Window 背景：</p>\n<pre><code>&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n &lt;!-- 或者 --&gt; \n &lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n</code></pre><p>或者在 BaseActivity 的 onCreate() 方法中使用下面的代码移除：</p>\n<pre><code>getWindow().setBackgroundDrawable(null); \n或者\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n</code></pre><p>移除默认的 Window 背景的工作在项目初期做最好，因为有可能有的界面未设置背景色，这就会导致该界面显示成黑色的背景，如下所示，如果是后期移除的，就需要检查移除默认 Window 背景之后的界面是否显示正常。</p>\n<h5 id=\"2-移除不必要的背景\"><a href=\"#2-移除不必要的背景\" class=\"headerlink\" title=\"2.移除不必要的背景\"></a>2.移除不必要的背景</h5><p>还是上面的那个界面，因为移除了默认的 Window 背景，所以在布局中设置背景为白色：</p>\n"},{"title":"Android性能优化（一）布局优化","date":"2018-04-13T06:57:40.000Z","_content":"\n布局优化主要的思想就一点：减少布局的层级\n\n常用的优化方式有三种：\n\n#### 一、&lt;include&gt;标签\n\n&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。\n\n举个例子：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:orientation=\"vertical\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\">\n\t\n\t    <include layout=\"@layout/include_comm_new_topbar_header\"/>\n\t\n\t    <android.support.v7.widget.RecyclerView\n\t        android:id=\"@+id/courier_recycle_change_record\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"match_parent\" />\n\t</LinearLayout>\n\t\n引用的部分，\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t\n\t<ComTopBarNew xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:id=\"@+id/toolBar\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"@dimen/com_toolbar_height\"\n\t    android:background=\"@color/comm_color18\"\n\t    />\n\t    \n需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。\n\n\n#### 二、&lt;merge&gt;标签\n\n&lt;merge\\>标签，一般是和<include>标签配合使用的，举个例子：\n\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<merge>\n\t\n\t    <View style=\"@style/Comm.Divider.Horizontal\" />\n\t</merge>\n\t\n\t\n使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。\n\n#### 三、 &lt;ViewStub&gt;标签\n\n&lt;ViewStub\\>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<ViewStub />标签以减少内存使用量，加快渲染速度。<ViewStub />标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。\n\n在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。\n\n举个例子：\n\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n\t    xmlns:tools=\"http://schemas.android.com/tools\"  \n\t    android:layout_width=\"match_parent\"  \n\t    android:layout_height=\"match_parent\"  \n\t    android:orientation=\"vertical\"  \n\t    tools:context=\".MainActivity\">  \n\t  \n\t    <Button  \n\t        android:id=\"@+id/btn_show\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:text=\"Show\"/>  \n\t    <Button  \n\t        android:id=\"@+id/btn_gone\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:text=\"GONE\"/>  \n\t  \n\t    <LinearLayout  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\">  \n\t    <ViewStub  \n\t        android:id=\"@+id/viewstub\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:layout=\"@layout/view\"/>  \n\t    </LinearLayout>  \n\t  \n\t</LinearLayout> \n\n在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。\n\n那么如何加载？\n\n两种方式：\n\n * stub.setVisibility(View.VISIBLE); \n\n * stub.inflate();","source":"_posts/Android性能优化（一）.md","raw":"---\ntitle: Android性能优化（一）布局优化\ndate: 2018-04-13 14:57:40\ntags: Android性能优化\n---\n\n布局优化主要的思想就一点：减少布局的层级\n\n常用的优化方式有三种：\n\n#### 一、&lt;include&gt;标签\n\n&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。\n\n举个例子：\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:orientation=\"vertical\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"match_parent\">\n\t\n\t    <include layout=\"@layout/include_comm_new_topbar_header\"/>\n\t\n\t    <android.support.v7.widget.RecyclerView\n\t        android:id=\"@+id/courier_recycle_change_record\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"match_parent\" />\n\t</LinearLayout>\n\t\n引用的部分，\n\t\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t\n\t<ComTopBarNew xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    android:id=\"@+id/toolBar\"\n\t    android:layout_width=\"match_parent\"\n\t    android:layout_height=\"@dimen/com_toolbar_height\"\n\t    android:background=\"@color/comm_color18\"\n\t    />\n\t    \n需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。\n\n\n#### 二、&lt;merge&gt;标签\n\n&lt;merge\\>标签，一般是和<include>标签配合使用的，举个例子：\n\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<merge>\n\t\n\t    <View style=\"@style/Comm.Divider.Horizontal\" />\n\t</merge>\n\t\n\t\n使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。\n\n#### 三、 &lt;ViewStub&gt;标签\n\n&lt;ViewStub\\>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<ViewStub />标签以减少内存使用量，加快渲染速度。<ViewStub />标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。\n\n在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。\n\n举个例子：\n\n\t<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"  \n\t    xmlns:tools=\"http://schemas.android.com/tools\"  \n\t    android:layout_width=\"match_parent\"  \n\t    android:layout_height=\"match_parent\"  \n\t    android:orientation=\"vertical\"  \n\t    tools:context=\".MainActivity\">  \n\t  \n\t    <Button  \n\t        android:id=\"@+id/btn_show\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:text=\"Show\"/>  \n\t    <Button  \n\t        android:id=\"@+id/btn_gone\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:text=\"GONE\"/>  \n\t  \n\t    <LinearLayout  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\">  \n\t    <ViewStub  \n\t        android:id=\"@+id/viewstub\"  \n\t        android:layout_width=\"wrap_content\"  \n\t        android:layout_height=\"wrap_content\"  \n\t        android:layout=\"@layout/view\"/>  \n\t    </LinearLayout>  \n\t  \n\t</LinearLayout> \n\n在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。\n\n那么如何加载？\n\n两种方式：\n\n * stub.setVisibility(View.VISIBLE); \n\n * stub.inflate();","slug":"Android性能优化（一）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnb000sx3c0fh0v5rvf","content":"<p>布局优化主要的思想就一点：减少布局的层级</p>\n<p>常用的优化方式有三种：</p>\n<h4 id=\"一、-lt-include-gt-标签\"><a href=\"#一、-lt-include-gt-标签\" class=\"headerlink\" title=\"一、&lt;include&gt;标签\"></a>一、&lt;include&gt;标签</h4><p>&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。</p>\n<p>举个例子：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:orientation=&quot;vertical&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;include layout=&quot;@layout/include_comm_new_topbar_header&quot;/&gt;\n\n    &lt;android.support.v7.widget.RecyclerView\n        android:id=&quot;@+id/courier_recycle_change_record&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/LinearLayout&gt;\n</code></pre><p>引用的部分，</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n\n&lt;ComTopBarNew xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:id=&quot;@+id/toolBar&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;@dimen/com_toolbar_height&quot;\n    android:background=&quot;@color/comm_color18&quot;\n    /&gt;\n</code></pre><p>需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。</p>\n<h4 id=\"二、-lt-merge-gt-标签\"><a href=\"#二、-lt-merge-gt-标签\" class=\"headerlink\" title=\"二、&lt;merge&gt;标签\"></a>二、&lt;merge&gt;标签</h4><p>&lt;merge>标签，一般是和<include>标签配合使用的，举个例子：</include></p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;merge&gt;\n\n    &lt;View style=&quot;@style/Comm.Divider.Horizontal&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p>使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。</merge></p>\n<h4 id=\"三、-lt-ViewStub-gt-标签\"><a href=\"#三、-lt-ViewStub-gt-标签\" class=\"headerlink\" title=\"三、 &lt;ViewStub&gt;标签\"></a>三、 &lt;ViewStub&gt;标签</h4><p>&lt;ViewStub>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<viewstub>标签以减少内存使用量，加快渲染速度。<viewstub>标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。</viewstub></viewstub></p>\n<p>在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。</p>\n<p>举个例子：</p>\n<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  \n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  \n    android:layout_width=&quot;match_parent&quot;  \n    android:layout_height=&quot;match_parent&quot;  \n    android:orientation=&quot;vertical&quot;  \n    tools:context=&quot;.MainActivity&quot;&gt;  \n\n    &lt;Button  \n        android:id=&quot;@+id/btn_show&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:text=&quot;Show&quot;/&gt;  \n    &lt;Button  \n        android:id=&quot;@+id/btn_gone&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:text=&quot;GONE&quot;/&gt;  \n\n    &lt;LinearLayout  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;&gt;  \n    &lt;ViewStub  \n        android:id=&quot;@+id/viewstub&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:layout=&quot;@layout/view&quot;/&gt;  \n    &lt;/LinearLayout&gt;  \n\n&lt;/LinearLayout&gt; \n</code></pre><p>在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>\n<p>那么如何加载？</p>\n<p>两种方式：</p>\n<ul>\n<li><p>stub.setVisibility(View.VISIBLE); </p>\n</li>\n<li><p>stub.inflate();</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>布局优化主要的思想就一点：减少布局的层级</p>\n<p>常用的优化方式有三种：</p>\n<h4 id=\"一、-lt-include-gt-标签\"><a href=\"#一、-lt-include-gt-标签\" class=\"headerlink\" title=\"一、&lt;include&gt;标签\"></a>一、&lt;include&gt;标签</h4><p>&lt;include&gt;标签可以将制定的布局加载到当前布局中。可以多处引用，类似于工具类的公共方法。</p>\n<p>举个例子：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:orientation=&quot;vertical&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;include layout=&quot;@layout/include_comm_new_topbar_header&quot;/&gt;\n\n    &lt;android.support.v7.widget.RecyclerView\n        android:id=&quot;@+id/courier_recycle_change_record&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n&lt;/LinearLayout&gt;\n</code></pre><p>引用的部分，</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n\n&lt;ComTopBarNew xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:id=&quot;@+id/toolBar&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;@dimen/com_toolbar_height&quot;\n    android:background=&quot;@color/comm_color18&quot;\n    /&gt;\n</code></pre><p>需要注意的是，include标签仅支持layout开头的属性；当在include的布局中指定了id,在当前的布局文件中也指定了id,那么是以include中指定的id为准的。</p>\n<h4 id=\"二、-lt-merge-gt-标签\"><a href=\"#二、-lt-merge-gt-标签\" class=\"headerlink\" title=\"二、&lt;merge&gt;标签\"></a>二、&lt;merge&gt;标签</h4><p>&lt;merge>标签，一般是和<include>标签配合使用的，举个例子：</include></p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;merge&gt;\n\n    &lt;View style=&quot;@style/Comm.Divider.Horizontal&quot; /&gt;\n&lt;/merge&gt;\n</code></pre><p>使用场景也很好理解，如果当前布局是LinearLayout，被包含的布局也是LinearLayout,那么就可以使用<merge>标签，这样做就减少了布局的层级了。</merge></p>\n<h4 id=\"三、-lt-ViewStub-gt-标签\"><a href=\"#三、-lt-ViewStub-gt-标签\" class=\"headerlink\" title=\"三、 &lt;ViewStub&gt;标签\"></a>三、 &lt;ViewStub&gt;标签</h4><p>&lt;ViewStub>标签，ViewStub继承自View,标签最大的特点就是当你需要的时候才会加载，但并不会影响UI初始化的性能。各种不常用的布局文件如进度条、显示错误信息等可以使用<viewstub>标签以减少内存使用量，加快渲染速度。<viewstub>标签是一个不可见的，大小为0的View。所以不会参与任何布局和绘制。</viewstub></viewstub></p>\n<p>在需要使用的时候再去加载显示，这样就提高了程序初始的性能了。</p>\n<p>举个例子：</p>\n<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  \n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  \n    android:layout_width=&quot;match_parent&quot;  \n    android:layout_height=&quot;match_parent&quot;  \n    android:orientation=&quot;vertical&quot;  \n    tools:context=&quot;.MainActivity&quot;&gt;  \n\n    &lt;Button  \n        android:id=&quot;@+id/btn_show&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:text=&quot;Show&quot;/&gt;  \n    &lt;Button  \n        android:id=&quot;@+id/btn_gone&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:text=&quot;GONE&quot;/&gt;  \n\n    &lt;LinearLayout  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;&gt;  \n    &lt;ViewStub  \n        android:id=&quot;@+id/viewstub&quot;  \n        android:layout_width=&quot;wrap_content&quot;  \n        android:layout_height=&quot;wrap_content&quot;  \n        android:layout=&quot;@layout/view&quot;/&gt;  \n    &lt;/LinearLayout&gt;  \n\n&lt;/LinearLayout&gt; \n</code></pre><p>在需要展示的时候，在设置显示出来，即按需加载。ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>\n<p>那么如何加载？</p>\n<p>两种方式：</p>\n<ul>\n<li><p>stub.setVisibility(View.VISIBLE); </p>\n</li>\n<li><p>stub.inflate();</p>\n</li>\n</ul>\n"},{"title":"Bitmap OOM解决方案","date":"2018-04-11T10:11:28.000Z","_content":"\n### Bitmap OOM常用解决方案\n---\n\n1. 在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。\n\n2. 在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。\n\n3. 通过设置Options.inPreferredConfig值来降低内存消耗：\n     默认为ARGB_8888: 每个像素4字节. 共32位。\n     Alpha_8: 只保存透明度，共8位，1字节。\n     ARGB_4444: 共16位，2字节。\n     RGB_565:共16位，2字节。\n     如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。\n     \n4. 通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。\n\n5. 设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。\n \t* inPurgeable:\n \t\t* 设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。\n \t\t* 设置为False时，表示不能被回收。\n   \t\t\n \t* inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为\n \t\t* false，该参数无意义；\n \t\t* True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。\n \t\t                               \n6. 使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。\n     \n     \n区别： \ndecodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。\n\ndecodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。\n\n       decodeStream调用过程：\n             decodeStream(InputStream,Rect,Options) -> nativeDecodeAsset/nativeDecodeStream\n       decodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。\n             decodeResource(Resource,resId,Options)  -> decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -> decodeStream() (在完成Decode后，进行finishDecode操作)\n             finishDecode() -> Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -> Bitmap.createBitmap()\n\n以上方法的组合使用，合理避免OOM错误。\n","source":"_posts/Bitmap-OOM解决方案.md","raw":"---\ntitle: Bitmap OOM解决方案\ndate: 2018-04-11 18:11:28\ntags: [内存优化]\n---\n\n### Bitmap OOM常用解决方案\n---\n\n1. 在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。\n\n2. 在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。\n\n3. 通过设置Options.inPreferredConfig值来降低内存消耗：\n     默认为ARGB_8888: 每个像素4字节. 共32位。\n     Alpha_8: 只保存透明度，共8位，1字节。\n     ARGB_4444: 共16位，2字节。\n     RGB_565:共16位，2字节。\n     如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。\n     \n4. 通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。\n\n5. 设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。\n \t* inPurgeable:\n \t\t* 设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。\n \t\t* 设置为False时，表示不能被回收。\n   \t\t\n \t* inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为\n \t\t* false，该参数无意义；\n \t\t* True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。\n \t\t                               \n6. 使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。\n     \n     \n区别： \ndecodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。\n\ndecodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。\n\n       decodeStream调用过程：\n             decodeStream(InputStream,Rect,Options) -> nativeDecodeAsset/nativeDecodeStream\n       decodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。\n             decodeResource(Resource,resId,Options)  -> decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -> decodeStream() (在完成Decode后，进行finishDecode操作)\n             finishDecode() -> Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -> Bitmap.createBitmap()\n\n以上方法的组合使用，合理避免OOM错误。\n","slug":"Bitmap-OOM解决方案","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnc000ux3c0hdks7cue","content":"<h3 id=\"Bitmap-OOM常用解决方案\"><a href=\"#Bitmap-OOM常用解决方案\" class=\"headerlink\" title=\"Bitmap OOM常用解决方案\"></a>Bitmap OOM常用解决方案</h3><hr>\n<ol>\n<li><p>在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。</p>\n</li>\n<li><p>在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。</p>\n</li>\n<li><p>通过设置Options.inPreferredConfig值来降低内存消耗：<br>  默认为ARGB_8888: 每个像素4字节. 共32位。<br>  Alpha_8: 只保存透明度，共8位，1字节。<br>  ARGB_4444: 共16位，2字节。<br>  RGB_565:共16位，2字节。<br>  如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。</p>\n</li>\n<li><p>通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。</p>\n</li>\n<li><p>设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。</p>\n<ul>\n<li><p>inPurgeable:</p>\n<ul>\n<li>设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。</li>\n<li>设置为False时，表示不能被回收。</li>\n</ul>\n</li>\n<li><p>inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为</p>\n<ul>\n<li>false，该参数无意义；</li>\n<li>True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。</p>\n</li>\n</ol>\n<p>区别：<br>decodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。</p>\n<p>decodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。</p>\n<pre><code>decodeStream调用过程：\n      decodeStream(InputStream,Rect,Options) -&gt; nativeDecodeAsset/nativeDecodeStream\ndecodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。\n      decodeResource(Resource,resId,Options)  -&gt; decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -&gt; decodeStream() (在完成Decode后，进行finishDecode操作)\n      finishDecode() -&gt; Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -&gt; Bitmap.createBitmap()\n</code></pre><p>以上方法的组合使用，合理避免OOM错误。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Bitmap-OOM常用解决方案\"><a href=\"#Bitmap-OOM常用解决方案\" class=\"headerlink\" title=\"Bitmap OOM常用解决方案\"></a>Bitmap OOM常用解决方案</h3><hr>\n<ol>\n<li><p>在Android 2.3.3以及之前，建议使用Bitmap.recycle()方法，及时释放资源。</p>\n</li>\n<li><p>在Android 3.0开始，可设置BitmapFactory.options.inBitmap值，(从缓存中获取)达到重用Bitmap的目的。如果设置，则inPreferredConfig属性值会被重用的Bitmap该属性值覆盖。</p>\n</li>\n<li><p>通过设置Options.inPreferredConfig值来降低内存消耗：<br>  默认为ARGB_8888: 每个像素4字节. 共32位。<br>  Alpha_8: 只保存透明度，共8位，1字节。<br>  ARGB_4444: 共16位，2字节。<br>  RGB_565:共16位，2字节。<br>  如果不需要透明度，可把默认值ARGB_8888改为RGB_565,节约一半内存。</p>\n</li>\n<li><p>通过设置Options.inSampleSize 对大图片进行压缩，可先设置Options.inJustDecodeBounds，获取Bitmap的外围数据，宽和高等。然后计算压缩比例，进行压缩。</p>\n</li>\n<li><p>设置Options.inPurgeable和inInputShareable：让系统能及时回收内存。</p>\n<ul>\n<li><p>inPurgeable:</p>\n<ul>\n<li>设置为True,则使用BitmapFactory创建的Bitmap用于存储Pixel的内存空间，在系统内存不足时可以被回收，当应用需要再次访问该Bitmap的Pixel时，系统会再次调用BitmapFactory 的decode方法重新生成Bitmap的Pixel数组。</li>\n<li>设置为False时，表示不能被回收。</li>\n</ul>\n</li>\n<li><p>inInputShareable：设置是否深拷贝，与inPurgeable结合使用，inPurgeable为</p>\n<ul>\n<li>false，该参数无意义；</li>\n<li>True,share  a reference to the input data(inputStream, array,etc) 。 False ：a deep copy。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用decodeStream代替其他decodeResource,setImageResource,setImageBitmap等方法来加载图片。</p>\n</li>\n</ol>\n<p>区别：<br>decodeStream直接读取图片字节码，调用nativeDecodeAsset/nativeDecodeStream来完成decode。无需使用Java空间的一些额外处理过程，节省dalvik内存。但是由于直接读取字节码，没有处理过程，因此不会根据机器的各种分辨率来自动适应，需要在hdpi,mdpi和ldpi中分别配置相应的图片资源，否则在不同分辨率机器上都是同样的大小(像素点数量)，显示的实际大小不对。</p>\n<p>decodeResource会在读取完图片数据后，根据机器的分辨率，进行图片的适配处理，导致增大了很多dalvik内存消耗。</p>\n<pre><code>decodeStream调用过程：\n      decodeStream(InputStream,Rect,Options) -&gt; nativeDecodeAsset/nativeDecodeStream\ndecodeResource调用过程：即finishDecode之后，调用额外的Java层的createBitmap方法，消耗更多dalvik内存。\n      decodeResource(Resource,resId,Options)  -&gt; decodeResourceStream (设置Options的inDensity和inTargetDensity参数)  -&gt; decodeStream() (在完成Decode后，进行finishDecode操作)\n      finishDecode() -&gt; Bitmap.createScaleBitmap()(根据inDensity和inTargetDensity计算scale) -&gt; Bitmap.createBitmap()\n</code></pre><p>以上方法的组合使用，合理避免OOM错误。</p>\n"},{"title":"Bugsnag:监控应用程序错误，以改善客户体验和代码质量","date":"2017-07-14T02:48:23.000Z","_content":"\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","source":"_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","raw":"---\ntitle: 'Bugsnag:监控应用程序错误，以改善客户体验和代码质量'\ndate: 2017-07-14 10:48:23\ntags: [Bugsnag,Android]\n---\n\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","slug":"Bugsnag-监控应用程序错误，以改善客户体验和代码质量","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnc000wx3c0gwp6llwb","content":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n"},{"title":"Hexo+Github搭建个人博客（3）","date":"2016-09-15T09:03:56.000Z","_content":"\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","source":"_posts/Github-hexo搭建个人博客（3）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（3）\ndate: 2016-09-15 17:03:56\ntags: [hexo,github]\n---\n\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","slug":"Github-hexo搭建个人博客（3）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnd000zx3c02icxe0oe","content":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n"},{"title":"Git提交index.lock问题解决","date":"2016-09-12T11:07:26.000Z","_content":"\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","source":"_posts/Git提交index.lock问题解决.md","raw":"---\ntitle: Git提交index.lock问题解决\ndate: 2016-09-12 19:07:26\ntags:\n---\n\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","slug":"Git提交index.lock问题解决","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tne0011x3c0q793nxar","content":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n"},{"title":"Glide4.x源码解析(1)-基本使用","date":"2017-12-11T08:41:28.000Z","_content":"\n### 一、关于Glide\n\n* 官方定义：\n\n\t* Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。\n\n   * Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。\n\n\t* 虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。\n\n\t\n* 性能\n\n\t两个关键点：\n\t* 图片的解码速度\n\t\n\t* 解码图片带来的资源压力也就是内存消耗\n\n\tGlide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：\n\t\n\t* 自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；\n\t* 积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；\n\t* 深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。\n\t\n\n### 二、使用配置\n\n#### 1.依赖\n\n##### Gradle\n使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖\n\n\trepositories {\n\t  mavenCentral()\n\t  maven { url 'https://maven.google.com' }\n\t}\n\t\n\tdependencies {\n\t    compile 'com.github.bumptech.glide:glide:4.4.0'\n\t    annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'\n\t}\n\n##### Maven\n\n使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖\n\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>glide</artifactId>\n\t  <version>4.4.0</version>\n\t  <type>aar</type>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.google.android</groupId>\n\t  <artifactId>support-v4</artifactId>\n\t  <version>r7</version>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>compiler</artifactId>\n\t  <version>4.4.0</version>\n\t  <optional>true</optional>\n\t</dependency>\n\n#### 2.相关设置\n\n##### 权限\n\n* 网络\n\n当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。\n\n\t<uses-permission android:name=\"android.permission.INTERNET\"/>\n\n* 连接状态\n\n如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。\n\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n\t\n* 本地存储\n\n要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。\n\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\t\n### 三、基本使用\n\nGlide的基本使用很简单：\n\t\n\tGlide.with(fragment)\n\t    .load(myUrl)\n\t    .into(imageView);\n\t    \n一行就可以搞定从网络加载图片，丝柔顺滑。\n\n具体实现：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t\n\t    Button mBtn;\n\t    ImageView imageView;\n\t    String myUrl = \"http://ot29getcp.bkt.clouddn.com/map.png\";\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        mBtn = (Button)findViewById(R.id.downloadimage);\n\t        imageView = (ImageView) findViewById(R.id.image);\n\t        mBtn.setOnClickListener(new View.OnClickListener() {\n\t            @Override\n\t            public void onClick(View v) {\n\t                Glide.with(getApplicationContext())\n\t                        .load(myUrl)\n\t                        .into(imageView);\n\t            }\n\t        });\n\t\n\t    }\n\t}\n\t\n核心代码：\n\n就这一行。\n\n\tGlide.with(getApplicationContext())\n\t\t                        .load(myUrl)\n\t\t                        .into(imageView);\n\n\n\n","source":"_posts/Glide4.x源码解析(1)-基本使用.md","raw":"---\ntitle: Glide4.x源码解析(1)-基本使用\ndate: 2017-12-11 16:41:28\ntags: [Glide]\n---\n\n### 一、关于Glide\n\n* 官方定义：\n\n\t* Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。\n\n   * Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。\n\n\t* 虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。\n\n\t\n* 性能\n\n\t两个关键点：\n\t* 图片的解码速度\n\t\n\t* 解码图片带来的资源压力也就是内存消耗\n\n\tGlide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：\n\t\n\t* 自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；\n\t* 积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；\n\t* 深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。\n\t\n\n### 二、使用配置\n\n#### 1.依赖\n\n##### Gradle\n使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖\n\n\trepositories {\n\t  mavenCentral()\n\t  maven { url 'https://maven.google.com' }\n\t}\n\t\n\tdependencies {\n\t    compile 'com.github.bumptech.glide:glide:4.4.0'\n\t    annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'\n\t}\n\n##### Maven\n\n使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖\n\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>glide</artifactId>\n\t  <version>4.4.0</version>\n\t  <type>aar</type>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.google.android</groupId>\n\t  <artifactId>support-v4</artifactId>\n\t  <version>r7</version>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>compiler</artifactId>\n\t  <version>4.4.0</version>\n\t  <optional>true</optional>\n\t</dependency>\n\n#### 2.相关设置\n\n##### 权限\n\n* 网络\n\n当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。\n\n\t<uses-permission android:name=\"android.permission.INTERNET\"/>\n\n* 连接状态\n\n如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。\n\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n\t\n* 本地存储\n\n要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。\n\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\t\n### 三、基本使用\n\nGlide的基本使用很简单：\n\t\n\tGlide.with(fragment)\n\t    .load(myUrl)\n\t    .into(imageView);\n\t    \n一行就可以搞定从网络加载图片，丝柔顺滑。\n\n具体实现：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t\n\t    Button mBtn;\n\t    ImageView imageView;\n\t    String myUrl = \"http://ot29getcp.bkt.clouddn.com/map.png\";\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        mBtn = (Button)findViewById(R.id.downloadimage);\n\t        imageView = (ImageView) findViewById(R.id.image);\n\t        mBtn.setOnClickListener(new View.OnClickListener() {\n\t            @Override\n\t            public void onClick(View v) {\n\t                Glide.with(getApplicationContext())\n\t                        .load(myUrl)\n\t                        .into(imageView);\n\t            }\n\t        });\n\t\n\t    }\n\t}\n\t\n核心代码：\n\n就这一行。\n\n\tGlide.with(getApplicationContext())\n\t\t                        .load(myUrl)\n\t\t                        .into(imageView);\n\n\n\n","slug":"Glide4.x源码解析(1)-基本使用","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnf0013x3c0jovsfpg3","content":"<h3 id=\"一、关于Glide\"><a href=\"#一、关于Glide\" class=\"headerlink\" title=\"一、关于Glide\"></a>一、关于Glide</h3><ul>\n<li><p>官方定义：</p>\n<ul>\n<li><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>\n<ul>\n<li>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</li>\n</ul>\n</li>\n<li><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>性能</p>\n<p>  两个关键点：</p>\n<ul>\n<li><p>图片的解码速度</p>\n</li>\n<li><p>解码图片带来的资源压力也就是内存消耗</p>\n<p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>\n</li>\n<li><p>自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；</p>\n</li>\n<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>\n<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、使用配置\"><a href=\"#二、使用配置\" class=\"headerlink\" title=\"二、使用配置\"></a>二、使用配置</h3><h4 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h4><h5 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h5><p>使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖</p>\n<pre><code>repositories {\n  mavenCentral()\n  maven { url &apos;https://maven.google.com&apos; }\n}\n\ndependencies {\n    compile &apos;com.github.bumptech.glide:glide:4.4.0&apos;\n    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.4.0&apos;\n}\n</code></pre><h5 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h5><p>使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;glide&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;type&gt;aar&lt;/type&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.google.android&lt;/groupId&gt;\n  &lt;artifactId&gt;support-v4&lt;/artifactId&gt;\n  &lt;version&gt;r7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;compiler&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"2-相关设置\"><a href=\"#2-相关设置\" class=\"headerlink\" title=\"2.相关设置\"></a>2.相关设置</h4><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h5><ul>\n<li>网络</li>\n</ul>\n<p>当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n</code></pre><ul>\n<li>连接状态</li>\n</ul>\n<p>如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n</code></pre><ul>\n<li>本地存储</li>\n</ul>\n<p>要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n</code></pre><h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>Glide的基本使用很简单：</p>\n<pre><code>Glide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n</code></pre><p>一行就可以搞定从网络加载图片，丝柔顺滑。</p>\n<p>具体实现：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    Button mBtn;\n    ImageView imageView;\n    String myUrl = &quot;http://ot29getcp.bkt.clouddn.com/map.png&quot;;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button)findViewById(R.id.downloadimage);\n        imageView = (ImageView) findViewById(R.id.image);\n        mBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Glide.with(getApplicationContext())\n                        .load(myUrl)\n                        .into(imageView);\n            }\n        });\n\n    }\n}\n</code></pre><p>核心代码：</p>\n<p>就这一行。</p>\n<pre><code>Glide.with(getApplicationContext())\n                            .load(myUrl)\n                            .into(imageView);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、关于Glide\"><a href=\"#一、关于Glide\" class=\"headerlink\" title=\"一、关于Glide\"></a>一、关于Glide</h3><ul>\n<li><p>官方定义：</p>\n<ul>\n<li><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>\n<ul>\n<li>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</li>\n</ul>\n</li>\n<li><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>性能</p>\n<p>  两个关键点：</p>\n<ul>\n<li><p>图片的解码速度</p>\n</li>\n<li><p>解码图片带来的资源压力也就是内存消耗</p>\n<p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>\n</li>\n<li><p>自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；</p>\n</li>\n<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>\n<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、使用配置\"><a href=\"#二、使用配置\" class=\"headerlink\" title=\"二、使用配置\"></a>二、使用配置</h3><h4 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h4><h5 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h5><p>使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖</p>\n<pre><code>repositories {\n  mavenCentral()\n  maven { url &apos;https://maven.google.com&apos; }\n}\n\ndependencies {\n    compile &apos;com.github.bumptech.glide:glide:4.4.0&apos;\n    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.4.0&apos;\n}\n</code></pre><h5 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h5><p>使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;glide&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;type&gt;aar&lt;/type&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.google.android&lt;/groupId&gt;\n  &lt;artifactId&gt;support-v4&lt;/artifactId&gt;\n  &lt;version&gt;r7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;compiler&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"2-相关设置\"><a href=\"#2-相关设置\" class=\"headerlink\" title=\"2.相关设置\"></a>2.相关设置</h4><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h5><ul>\n<li>网络</li>\n</ul>\n<p>当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n</code></pre><ul>\n<li>连接状态</li>\n</ul>\n<p>如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n</code></pre><ul>\n<li>本地存储</li>\n</ul>\n<p>要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n</code></pre><h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>Glide的基本使用很简单：</p>\n<pre><code>Glide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n</code></pre><p>一行就可以搞定从网络加载图片，丝柔顺滑。</p>\n<p>具体实现：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    Button mBtn;\n    ImageView imageView;\n    String myUrl = &quot;http://ot29getcp.bkt.clouddn.com/map.png&quot;;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button)findViewById(R.id.downloadimage);\n        imageView = (ImageView) findViewById(R.id.image);\n        mBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Glide.with(getApplicationContext())\n                        .load(myUrl)\n                        .into(imageView);\n            }\n        });\n\n    }\n}\n</code></pre><p>核心代码：</p>\n<p>就这一行。</p>\n<pre><code>Glide.with(getApplicationContext())\n                            .load(myUrl)\n                            .into(imageView);\n</code></pre>"},{"title":"HTTP需要知道的知识点-补充","date":"2016-11-19T11:33:52.000Z","_content":"\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","source":"_posts/HTTP需要知道的知识点-补充.md","raw":"---\ntitle: HTTP需要知道的知识点-补充\ndate: 2016-11-19 19:33:52\ntags: [HTTP]\n---\n\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","slug":"HTTP需要知道的知识点-补充","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tng0015x3c0txd1o4dz","content":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo+Github搭建个人博客(1)","date":"2016-09-10T13:02:08.000Z","_content":"\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","source":"_posts/Hexo+Github搭建个人博客（1）.md","raw":"---\ntitle: Hexo+Github搭建个人博客(1)\ndate: 2016-09-10 21:02:08\ntags: [hexo,github]\n---\n\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","slug":"Hexo+Github搭建个人博客（1）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnh0017x3c0rxt000xf","content":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n"},{"title":"HashMap的实现原理","date":"2018-03-20T07:59:34.000Z","_content":"\n\n### HashMap实现原理\n\n#### HashMap简介\n\nHashMap 是一个散列表，允许使用空值和空键。存储的内容是键值对(key-value)映射\n\nHashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。\n\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。\n通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n#### HashMap的数据结构\n\n在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n\nHashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。\n\n\n继承关系：\n\n\tjava.lang.Object\n\t   ↳     java.util.AbstractMap<K, V>\n\t         ↳     java.util.HashMap<K, V>\n\t\n\tpublic class HashMap<K,V>\n\t    extends AbstractMap<K,V>\n\t    implements Map<K,V>, Cloneable, Serializable { }\n    \n#### HashMap的构造函数\n\n\t// 默认构造函数。\n\tHashMap()\n\t\n\t// 指定“容量大小”的构造函数\n\tHashMap(int capacity)\n\t\n\t// 指定“容量大小”和“加载因子”的构造函数\n\tHashMap(int capacity, float loadFactor)\n\t\n\t// 包含“子Map”的构造函数\n\tHashMap(Map<? extends K, ? extends V> map)\n\t\n\t\n\t\n#### HashMap的整体结构\n\n![HashMap整体结构](http://ot29getcp.bkt.clouddn.com//blog/hashmapbuild.png)","source":"_posts/HashMap的实现原理.md","raw":"---\ntitle: HashMap的实现原理\ndate: 2018-03-20 15:59:34\ntags: [数据结构]\n---\n\n\n### HashMap实现原理\n\n#### HashMap简介\n\nHashMap 是一个散列表，允许使用空值和空键。存储的内容是键值对(key-value)映射\n\nHashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。\n\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。\n通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n#### HashMap的数据结构\n\n在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n\nHashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。\n\n\n继承关系：\n\n\tjava.lang.Object\n\t   ↳     java.util.AbstractMap<K, V>\n\t         ↳     java.util.HashMap<K, V>\n\t\n\tpublic class HashMap<K,V>\n\t    extends AbstractMap<K,V>\n\t    implements Map<K,V>, Cloneable, Serializable { }\n    \n#### HashMap的构造函数\n\n\t// 默认构造函数。\n\tHashMap()\n\t\n\t// 指定“容量大小”的构造函数\n\tHashMap(int capacity)\n\t\n\t// 指定“容量大小”和“加载因子”的构造函数\n\tHashMap(int capacity, float loadFactor)\n\t\n\t// 包含“子Map”的构造函数\n\tHashMap(Map<? extends K, ? extends V> map)\n\t\n\t\n\t\n#### HashMap的整体结构\n\n![HashMap整体结构](http://ot29getcp.bkt.clouddn.com//blog/hashmapbuild.png)","slug":"HashMap的实现原理","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnh0019x3c0uassp98w","content":"<h3 id=\"HashMap实现原理\"><a href=\"#HashMap实现原理\" class=\"headerlink\" title=\"HashMap实现原理\"></a>HashMap实现原理</h3><h4 id=\"HashMap简介\"><a href=\"#HashMap简介\" class=\"headerlink\" title=\"HashMap简介\"></a>HashMap简介</h4><p>HashMap 是一个散列表，允许使用空值和空键。存储的内容是键值对(key-value)映射</p>\n<p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>\n<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p>\n<p>继承关系：</p>\n<pre><code>java.lang.Object\n   ↳     java.util.AbstractMap&lt;K, V&gt;\n         ↳     java.util.HashMap&lt;K, V&gt;\n\npublic class HashMap&lt;K,V&gt;\n    extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable { }\n</code></pre><h4 id=\"HashMap的构造函数\"><a href=\"#HashMap的构造函数\" class=\"headerlink\" title=\"HashMap的构造函数\"></a>HashMap的构造函数</h4><pre><code>// 默认构造函数。\nHashMap()\n\n// 指定“容量大小”的构造函数\nHashMap(int capacity)\n\n// 指定“容量大小”和“加载因子”的构造函数\nHashMap(int capacity, float loadFactor)\n\n// 包含“子Map”的构造函数\nHashMap(Map&lt;? extends K, ? extends V&gt; map)\n</code></pre><h4 id=\"HashMap的整体结构\"><a href=\"#HashMap的整体结构\" class=\"headerlink\" title=\"HashMap的整体结构\"></a>HashMap的整体结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/hashmapbuild.png\" alt=\"HashMap整体结构\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"HashMap实现原理\"><a href=\"#HashMap实现原理\" class=\"headerlink\" title=\"HashMap实现原理\"></a>HashMap实现原理</h3><h4 id=\"HashMap简介\"><a href=\"#HashMap简介\" class=\"headerlink\" title=\"HashMap简介\"></a>HashMap简介</h4><p>HashMap 是一个散列表，允许使用空值和空键。存储的内容是键值对(key-value)映射</p>\n<p>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>\n<p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是指针（引用），HashMap 就是通过这两个数据结构进行实现。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>HashMap 底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个 HashMap 的时候，就会初始化一个数组。</p>\n<p>继承关系：</p>\n<pre><code>java.lang.Object\n   ↳     java.util.AbstractMap&lt;K, V&gt;\n         ↳     java.util.HashMap&lt;K, V&gt;\n\npublic class HashMap&lt;K,V&gt;\n    extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable { }\n</code></pre><h4 id=\"HashMap的构造函数\"><a href=\"#HashMap的构造函数\" class=\"headerlink\" title=\"HashMap的构造函数\"></a>HashMap的构造函数</h4><pre><code>// 默认构造函数。\nHashMap()\n\n// 指定“容量大小”的构造函数\nHashMap(int capacity)\n\n// 指定“容量大小”和“加载因子”的构造函数\nHashMap(int capacity, float loadFactor)\n\n// 包含“子Map”的构造函数\nHashMap(Map&lt;? extends K, ? extends V&gt; map)\n</code></pre><h4 id=\"HashMap的整体结构\"><a href=\"#HashMap的整体结构\" class=\"headerlink\" title=\"HashMap的整体结构\"></a>HashMap的整体结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/hashmapbuild.png\" alt=\"HashMap整体结构\"></p>\n"},{"title":"Hexo+Github搭建个人博客（2）","date":"2016-09-14T06:01:42.000Z","_content":"\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","source":"_posts/Hexo-Github搭建个人博客（2）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（2）\ndate: 2016-09-14 14:01:42\ntags: [hexo,github]\n---\n\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","slug":"Hexo-Github搭建个人博客（2）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnj001bx3c0wrrx8x48","content":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>"},{"title":"Hexo+Github搭建个人博客（4）","date":"2016-09-24T09:28:09.000Z","_content":"\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","source":"_posts/Hexo-Github搭建个人博客（4）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（4）\ndate: 2016-09-24 17:28:09\ntags: [hexo,github]\n---\n\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","slug":"Hexo-Github搭建个人博客（4）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnj001dx3c010uavvm3","content":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n"},{"title":"IPC基础概念介绍","date":"2018-03-22T01:09:50.000Z","_content":"\n## IPC基础概念介绍\n\n#### 一、简介\n\n* IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。\n\n* 线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。\n\n\n#### 二、Android中的多进程模式\n\n Android中开启多进程的方法：\n \n\t <activity android:name=\".BinderOneActivity\"\n\t            android:process=\"com.neil.binder.one\"/>\n\t <activity android:name=\".BinderTwoActivity\"\n\t            android:process=\"com.neil.binder.two\"/>\n\t <activity android:name=\".BinderThreeActivity\"\n\t            android:process=\"com.neil.binder.three\"/>\n\t            \n在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。\n\n日志输出：\n\n\tu0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo\n\tu0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one\n\tu0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two\n\tu0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three\n\nAndroid系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。\n\n\n\t            \n#### 三、序列化和反序列化\n\n1. 序列化\n\n由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。\n\n指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程\n\n2. 反序列化\n\n反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。\n\n  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。\n  \n  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n  \n#### 四、Serializable VS  Parcelable\n\n##### 1. Serializable\n\nSerializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。\n\n举个例子：\n\n\timport java.io.Serializable;\n\t\n\tpublic class Person implements Serializable {\n\t\n\t\t**\n\t     * 生成序列号标识\n\t     */\n\t    private static final long serialVersionUID = -2083503801443301445L;\n\t    \n\t    private String firstName;\n\t    private String lastName;\n\t    private int age;\n\t\n\t\n\t    public Person(String firstName, String lastName, int age) {\n\t        this.firstName = firstName;\n\t        this.lastName = lastName;\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    public String getFirstName() {\n\t        return firstName;\n\t    }\n\t\n\t    public void setFirstName(String firstName) {\n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public String getLastName() {\n\t        return lastName;\n\t    }\n\t\n\t    public void setLastName(String lastName) {\n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public int getAge() {\n\t        return age;\n\t    }\n\t\n\t    public void setAge(int age) {\n\t        this.age = age;\n\t    }\n\t}\n\n\n实现的Serializable接口并声明了序列化标识serialVersionUID。\n\n那么serialVersionUID有什么作用呢？\n\n实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。\n\n那么既然自动生成我们是不是可以不写？\n\n由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。\n\n\n例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。\n\n##### 2. Parcelable\n\nParcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。\n\n举个例子：\n\n\timport android.os.Parcel;\n\timport android.os.Parcelable;\n\t\n\tpublic class Person implements Parcelable {\n\t\n\t    private String firstName;\n\t    private String lastName;\n\t    private int age;\n\t\n\t\n\t    public Person(String firstName, String lastName, int age) {\n\t        this.firstName = firstName;\n\t        this.lastName = lastName;\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    public String getFirstName() {\n\t        return firstName;\n\t    }\n\t\n\t    public void setFirstName(String firstName) {\n\t        this.firstName = firstName;\n\t    }\n\t    \n\t    public String getLastName() {\n\t        return lastName;\n\t    }\n\t\n\t    public void setLastName(String lastName) {\n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public int getAge() {\n\t        return age;\n\t    }\n\t\n\t    public void setAge(int age) {\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    @Override\n\t    public int describeContents() {\n\t        return 0;\n\t    }\n\t\n\t    @Override\n\t    public void writeToParcel(Parcel dest, int flags) {\n\t        dest.writeString(this.firstName);\n\t        dest.writeString(this.lastName);\n\t        dest.writeInt(this.age);\n\t    }\n\t\n\t\tprotected Person(Parcel in) {\n\t\t        this.firstName = in.readString();\n\t\t        this.lastName = in.readString();\n\t\t        this.age = in.readInt();\n\t\t    }\n\t\n\t    public static final Parcelable.Creator<Person> CREATOR = new Parcelable.Creator<Person>() {\n\t        @Override\n\t        public Person createFromParcel(Parcel source) {\n\t            return new Person(source);\n\t        }\n\t\n\t        @Override\n\t        public Person[] newArray(int size) {\n\t            return new Person[size];\n\t        }\n\t    };\n\t}\n\n\n相对Serializable稍显复杂。\n\n* Parcelable.Creator\n\n\t* 必须实现的接口。\n\n* T createFromParcel (Parcel source)\n\n\t* 创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层\n\n* T[] newArray (int size)\n\n\t* 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。\n\n* void writeToParcel (Parcel dest, \n                int flags)\n                \n\n\t* 将当前对象写入序列化结构中\n\n\n简单概括下：\n\n 序列化过程中，需要实现序列化和反序列化以及内容描述。\n \n writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。\n \n 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。\n\n\n##### 3. Serializable 和 Parcelable 异同\n\n* 都能序列化，都可用于Intent传递数据\n\n* Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。\n\n* Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。\n\n* Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口\n\n","source":"_posts/IPC基础概念介绍.md","raw":"---\ntitle: IPC基础概念介绍\ndate: 2018-03-22 09:09:50\ntags: [Android进阶]\n---\n\n## IPC基础概念介绍\n\n#### 一、简介\n\n* IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。\n\n* 线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。\n\n\n#### 二、Android中的多进程模式\n\n Android中开启多进程的方法：\n \n\t <activity android:name=\".BinderOneActivity\"\n\t            android:process=\"com.neil.binder.one\"/>\n\t <activity android:name=\".BinderTwoActivity\"\n\t            android:process=\"com.neil.binder.two\"/>\n\t <activity android:name=\".BinderThreeActivity\"\n\t            android:process=\"com.neil.binder.three\"/>\n\t            \n在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。\n\n日志输出：\n\n\tu0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo\n\tu0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one\n\tu0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two\n\tu0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three\n\nAndroid系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。\n\n\n\t            \n#### 三、序列化和反序列化\n\n1. 序列化\n\n由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。\n\n指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程\n\n2. 反序列化\n\n反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。\n\n  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。\n  \n  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n  \n#### 四、Serializable VS  Parcelable\n\n##### 1. Serializable\n\nSerializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。\n\n举个例子：\n\n\timport java.io.Serializable;\n\t\n\tpublic class Person implements Serializable {\n\t\n\t\t**\n\t     * 生成序列号标识\n\t     */\n\t    private static final long serialVersionUID = -2083503801443301445L;\n\t    \n\t    private String firstName;\n\t    private String lastName;\n\t    private int age;\n\t\n\t\n\t    public Person(String firstName, String lastName, int age) {\n\t        this.firstName = firstName;\n\t        this.lastName = lastName;\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    public String getFirstName() {\n\t        return firstName;\n\t    }\n\t\n\t    public void setFirstName(String firstName) {\n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public String getLastName() {\n\t        return lastName;\n\t    }\n\t\n\t    public void setLastName(String lastName) {\n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public int getAge() {\n\t        return age;\n\t    }\n\t\n\t    public void setAge(int age) {\n\t        this.age = age;\n\t    }\n\t}\n\n\n实现的Serializable接口并声明了序列化标识serialVersionUID。\n\n那么serialVersionUID有什么作用呢？\n\n实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。\n\n那么既然自动生成我们是不是可以不写？\n\n由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。\n\n\n例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。\n\n##### 2. Parcelable\n\nParcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。\n\n举个例子：\n\n\timport android.os.Parcel;\n\timport android.os.Parcelable;\n\t\n\tpublic class Person implements Parcelable {\n\t\n\t    private String firstName;\n\t    private String lastName;\n\t    private int age;\n\t\n\t\n\t    public Person(String firstName, String lastName, int age) {\n\t        this.firstName = firstName;\n\t        this.lastName = lastName;\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    public String getFirstName() {\n\t        return firstName;\n\t    }\n\t\n\t    public void setFirstName(String firstName) {\n\t        this.firstName = firstName;\n\t    }\n\t    \n\t    public String getLastName() {\n\t        return lastName;\n\t    }\n\t\n\t    public void setLastName(String lastName) {\n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public int getAge() {\n\t        return age;\n\t    }\n\t\n\t    public void setAge(int age) {\n\t        this.age = age;\n\t    }\n\t\n\t\n\t    @Override\n\t    public int describeContents() {\n\t        return 0;\n\t    }\n\t\n\t    @Override\n\t    public void writeToParcel(Parcel dest, int flags) {\n\t        dest.writeString(this.firstName);\n\t        dest.writeString(this.lastName);\n\t        dest.writeInt(this.age);\n\t    }\n\t\n\t\tprotected Person(Parcel in) {\n\t\t        this.firstName = in.readString();\n\t\t        this.lastName = in.readString();\n\t\t        this.age = in.readInt();\n\t\t    }\n\t\n\t    public static final Parcelable.Creator<Person> CREATOR = new Parcelable.Creator<Person>() {\n\t        @Override\n\t        public Person createFromParcel(Parcel source) {\n\t            return new Person(source);\n\t        }\n\t\n\t        @Override\n\t        public Person[] newArray(int size) {\n\t            return new Person[size];\n\t        }\n\t    };\n\t}\n\n\n相对Serializable稍显复杂。\n\n* Parcelable.Creator\n\n\t* 必须实现的接口。\n\n* T createFromParcel (Parcel source)\n\n\t* 创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层\n\n* T[] newArray (int size)\n\n\t* 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。\n\n* void writeToParcel (Parcel dest, \n                int flags)\n                \n\n\t* 将当前对象写入序列化结构中\n\n\n简单概括下：\n\n 序列化过程中，需要实现序列化和反序列化以及内容描述。\n \n writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。\n \n 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。\n\n\n##### 3. Serializable 和 Parcelable 异同\n\n* 都能序列化，都可用于Intent传递数据\n\n* Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。\n\n* Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。\n\n* Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口\n\n","slug":"IPC基础概念介绍","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnk001fx3c0qro8rasp","content":"<h2 id=\"IPC基础概念介绍\"><a href=\"#IPC基础概念介绍\" class=\"headerlink\" title=\"IPC基础概念介绍\"></a>IPC基础概念介绍</h2><h4 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h4><ul>\n<li><p>IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。</p>\n</li>\n<li><p>线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。</p>\n</li>\n</ul>\n<h4 id=\"二、Android中的多进程模式\"><a href=\"#二、Android中的多进程模式\" class=\"headerlink\" title=\"二、Android中的多进程模式\"></a>二、Android中的多进程模式</h4><p> Android中开启多进程的方法：</p>\n<pre><code>&lt;activity android:name=&quot;.BinderOneActivity&quot;\n           android:process=&quot;com.neil.binder.one&quot;/&gt;\n&lt;activity android:name=&quot;.BinderTwoActivity&quot;\n           android:process=&quot;com.neil.binder.two&quot;/&gt;\n&lt;activity android:name=&quot;.BinderThreeActivity&quot;\n           android:process=&quot;com.neil.binder.three&quot;/&gt;\n</code></pre><p>在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。</p>\n<p>日志输出：</p>\n<pre><code>u0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo\nu0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one\nu0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two\nu0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three\n</code></pre><p>Android系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。</p>\n<h4 id=\"三、序列化和反序列化\"><a href=\"#三、序列化和反序列化\" class=\"headerlink\" title=\"三、序列化和反序列化\"></a>三、序列化和反序列化</h4><ol>\n<li>序列化</li>\n</ol>\n<p>由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。</p>\n<p>指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程</p>\n<ol>\n<li>反序列化</li>\n</ol>\n<p>反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。</p>\n<p>  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。<br>  <br>  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n  </p>\n<h4 id=\"四、Serializable-VS-Parcelable\"><a href=\"#四、Serializable-VS-Parcelable\" class=\"headerlink\" title=\"四、Serializable VS  Parcelable\"></a>四、Serializable VS  Parcelable</h4><h5 id=\"1-Serializable\"><a href=\"#1-Serializable\" class=\"headerlink\" title=\"1. Serializable\"></a>1. Serializable</h5><p>Serializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。</p>\n<p>举个例子：</p>\n<pre><code>import java.io.Serializable;\n\npublic class Person implements Serializable {\n\n    **\n     * 生成序列号标识\n     */\n    private static final long serialVersionUID = -2083503801443301445L;\n\n    private String firstName;\n    private String lastName;\n    private int age;\n\n\n    public Person(String firstName, String lastName, int age) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre><p>实现的Serializable接口并声明了序列化标识serialVersionUID。</p>\n<p>那么serialVersionUID有什么作用呢？</p>\n<p>实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。</p>\n<p>那么既然自动生成我们是不是可以不写？</p>\n<p>由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。</p>\n<p>例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。</p>\n<h5 id=\"2-Parcelable\"><a href=\"#2-Parcelable\" class=\"headerlink\" title=\"2. Parcelable\"></a>2. Parcelable</h5><p>Parcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。</p>\n<p>举个例子：</p>\n<pre><code>import android.os.Parcel;\nimport android.os.Parcelable;\n\npublic class Person implements Parcelable {\n\n    private String firstName;\n    private String lastName;\n    private int age;\n\n\n    public Person(String firstName, String lastName, int age) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(this.firstName);\n        dest.writeString(this.lastName);\n        dest.writeInt(this.age);\n    }\n\n    protected Person(Parcel in) {\n            this.firstName = in.readString();\n            this.lastName = in.readString();\n            this.age = in.readInt();\n        }\n\n    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() {\n        @Override\n        public Person createFromParcel(Parcel source) {\n            return new Person(source);\n        }\n\n        @Override\n        public Person[] newArray(int size) {\n            return new Person[size];\n        }\n    };\n}\n</code></pre><p>相对Serializable稍显复杂。</p>\n<ul>\n<li><p>Parcelable.Creator</p>\n<ul>\n<li>必须实现的接口。</li>\n</ul>\n</li>\n<li><p>T createFromParcel (Parcel source)</p>\n<ul>\n<li>创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层</li>\n</ul>\n</li>\n<li><p>T[] newArray (int size)</p>\n<ul>\n<li>创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。</li>\n</ul>\n</li>\n<li><p>void writeToParcel (Parcel dest, </p>\n<pre><code>int flags)\n</code></pre></li>\n</ul>\n<pre><code>* 将当前对象写入序列化结构中\n</code></pre><p>简单概括下：</p>\n<p> 序列化过程中，需要实现序列化和反序列化以及内容描述。</p>\n<p> writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。</p>\n<p> 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。</p>\n<h5 id=\"3-Serializable-和-Parcelable-异同\"><a href=\"#3-Serializable-和-Parcelable-异同\" class=\"headerlink\" title=\"3. Serializable 和 Parcelable 异同\"></a>3. Serializable 和 Parcelable 异同</h5><ul>\n<li><p>都能序列化，都可用于Intent传递数据</p>\n</li>\n<li><p>Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。</p>\n</li>\n<li><p>Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。</p>\n</li>\n<li><p>Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"IPC基础概念介绍\"><a href=\"#IPC基础概念介绍\" class=\"headerlink\" title=\"IPC基础概念介绍\"></a>IPC基础概念介绍</h2><h4 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h4><ul>\n<li><p>IPC是 Inter-Process Communication的缩写，意为进程间通信或跨进程通信，是指两个进程之间进行数据交换的过程。</p>\n</li>\n<li><p>线程是CPU调度的最小单元，同时线程是一种有限的系统资源。进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。最简单的情况下，一个进程中只可以有一个线程，即主线程，在Android中也叫UI线程。</p>\n</li>\n</ul>\n<h4 id=\"二、Android中的多进程模式\"><a href=\"#二、Android中的多进程模式\" class=\"headerlink\" title=\"二、Android中的多进程模式\"></a>二、Android中的多进程模式</h4><p> Android中开启多进程的方法：</p>\n<pre><code>&lt;activity android:name=&quot;.BinderOneActivity&quot;\n           android:process=&quot;com.neil.binder.one&quot;/&gt;\n&lt;activity android:name=&quot;.BinderTwoActivity&quot;\n           android:process=&quot;com.neil.binder.two&quot;/&gt;\n&lt;activity android:name=&quot;.BinderThreeActivity&quot;\n           android:process=&quot;com.neil.binder.three&quot;/&gt;\n</code></pre><p>在AndroidManifest.xml指定android:process属性，若没有指定process属性，默认的进程中，默认进程的进程名是包名。</p>\n<p>日志输出：</p>\n<pre><code>u0_a60    4080  1207  1255464 42888 ffffffff b74c94f5 S com.example.liushihan.glidedemo\nu0_a60    4113  1207  1256320 42124 ffffffff b74c94f5 S com.neil.binder.one\nu0_a60    4144  1207  1254256 42088 ffffffff b74c94f5 S com.neil.binder.two\nu0_a60    4170  1207  1254256 41744 ffffffff b74c94f5 S com.neil.binder.three\n</code></pre><p>Android系统为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录，组件信息等。</p>\n<h4 id=\"三、序列化和反序列化\"><a href=\"#三、序列化和反序列化\" class=\"headerlink\" title=\"三、序列化和反序列化\"></a>三、序列化和反序列化</h4><ol>\n<li>序列化</li>\n</ol>\n<p>由于存在于内存中的对象都是暂时的，无法长期驻存，为了把对象的状态保持下来，这时需要把对象写入到磁盘或者其他介质中，这个过程就叫做序列化。</p>\n<p>指把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。这个过程称为序列化。通俗来说就是将数据结构或对象转换成二进制串的过程</p>\n<ol>\n<li>反序列化</li>\n</ol>\n<p>反序列化恰恰是序列化的反向操作，也就是说，把已存在在磁盘或者其他介质中的对象，反序列化（读取）到内存中，以便后续操作，而这个过程就叫做反序列化。</p>\n<p>  概括性来说序列化是指将对象实例的状态存储到存储媒体（磁盘或者其他介质）的过程。在此过程中，先将对象的公共字段和私有字段以及类的名称（包括类所在的程序集）转换为字节流，然后再把字节流写入数据流。在随后对对象进行反序列化时，将创建出与原对象完全相同的副本。<br>  <br>  把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程\n  </p>\n<h4 id=\"四、Serializable-VS-Parcelable\"><a href=\"#四、Serializable-VS-Parcelable\" class=\"headerlink\" title=\"四、Serializable VS  Parcelable\"></a>四、Serializable VS  Parcelable</h4><h5 id=\"1-Serializable\"><a href=\"#1-Serializable\" class=\"headerlink\" title=\"1. Serializable\"></a>1. Serializable</h5><p>Serializable是java提供的一个序列化接口，它是一个空接口，专门为对象提供标准的序列化和反序列化操作，使用Serializable实现类的序列化比较简单，只要在类声明中实现Serializable接口即可。</p>\n<p>举个例子：</p>\n<pre><code>import java.io.Serializable;\n\npublic class Person implements Serializable {\n\n    **\n     * 生成序列号标识\n     */\n    private static final long serialVersionUID = -2083503801443301445L;\n\n    private String firstName;\n    private String lastName;\n    private int age;\n\n\n    public Person(String firstName, String lastName, int age) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre><p>实现的Serializable接口并声明了序列化标识serialVersionUID。</p>\n<p>那么serialVersionUID有什么作用呢？</p>\n<p>实际上我们不声明serialVersionUID也是可以的，因为在序列化过程中会自动生成一个serialVersionUID来标识序列化对象。</p>\n<p>那么既然自动生成我们是不是可以不写？</p>\n<p>由于serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的对象中serialVersionUID只有和当前类的serialVersionUID相同才能够正常被反序列化，也就是说序列化与反序列化的serialVersionUID必须相同才能够使序列化操作成功。具体过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。不指定的话在反序列化会报错。</p>\n<p>例子的实现很简单，当然也是有弊端的，如果在此过程中使用反射，可能会创建大量其他对象，这就可能会导致很多垃圾回收。造成的结果是性能差和电池耗尽。</p>\n<h5 id=\"2-Parcelable\"><a href=\"#2-Parcelable\" class=\"headerlink\" title=\"2. Parcelable\"></a>2. Parcelable</h5><p>Parcelable是Android SDK中接口。鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。</p>\n<p>举个例子：</p>\n<pre><code>import android.os.Parcel;\nimport android.os.Parcelable;\n\npublic class Person implements Parcelable {\n\n    private String firstName;\n    private String lastName;\n    private int age;\n\n\n    public Person(String firstName, String lastName, int age) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.age = age;\n    }\n\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        this.firstName = firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeString(this.firstName);\n        dest.writeString(this.lastName);\n        dest.writeInt(this.age);\n    }\n\n    protected Person(Parcel in) {\n            this.firstName = in.readString();\n            this.lastName = in.readString();\n            this.age = in.readInt();\n        }\n\n    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() {\n        @Override\n        public Person createFromParcel(Parcel source) {\n            return new Person(source);\n        }\n\n        @Override\n        public Person[] newArray(int size) {\n            return new Person[size];\n        }\n    };\n}\n</code></pre><p>相对Serializable稍显复杂。</p>\n<ul>\n<li><p>Parcelable.Creator</p>\n<ul>\n<li>必须实现的接口。</li>\n</ul>\n</li>\n<li><p>T createFromParcel (Parcel source)</p>\n<ul>\n<li>创建序列化的实例，实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层</li>\n</ul>\n</li>\n<li><p>T[] newArray (int size)</p>\n<ul>\n<li>创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。</li>\n</ul>\n</li>\n<li><p>void writeToParcel (Parcel dest, </p>\n<pre><code>int flags)\n</code></pre></li>\n</ul>\n<pre><code>* 将当前对象写入序列化结构中\n</code></pre><p>简单概括下：</p>\n<p> 序列化过程中，需要实现序列化和反序列化以及内容描述。</p>\n<p> writeToParcel实现序列化，通过CREATOR内部对象来实现反序列化，其内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终利用Parcel的一系列read方法完成反序列化，最后由describeContents完成内容描述功能，该方法一般返回0，仅当对象中存在文件描述符时返回1。</p>\n<p> 一句话概括，就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。</p>\n<h5 id=\"3-Serializable-和-Parcelable-异同\"><a href=\"#3-Serializable-和-Parcelable-异同\" class=\"headerlink\" title=\"3. Serializable 和 Parcelable 异同\"></a>3. Serializable 和 Parcelable 异同</h5><ul>\n<li><p>都能序列化，都可用于Intent传递数据</p>\n</li>\n<li><p>Serializable是Java中的序列化接口，使用简单但是内存开销大，序列化和反序列化需要大量的I/O操作。</p>\n</li>\n<li><p>Parcelable是Android SDK中的序列化接口，更适用Android平台，使用起来稍显复杂，但是效率很高。内存开销较小。</p>\n</li>\n<li><p>Parcelable主要用于内存序列化上，因此在序列化到存储设备或者网络传输方面还是尽量选择Serializable接口</p>\n</li>\n</ul>\n"},{"title":"Java线程池浅析","date":"2018-12-04T07:59:48.000Z","_content":"\n# Java线程池\n\n### 一、简单介绍\n\n最简单的新建一个线程的方式就是new Thread\n```\nnew Thread(new Runnable() {\n\t\t@Overrider\n\t\tpublic void run(){\n\t\t\t//do something\n\t\t}\n\t}\n).start();\n```\n\n虽然简单，但是有很多缺点：\n\n1. 频繁的使用new Thread 来新建线程会造成新建对象性能差\n2. 新建的线程缺乏统一的管理，并且新建线程没有限制，互相竞争，可能占用系统资源导致oom\n3. 功能单一\n\n既然不能new Thread不能满足多样的需求变化，那么Java提供的线程池就很好的解决了这些问题。Java提供四种线程池，下面一一介绍。\n\n### 二、Java线程池\n\n优点：\n1. 重用线程池中的线程，避免因频繁创建和销毁线程带来的性能的开销\n2. 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞的现象\n3. 能够对线程进行简单的管理，并提供定时执行及指定间隔循环执行的功能\n\n\nJava中的线程池的具体实现是在ThreadPoolExecutor，通过配置不同的参数来实现不同功能的线程池。\n\nThreadPoolExecutor构造函数有四个，源码实现最终都是调用了\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n\n```\n\n 构造函数的各个参数将会影响到线程池的功能特性，\n\n* corePoolSize： 线程池中的核心线程池数量，除非设置了allowCoreThreadTimeOut为true，否则即使处于空闲状态也一直保留在线程池中。\n* maximumPoolSize：最大线程数，当活动的线程数达到最大，后续新的任务将会被阻塞\n* keepAliveTime：非核心线程空闲时的超时时间，空闲超过该时间将会被回收，当allowCoreThreadTimeOut为true也会作用于核心线程\n* unit：超时时间的单位\n* workQueue：线程池中的任务队列，通过线程池的execute方法提交的Runnable会存储在这个参数中在JDK中提供了如下阻塞队列：\n1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；\n2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；\n3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；\n4、priorityBlockingQuene：具有优先级的无界阻塞队列；\n\n* threadFactory：线程工厂,为线程池提供创建新线程的功能\n* handler：RejectedExecutionHandler（饱和策略），当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n1、AbortPolicy：直接抛出异常。\n2、CallerRunsPolicy：只用调用者所在线程来运行任务。\n3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n4、DiscardPolicy：不处理，丢弃掉。\n当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\n### 三、线程池的分类\n\n常见的线程池有四种:\n\n1. FixedThreadPool\n2. CachedThreadPool\n3. ScheduledThreadPool\n4. SingleThreadExecutor\n\n\n","source":"_posts/Java-线程池浅析.md","raw":"---\ntitle: Java线程池浅析\ndate: 2018-12-04 15:59:48\ntags: [Java]\n---\n\n# Java线程池\n\n### 一、简单介绍\n\n最简单的新建一个线程的方式就是new Thread\n```\nnew Thread(new Runnable() {\n\t\t@Overrider\n\t\tpublic void run(){\n\t\t\t//do something\n\t\t}\n\t}\n).start();\n```\n\n虽然简单，但是有很多缺点：\n\n1. 频繁的使用new Thread 来新建线程会造成新建对象性能差\n2. 新建的线程缺乏统一的管理，并且新建线程没有限制，互相竞争，可能占用系统资源导致oom\n3. 功能单一\n\n既然不能new Thread不能满足多样的需求变化，那么Java提供的线程池就很好的解决了这些问题。Java提供四种线程池，下面一一介绍。\n\n### 二、Java线程池\n\n优点：\n1. 重用线程池中的线程，避免因频繁创建和销毁线程带来的性能的开销\n2. 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞的现象\n3. 能够对线程进行简单的管理，并提供定时执行及指定间隔循环执行的功能\n\n\nJava中的线程池的具体实现是在ThreadPoolExecutor，通过配置不同的参数来实现不同功能的线程池。\n\nThreadPoolExecutor构造函数有四个，源码实现最终都是调用了\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n\n```\n\n 构造函数的各个参数将会影响到线程池的功能特性，\n\n* corePoolSize： 线程池中的核心线程池数量，除非设置了allowCoreThreadTimeOut为true，否则即使处于空闲状态也一直保留在线程池中。\n* maximumPoolSize：最大线程数，当活动的线程数达到最大，后续新的任务将会被阻塞\n* keepAliveTime：非核心线程空闲时的超时时间，空闲超过该时间将会被回收，当allowCoreThreadTimeOut为true也会作用于核心线程\n* unit：超时时间的单位\n* workQueue：线程池中的任务队列，通过线程池的execute方法提交的Runnable会存储在这个参数中在JDK中提供了如下阻塞队列：\n1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；\n2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；\n3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；\n4、priorityBlockingQuene：具有优先级的无界阻塞队列；\n\n* threadFactory：线程工厂,为线程池提供创建新线程的功能\n* handler：RejectedExecutionHandler（饱和策略），当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。\n1、AbortPolicy：直接抛出异常。\n2、CallerRunsPolicy：只用调用者所在线程来运行任务。\n3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n4、DiscardPolicy：不处理，丢弃掉。\n当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\n### 三、线程池的分类\n\n常见的线程池有四种:\n\n1. FixedThreadPool\n2. CachedThreadPool\n3. ScheduledThreadPool\n4. SingleThreadExecutor\n\n\n","slug":"Java-线程池浅析","published":1,"updated":"2018-12-04T10:42:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnl001hx3c0oowcyxtr","content":"<h1 id=\"Java线程池\"><a href=\"#Java线程池\" class=\"headerlink\" title=\"Java线程池\"></a>Java线程池</h1><h3 id=\"一、简单介绍\"><a href=\"#一、简单介绍\" class=\"headerlink\" title=\"一、简单介绍\"></a>一、简单介绍</h3><p>最简单的新建一个线程的方式就是new Thread<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Overrider</span></div><div class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//do something</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">).start();</div></pre></td></tr></table></figure></p>\n<p>虽然简单，但是有很多缺点：</p>\n<ol>\n<li>频繁的使用new Thread 来新建线程会造成新建对象性能差</li>\n<li>新建的线程缺乏统一的管理，并且新建线程没有限制，互相竞争，可能占用系统资源导致oom</li>\n<li>功能单一</li>\n</ol>\n<p>既然不能new Thread不能满足多样的需求变化，那么Java提供的线程池就很好的解决了这些问题。Java提供四种线程池，下面一一介绍。</p>\n<h3 id=\"二、Java线程池\"><a href=\"#二、Java线程池\" class=\"headerlink\" title=\"二、Java线程池\"></a>二、Java线程池</h3><p>优点：</p>\n<ol>\n<li>重用线程池中的线程，避免因频繁创建和销毁线程带来的性能的开销</li>\n<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞的现象</li>\n<li>能够对线程进行简单的管理，并提供定时执行及指定间隔循环执行的功能</li>\n</ol>\n<p>Java中的线程池的具体实现是在ThreadPoolExecutor，通过配置不同的参数来实现不同功能的线程池。</p>\n<p>ThreadPoolExecutor构造函数有四个，源码实现最终都是调用了</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></div><div class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</div><div class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</div><div class=\"line\">                          TimeUnit unit,</div><div class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                          ThreadFactory threadFactory,</div><div class=\"line\">                          RejectedExecutionHandler <span class=\"keyword\">handler</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt; corePoolSize ||</div><div class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</div><div class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || <span class=\"keyword\">handler</span> == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</div><div class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</div><div class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"keyword\">handler</span> = <span class=\"keyword\">handler</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 构造函数的各个参数将会影响到线程池的功能特性，</p>\n<ul>\n<li>corePoolSize： 线程池中的核心线程池数量，除非设置了allowCoreThreadTimeOut为true，否则即使处于空闲状态也一直保留在线程池中。</li>\n<li>maximumPoolSize：最大线程数，当活动的线程数达到最大，后续新的任务将会被阻塞</li>\n<li>keepAliveTime：非核心线程空闲时的超时时间，空闲超过该时间将会被回收，当allowCoreThreadTimeOut为true也会作用于核心线程</li>\n<li>unit：超时时间的单位</li>\n<li><p>workQueue：线程池中的任务队列，通过线程池的execute方法提交的Runnable会存储在这个参数中在JDK中提供了如下阻塞队列：<br>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；<br>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</p>\n</li>\n<li><p>threadFactory：线程工厂,为线程池提供创建新线程的功能</p>\n</li>\n<li>handler：RejectedExecutionHandler（饱和策略），当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。<br>1、AbortPolicy：直接抛出异常。<br>2、CallerRunsPolicy：只用调用者所在线程来运行任务。<br>3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>4、DiscardPolicy：不处理，丢弃掉。<br>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>\n</ul>\n<h3 id=\"三、线程池的分类\"><a href=\"#三、线程池的分类\" class=\"headerlink\" title=\"三、线程池的分类\"></a>三、线程池的分类</h3><p>常见的线程池有四种:</p>\n<ol>\n<li>FixedThreadPool</li>\n<li>CachedThreadPool</li>\n<li>ScheduledThreadPool</li>\n<li>SingleThreadExecutor</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java线程池\"><a href=\"#Java线程池\" class=\"headerlink\" title=\"Java线程池\"></a>Java线程池</h1><h3 id=\"一、简单介绍\"><a href=\"#一、简单介绍\" class=\"headerlink\" title=\"一、简单介绍\"></a>一、简单介绍</h3><p>最简单的新建一个线程的方式就是new Thread<br><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">\t\t<span class=\"meta\">@Overrider</span></div><div class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">//do something</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">).start();</div></pre></td></tr></table></figure></p>\n<p>虽然简单，但是有很多缺点：</p>\n<ol>\n<li>频繁的使用new Thread 来新建线程会造成新建对象性能差</li>\n<li>新建的线程缺乏统一的管理，并且新建线程没有限制，互相竞争，可能占用系统资源导致oom</li>\n<li>功能单一</li>\n</ol>\n<p>既然不能new Thread不能满足多样的需求变化，那么Java提供的线程池就很好的解决了这些问题。Java提供四种线程池，下面一一介绍。</p>\n<h3 id=\"二、Java线程池\"><a href=\"#二、Java线程池\" class=\"headerlink\" title=\"二、Java线程池\"></a>二、Java线程池</h3><p>优点：</p>\n<ol>\n<li>重用线程池中的线程，避免因频繁创建和销毁线程带来的性能的开销</li>\n<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞的现象</li>\n<li>能够对线程进行简单的管理，并提供定时执行及指定间隔循环执行的功能</li>\n</ol>\n<p>Java中的线程池的具体实现是在ThreadPoolExecutor，通过配置不同的参数来实现不同功能的线程池。</p>\n<p>ThreadPoolExecutor构造函数有四个，源码实现最终都是调用了</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></div><div class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</div><div class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</div><div class=\"line\">                          TimeUnit unit,</div><div class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                          ThreadFactory threadFactory,</div><div class=\"line\">                          RejectedExecutionHandler <span class=\"keyword\">handler</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt; corePoolSize ||</div><div class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</div><div class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || <span class=\"keyword\">handler</span> == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</div><div class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</div><div class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"keyword\">handler</span> = <span class=\"keyword\">handler</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 构造函数的各个参数将会影响到线程池的功能特性，</p>\n<ul>\n<li>corePoolSize： 线程池中的核心线程池数量，除非设置了allowCoreThreadTimeOut为true，否则即使处于空闲状态也一直保留在线程池中。</li>\n<li>maximumPoolSize：最大线程数，当活动的线程数达到最大，后续新的任务将会被阻塞</li>\n<li>keepAliveTime：非核心线程空闲时的超时时间，空闲超过该时间将会被回收，当allowCoreThreadTimeOut为true也会作用于核心线程</li>\n<li>unit：超时时间的单位</li>\n<li><p>workQueue：线程池中的任务队列，通过线程池的execute方法提交的Runnable会存储在这个参数中在JDK中提供了如下阻塞队列：<br>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；<br>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；<br>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；<br>4、priorityBlockingQuene：具有优先级的无界阻塞队列；</p>\n</li>\n<li><p>threadFactory：线程工厂,为线程池提供创建新线程的功能</p>\n</li>\n<li>handler：RejectedExecutionHandler（饱和策略），当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。<br>1、AbortPolicy：直接抛出异常。<br>2、CallerRunsPolicy：只用调用者所在线程来运行任务。<br>3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>4、DiscardPolicy：不处理，丢弃掉。<br>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>\n</ul>\n<h3 id=\"三、线程池的分类\"><a href=\"#三、线程池的分类\" class=\"headerlink\" title=\"三、线程池的分类\"></a>三、线程池的分类</h3><p>常见的线程池有四种:</p>\n<ol>\n<li>FixedThreadPool</li>\n<li>CachedThreadPool</li>\n<li>ScheduledThreadPool</li>\n<li>SingleThreadExecutor</li>\n</ol>\n"},{"title":"MarkDown语法","date":"2016-09-04T15:30:15.000Z","_content":"\n\n1. 列表\n\n\t* 1.、2.···加空格\n\t* *、+、-加空格\n\n2. 标题\n\t\n\t* 以#数量相对应H1、H2···\n\n3. 行内代码\n\n\t* 可以通过 ``，插入行内代码（` 是 Tab 键上边、数字 1 键左侧的那个按键）\n\n4. 超链接\n\n\t* 普通链接\n\t\t* `[Google](http://www.google.com/)`\n\t\n\t* 指向本地文件的链接\n\t\t* `[icon.png](./images/icon.png)`\n\n5. 图片\n\t\n\t* `![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 \"GitHub,Social Coding\")`\n\n6. 表格\n\n\t* 单元格和表头：\n\t\t* 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\n\n\t\t\t`  name | age `\n\t\t\t\n\t\t\t`\t---- | ---`\n\t\t\t\n\t\t\t`\tLearnShare | 12`\n\t\t\t\n\t\t\t`\tMike |  32 `","source":"_posts/MarkDown语法.md","raw":"---\ntitle: MarkDown语法\ndate: 2016-09-04 23:30:15\ntags: [MarkDown]\n---\n\n\n1. 列表\n\n\t* 1.、2.···加空格\n\t* *、+、-加空格\n\n2. 标题\n\t\n\t* 以#数量相对应H1、H2···\n\n3. 行内代码\n\n\t* 可以通过 ``，插入行内代码（` 是 Tab 键上边、数字 1 键左侧的那个按键）\n\n4. 超链接\n\n\t* 普通链接\n\t\t* `[Google](http://www.google.com/)`\n\t\n\t* 指向本地文件的链接\n\t\t* `[icon.png](./images/icon.png)`\n\n5. 图片\n\t\n\t* `![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 \"GitHub,Social Coding\")`\n\n6. 表格\n\n\t* 单元格和表头：\n\t\t* 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\n\n\t\t\t`  name | age `\n\t\t\t\n\t\t\t`\t---- | ---`\n\t\t\t\n\t\t\t`\tLearnShare | 12`\n\t\t\t\n\t\t\t`\tMike |  32 `","slug":"MarkDown语法","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnm001jx3c0lwr0bu90","content":"<ol>\n<li><p>列表</p>\n<ul>\n<li>1.、2.···加空格</li>\n<li>*、+、-加空格</li>\n</ul>\n</li>\n<li><p>标题</p>\n<ul>\n<li>以#数量相对应H1、H2···</li>\n</ul>\n</li>\n<li><p>行内代码</p>\n<ul>\n<li>可以通过 <code>`，插入行内代码（</code> 是 Tab 键上边、数字 1 键左侧的那个按键）</li>\n</ul>\n</li>\n<li><p>超链接</p>\n<ul>\n<li><p>普通链接</p>\n<ul>\n<li><code>[Google](http://www.google.com/)</code></li>\n</ul>\n</li>\n<li><p>指向本地文件的链接</p>\n<ul>\n<li><code>[icon.png](./images/icon.png)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>图片</p>\n<ul>\n<li><code>![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;)</code></li>\n</ul>\n</li>\n<li><p>表格</p>\n<ul>\n<li><p>单元格和表头：</p>\n<ul>\n<li><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p>\n<p>  <code>name | age</code></p>\n<p>  <code>---- | ---</code></p>\n<p>  <code>LearnShare | 12</code></p>\n<p>  <code>Mike |  32</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>列表</p>\n<ul>\n<li>1.、2.···加空格</li>\n<li>*、+、-加空格</li>\n</ul>\n</li>\n<li><p>标题</p>\n<ul>\n<li>以#数量相对应H1、H2···</li>\n</ul>\n</li>\n<li><p>行内代码</p>\n<ul>\n<li>可以通过 <code>`，插入行内代码（</code> 是 Tab 键上边、数字 1 键左侧的那个按键）</li>\n</ul>\n</li>\n<li><p>超链接</p>\n<ul>\n<li><p>普通链接</p>\n<ul>\n<li><code>[Google](http://www.google.com/)</code></li>\n</ul>\n</li>\n<li><p>指向本地文件的链接</p>\n<ul>\n<li><code>[icon.png](./images/icon.png)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>图片</p>\n<ul>\n<li><code>![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;)</code></li>\n</ul>\n</li>\n<li><p>表格</p>\n<ul>\n<li><p>单元格和表头：</p>\n<ul>\n<li><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p>\n<p>  <code>name | age</code></p>\n<p>  <code>---- | ---</code></p>\n<p>  <code>LearnShare | 12</code></p>\n<p>  <code>Mike |  32</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Java死锁浅析","date":"2018-11-14T07:38:44.000Z","_content":"\n## 一、死锁的基本概念\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”那么我们换一个更加规范的定义：“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。\n\n\n产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。\n\n* 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n* 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。\n* 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n* 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有\n\n\n```\npublic class SyncABDemo {\n    public static void main(String args[]){\n\n    Object a =  new Object();\n    Object b =  new Object();\n    Thread threadA = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized(a) {\n                try{\n                    System.out.println(\"ThreadA--a is Locked\");\n                    Thread.sleep(1000);\n                    synchronized(b) {\n                        System.out.println(\"ThreadA--b is Locked\");\n                    }\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n    Thread threadB = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized(b) {\n                try{\n                    System.out.println(\"ThreadB--a is Locked\");\n                    Thread.sleep(1000);\n                    synchronized(a) {\n                        System.out.println(\"ThreadB--b is Locked\");\n                    }\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n    threadA.start();\n    threadB.start();\n    }\n}\n\n```\n\n\n输出结果为：\n\n```\nThreadA--a is Locked\nThreadB--a is Locked\n\n```\n\n发现程序执行停滞了。\n\n这个时候程序发生了死锁。\n\n## 二、检测死锁\nJDK自带检测工具\n可以在IDEA命令行输入JConsole打开JConsole连接本地进程就可以进行检测死锁的操作了。\n\n\n## 三、死锁预防\n\n### 1.以确定的顺序获得锁\n\n如果一定要获取多个锁，那么在设计的时候需要考虑多线程情况下获取锁的情况\n\n例如上述代码示例：\n\n* 线程A -> 获取锁a -> 获取锁b -> 永久等待\n\n* 线程B -> 获取锁b -> 获取锁a -> 永久等待\n\n那么如果把获取锁的时序更改为下面的情况：\n\n* 线程A -> 获取锁a -> 获取锁b -> 结束\n\n* 线程B -> 获取锁a -> 获取锁b -> 结束\n\n那么死锁就不会发生了\n\n### 2.超时放弃\n\n当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了\n\n`boolean tryLock(long time, TimeUnit unit) throws InterruptedException`\n\n方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。\n\n## 四、死锁举例\n\n### 线程池死锁\n\n```\nfinal ExecutorService executorService = \n        Executors.newSingleThreadExecutor();\nFuture<Long> f1 = executorService.submit(new Callable<Long>() {\n\n    public Long call() throws Exception {\n        System.out.println(\"start f1\");\n        Thread.sleep(1000);//延时\n        Future<Long> f2 = \n           executorService.submit(new Callable<Long>() {\n\n            public Long call() throws Exception {\n                System.out.println(\"start f2\");\n                return -1L;\n            }\n        });\n        System.out.println(\"result\" + f2.get());\n        System.out.println(\"end f1\");\n        return -1L;\n    }\n});\n```\n","source":"_posts/Java死锁浅析.md","raw":"---\ntitle: Java死锁浅析\ndate: 2018-11-14 15:38:44\ntags: [Java]\n---\n\n## 一、死锁的基本概念\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”那么我们换一个更加规范的定义：“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。\n\n\n产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。\n\n* 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。\n* 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。\n* 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n* 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有\n\n\n```\npublic class SyncABDemo {\n    public static void main(String args[]){\n\n    Object a =  new Object();\n    Object b =  new Object();\n    Thread threadA = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized(a) {\n                try{\n                    System.out.println(\"ThreadA--a is Locked\");\n                    Thread.sleep(1000);\n                    synchronized(b) {\n                        System.out.println(\"ThreadA--b is Locked\");\n                    }\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n    Thread threadB = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized(b) {\n                try{\n                    System.out.println(\"ThreadB--a is Locked\");\n                    Thread.sleep(1000);\n                    synchronized(a) {\n                        System.out.println(\"ThreadB--b is Locked\");\n                    }\n                } catch(InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    });\n    threadA.start();\n    threadB.start();\n    }\n}\n\n```\n\n\n输出结果为：\n\n```\nThreadA--a is Locked\nThreadB--a is Locked\n\n```\n\n发现程序执行停滞了。\n\n这个时候程序发生了死锁。\n\n## 二、检测死锁\nJDK自带检测工具\n可以在IDEA命令行输入JConsole打开JConsole连接本地进程就可以进行检测死锁的操作了。\n\n\n## 三、死锁预防\n\n### 1.以确定的顺序获得锁\n\n如果一定要获取多个锁，那么在设计的时候需要考虑多线程情况下获取锁的情况\n\n例如上述代码示例：\n\n* 线程A -> 获取锁a -> 获取锁b -> 永久等待\n\n* 线程B -> 获取锁b -> 获取锁a -> 永久等待\n\n那么如果把获取锁的时序更改为下面的情况：\n\n* 线程A -> 获取锁a -> 获取锁b -> 结束\n\n* 线程B -> 获取锁a -> 获取锁b -> 结束\n\n那么死锁就不会发生了\n\n### 2.超时放弃\n\n当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了\n\n`boolean tryLock(long time, TimeUnit unit) throws InterruptedException`\n\n方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。\n\n## 四、死锁举例\n\n### 线程池死锁\n\n```\nfinal ExecutorService executorService = \n        Executors.newSingleThreadExecutor();\nFuture<Long> f1 = executorService.submit(new Callable<Long>() {\n\n    public Long call() throws Exception {\n        System.out.println(\"start f1\");\n        Thread.sleep(1000);//延时\n        Future<Long> f2 = \n           executorService.submit(new Callable<Long>() {\n\n            public Long call() throws Exception {\n                System.out.println(\"start f2\");\n                return -1L;\n            }\n        });\n        System.out.println(\"result\" + f2.get());\n        System.out.println(\"end f1\");\n        return -1L;\n    }\n});\n```\n","slug":"Java死锁浅析","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnp001mx3c0gp464r5t","content":"<h2 id=\"一、死锁的基本概念\"><a href=\"#一、死锁的基本概念\" class=\"headerlink\" title=\"一、死锁的基本概念\"></a>一、死锁的基本概念</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”那么我们换一个更加规范的定义：“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</p>\n<p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>\n<ul>\n<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>\n<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有</li>\n</ul>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> class SyncABDemo &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> args[])&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">Object</span> a =  <span class=\"keyword\">new</span> <span class=\"keyword\">Object</span>();</div><div class=\"line\">    <span class=\"keyword\">Object</span> b =  <span class=\"keyword\">new</span> <span class=\"keyword\">Object</span>();</div><div class=\"line\">    Thread threadA = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run() &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span>(a) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadA--a is Locked\"</span>);</div><div class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">                    <span class=\"keyword\">synchronized</span>(b) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadA--b is Locked\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Thread threadB = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run() &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span>(b) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadB--a is Locked\"</span>);</div><div class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">                    <span class=\"keyword\">synchronized</span>(a) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadB--b is Locked\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    threadA.start();</div><div class=\"line\">    threadB.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThreadA<span class=\"comment\">--a is Locked</span></div><div class=\"line\">ThreadB<span class=\"comment\">--a is Locked</span></div></pre></td></tr></table></figure>\n<p>发现程序执行停滞了。</p>\n<p>这个时候程序发生了死锁。</p>\n<h2 id=\"二、检测死锁\"><a href=\"#二、检测死锁\" class=\"headerlink\" title=\"二、检测死锁\"></a>二、检测死锁</h2><p>JDK自带检测工具<br>可以在IDEA命令行输入JConsole打开JConsole连接本地进程就可以进行检测死锁的操作了。</p>\n<h2 id=\"三、死锁预防\"><a href=\"#三、死锁预防\" class=\"headerlink\" title=\"三、死锁预防\"></a>三、死锁预防</h2><h3 id=\"1-以确定的顺序获得锁\"><a href=\"#1-以确定的顺序获得锁\" class=\"headerlink\" title=\"1.以确定的顺序获得锁\"></a>1.以确定的顺序获得锁</h3><p>如果一定要获取多个锁，那么在设计的时候需要考虑多线程情况下获取锁的情况</p>\n<p>例如上述代码示例：</p>\n<ul>\n<li><p>线程A -&gt; 获取锁a -&gt; 获取锁b -&gt; 永久等待</p>\n</li>\n<li><p>线程B -&gt; 获取锁b -&gt; 获取锁a -&gt; 永久等待</p>\n</li>\n</ul>\n<p>那么如果把获取锁的时序更改为下面的情况：</p>\n<ul>\n<li><p>线程A -&gt; 获取锁a -&gt; 获取锁b -&gt; 结束</p>\n</li>\n<li><p>线程B -&gt; 获取锁a -&gt; 获取锁b -&gt; 结束</p>\n</li>\n</ul>\n<p>那么死锁就不会发生了</p>\n<h3 id=\"2-超时放弃\"><a href=\"#2-超时放弃\" class=\"headerlink\" title=\"2.超时放弃\"></a>2.超时放弃</h3><p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了</p>\n<p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></p>\n<p>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</p>\n<h2 id=\"四、死锁举例\"><a href=\"#四、死锁举例\" class=\"headerlink\" title=\"四、死锁举例\"></a>四、死锁举例</h2><h3 id=\"线程池死锁\"><a href=\"#线程池死锁\" class=\"headerlink\" title=\"线程池死锁\"></a>线程池死锁</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ExecutorService executorService = </div><div class=\"line\">        Executors.newSingleThreadExecutor();</div><div class=\"line\">Future&lt;<span class=\"keyword\">Long</span>&gt; f1 = executorService.submit(<span class=\"keyword\">new</span> Callable&lt;<span class=\"keyword\">Long</span>&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">Long</span> <span class=\"keyword\">call</span>() <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"start f1\"</span>);</div><div class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//延时</span></div><div class=\"line\">        Future&lt;<span class=\"keyword\">Long</span>&gt; f2 = </div><div class=\"line\">           executorService.submit(<span class=\"keyword\">new</span> Callable&lt;<span class=\"keyword\">Long</span>&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">Long</span> <span class=\"keyword\">call</span>() <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">                System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"start f2\"</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>L;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"result\"</span> + f2.get());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"end f1\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>L;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、死锁的基本概念\"><a href=\"#一、死锁的基本概念\" class=\"headerlink\" title=\"一、死锁的基本概念\"></a>一、死锁的基本概念</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。”那么我们换一个更加规范的定义：“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</p>\n<p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>\n<ul>\n<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>\n<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有</li>\n</ul>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> class SyncABDemo &#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"keyword\">String</span> args[])&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">Object</span> a =  <span class=\"keyword\">new</span> <span class=\"keyword\">Object</span>();</div><div class=\"line\">    <span class=\"keyword\">Object</span> b =  <span class=\"keyword\">new</span> <span class=\"keyword\">Object</span>();</div><div class=\"line\">    Thread threadA = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run() &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span>(a) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadA--a is Locked\"</span>);</div><div class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">                    <span class=\"keyword\">synchronized</span>(b) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadA--b is Locked\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    Thread threadB = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run() &#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span>(b) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">                    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadB--a is Locked\"</span>);</div><div class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\">                    <span class=\"keyword\">synchronized</span>(a) &#123;</div><div class=\"line\">                        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">\"ThreadB--b is Locked\"</span>);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</div><div class=\"line\">                    e.printStackTrace();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    threadA.start();</div><div class=\"line\">    threadB.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ThreadA<span class=\"comment\">--a is Locked</span></div><div class=\"line\">ThreadB<span class=\"comment\">--a is Locked</span></div></pre></td></tr></table></figure>\n<p>发现程序执行停滞了。</p>\n<p>这个时候程序发生了死锁。</p>\n<h2 id=\"二、检测死锁\"><a href=\"#二、检测死锁\" class=\"headerlink\" title=\"二、检测死锁\"></a>二、检测死锁</h2><p>JDK自带检测工具<br>可以在IDEA命令行输入JConsole打开JConsole连接本地进程就可以进行检测死锁的操作了。</p>\n<h2 id=\"三、死锁预防\"><a href=\"#三、死锁预防\" class=\"headerlink\" title=\"三、死锁预防\"></a>三、死锁预防</h2><h3 id=\"1-以确定的顺序获得锁\"><a href=\"#1-以确定的顺序获得锁\" class=\"headerlink\" title=\"1.以确定的顺序获得锁\"></a>1.以确定的顺序获得锁</h3><p>如果一定要获取多个锁，那么在设计的时候需要考虑多线程情况下获取锁的情况</p>\n<p>例如上述代码示例：</p>\n<ul>\n<li><p>线程A -&gt; 获取锁a -&gt; 获取锁b -&gt; 永久等待</p>\n</li>\n<li><p>线程B -&gt; 获取锁b -&gt; 获取锁a -&gt; 永久等待</p>\n</li>\n</ul>\n<p>那么如果把获取锁的时序更改为下面的情况：</p>\n<ul>\n<li><p>线程A -&gt; 获取锁a -&gt; 获取锁b -&gt; 结束</p>\n</li>\n<li><p>线程B -&gt; 获取锁a -&gt; 获取锁b -&gt; 结束</p>\n</li>\n</ul>\n<p>那么死锁就不会发生了</p>\n<h3 id=\"2-超时放弃\"><a href=\"#2-超时放弃\" class=\"headerlink\" title=\"2.超时放弃\"></a>2.超时放弃</h3><p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了</p>\n<p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></p>\n<p>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</p>\n<h2 id=\"四、死锁举例\"><a href=\"#四、死锁举例\" class=\"headerlink\" title=\"四、死锁举例\"></a>四、死锁举例</h2><h3 id=\"线程池死锁\"><a href=\"#线程池死锁\" class=\"headerlink\" title=\"线程池死锁\"></a>线程池死锁</h3><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> ExecutorService executorService = </div><div class=\"line\">        Executors.newSingleThreadExecutor();</div><div class=\"line\">Future&lt;<span class=\"keyword\">Long</span>&gt; f1 = executorService.submit(<span class=\"keyword\">new</span> Callable&lt;<span class=\"keyword\">Long</span>&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">Long</span> <span class=\"keyword\">call</span>() <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"start f1\"</span>);</div><div class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">//延时</span></div><div class=\"line\">        Future&lt;<span class=\"keyword\">Long</span>&gt; f2 = </div><div class=\"line\">           executorService.submit(<span class=\"keyword\">new</span> Callable&lt;<span class=\"keyword\">Long</span>&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">Long</span> <span class=\"keyword\">call</span>() <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\">                System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"start f2\"</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>L;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"result\"</span> + f2.get());</div><div class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">\"end f1\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>L;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"Java并发编程：volatile关键字解析","date":"2017-12-08T02:28:29.000Z","_content":"\n原文出处：http://www.cnblogs.com/dolphin0520/p/3920373.html\n### 一.内存模型的相关概念\n\n计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\n\n\ti = i + 1;\n\t\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n\n这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n\n为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n\n 1. 通过在总线加LOCK#锁的方式\n\n 2. 通过缓存一致性协议\n\n这2种方式都是硬件层面上提供的方式。\n\n在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n### 二.并发编程中的三个概念\n\n在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：\n\n1. 原子性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n\ti = 9;\n\t\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n2. 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n举个简单的例子，看下面这段代码：\n\n\t//线程1执行的代码\n\tint i = 0;\n\ti = 10;\n\t \n\t//线程2执行的代码\n\tj = i;\n\t\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3. 有序性\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\n\tint i = 0;              \n\tboolean flag = false;\n\ti = 1;                //语句1  \n\tflag = true;          //语句2\n\t\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n\tint a = 10;    //语句1\n\tint r = 2;    //语句2\n\ta = a + 3;    //语句3\n\tr = a*a;     //语句4\n\t\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n语句2  语句1  语句3  语句4\n\n那么可不可能是这个执行顺序呢：\n\n 语句2   语句1    语句4   语句3\n \n 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n \n 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n \n\t //线程1:\n\tcontext = loadContext();   //语句1\n\tinited = true;             //语句2\n\t \n\t//线程2:\n\twhile(!inited ){\n\t  sleep()\n\t}\n\tdoSomethingwithconfig(context);\n\t\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n### 三.Java内存模型\n\n在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。\n\n在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n\ti  = 10;\n\t\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\n\n1. 原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n\tx = 10;         //语句1\n\ty = x;         //语句2\n\tx++;           //语句3\n\tx = x + 1;     //语句4\n\t\n咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n2. 可见性\n\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n\n* 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n\n\n* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n\n* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n\n* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n\n* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n\n* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条原则摘自《深入理解Java虚拟机》。\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n### 四.深入剖析volatile关键字\n\n在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。\n\n1. volatile关键字的两层语义\n\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n* 禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n\t//线程1\n\tboolean stop = false;\n\twhile(!stop){\n\t    doSomething();\n\t}\n\t \n\t//线程2\n\tstop = true;\n\t\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n* 第一，使用volatile关键字会强制将修改的值立即写入主存；\n\n* 第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n* 第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2. volatile保证原子性吗？\n\n从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n\n下面看一个例子：\n\n\tpublic class Test {\n\t    public volatile int inc = 0;\n\t \n\t    public void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n\t\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n采用synchronized：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t \n\t    public synchronized void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用Lock：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t    Lock lock = new ReentrantLock();\n\t \n\t    public  void increase() {\n\t        lock.lock();\n\t        try {\n\t            inc++;\n\t        } finally{\n\t            lock.unlock();\n\t        }\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用AtomicInteger：\n\n\tpublic class Test {\n\t    public  AtomicInteger inc = new AtomicInteger();\n\t \n\t    public  void increase() {\n\t        inc.getAndIncrement();\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3. volatile能保证有序性吗？\n\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n\t//x、y为非volatile变量\n\t//flag为volatile变量\n\t \n\tx = 2;        //语句1\n\ty = 0;        //语句2\n\tflag = true;  //语句3\n\tx = 4;         //语句4\n\ty = -1;       //语句5\n\t\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n4. volatile的原理和实现机制\n\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n下面这段话摘自《深入理解Java虚拟机》：\n\n“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n\n  1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n\n  2. 它会强制将对缓存的修改操作立即写入主存；\n\n  3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n  \n### 五.使用volatile关键字的场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n  * 对变量的写操作不依赖于当前值\n\n  * 该变量没有包含在具有其他变量的不变式中\n\n实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n\n事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n\n下面列举几个Java中使用volatile的几个场景。\n\n1. 状态标记量\n\n\t\tvolatile boolean flag = false;\n\t\t \n\t\twhile(!flag){\n\t\t    doSomething();\n\t\t}\n\t\t \n\t\tpublic void setFlag() {\n\t\t    flag = true;\n\t\t}\n\t\t\n\t\tvolatile boolean inited = false;\n\t\t//线程1:\n\t\tcontext = loadContext();  \n\t\tinited = true;            \n\t\t \n\t\t//线程2:\n\t\twhile(!inited ){\n\t\tsleep()\n\t\t}\n\t\tdoSomethingwithconfig(context);\n\t\t\n2. double check\n\n\t\tclass Singleton{\n\t\t    private volatile static Singleton instance = null;\n\t\t \n\t\t    private Singleton() {\n\t\t \n\t\t    }\n\t\t \n\t\t    public static Singleton getInstance() {\n\t\t        if(instance==null) {\n\t\t            synchronized (Singleton.class) {\n\t\t                if(instance==null)\n\t\t                    instance = new Singleton();\n\t\t            }\n\t\t        }\n\t\t        return instance;\n\t\t    }\n\t\t}\n\t\t\n为什么要用volatile修饰instance?\n\n主要在于ImportNew\n首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源\n你真的了解volatile关键字吗？\n2017/04/01 | 分类： 基础技术 | 6 条评论 | 标签： VOLATILE\n\n分享到： 35\n原文出处： Ruheng\n一、Java内存模型\n想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。\n\nJava内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n\n基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n1\ni  = 10++;\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。\n\n最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n那么如何确保共享变量在多线程访问时能够正确输出结果呢？\n\n在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。\n\n二、原子性\n1.定义\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n2.实例\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n1\ni = 9;\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n3.Java中的原子性\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n1\n2\n3\n4\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解\n\n三、可见性\n1.定义\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n2.实例\n举个简单的例子，看下面这段代码：\n\n1\n2\n3\n4\n5\n6\n//线程1执行的代码\nint i = 0;\ni = 10;\n \n//线程2执行的代码\nj = i;\n由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3.Java中的可见性\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n四、有序性\n1.定义\n有序性：即程序执行的顺序按照代码的先后顺序执行。\n\n2.实例\n举个简单的例子，看下面这段代码：\n\n1\n2\n3\n4\n5\n6\nint i = 0;              \n \nboolean flag = false;\n \ni = 1;                //语句1  \nflag = true;          //语句2\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n1\n2\n3\n4\nint a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n\n那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3\n\n不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n\n虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n//线程1:\n \ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n //线程2:\nwhile(!inited ){\n   sleep()\n}\ndoSomethingwithconfig(context);\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n3.Java中的有序性\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作\n\n③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n五、深入理解volatile关键字\n1.volatile保证可见性\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n2）禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n1\n2\n3\n4\n5\n6\n7\n8\n//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n \n//线程2\nstop = true;\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n第一：使用volatile关键字会强制将修改的值立即写入主存；\n\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2.volatile不能确保原子性\n下面看一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\npublic class Test {\n    public volatile int inc = 0;\n \n    public void increase() {\n        inc++;\n    }\n \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n \n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。\n\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3.volatile保证有序性\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n//x、y为非volatile变量\n//flag为volatile变量\n \nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\n\n并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。\n\n那么我们回到前面举的一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n//线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n六、volatile的实现原理\n1.可见性\n处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。\n\n如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。\n\n但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。\n\n2.有序性\nLock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n七、volatile的应用场景\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n1）对变量的写操作不依赖于当前值\n\n2）该变量没有包含在具有其他变量的不变式中\n\n下面列举几个Java中使用volatile的几个场景。\n\n①.状态标记量\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvolatile boolean flag = false;\n //线程1\nwhile(!flag){\n    doSomething();\n}\n  //线程2\npublic void setFlag() {\n    flag = true;\n}\n根据状态标记，终止线程。\n\n②.单例模式中的double check\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n为什么要使用volatile 修饰instance？\n\n主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:\n\n1.给 instance 分配内存\n\n2.调用 Singleton 的构造函数来初始化成员变量\n\n3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。\n\n\t\t\n\t\t\n参考资料：\n\n《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024\n\n和http://www.iteye.com/topic/652440\n\n\n《Java编程思想》\n\n《深入理解Java虚拟机》\n\nhttp://jiangzhengjun.iteye.com/blog/652532\n\nhttp://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\n\nhttp://ifeve.com/volatile/\n\nhttp://blog.csdn.net/ccit0519/article/details/11241403\n\nhttp://blog.csdn.net/ns_code/article/details/17101369\n\nhttp://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\n\nhttp://www.cppblog.com/elva/archive/2011/01/21/139019.html\n\nhttp://ifeve.com/volatile-array-visiblity/\n\nhttp://www.bdqn.cn/news/201312/12579.shtml\n\nhttp://exploer.blog.51cto.com/7123589/1193399\n\nhttp://www.cnblogs.com/Mainz/p/3556430.html","source":"_posts/Java并发编程：volatile关键字解析.md","raw":"---\ntitle: Java并发编程：volatile关键字解析\ndate: 2017-12-08 10:28:29\ntags: [Java]\n---\n\n原文出处：http://www.cnblogs.com/dolphin0520/p/3920373.html\n### 一.内存模型的相关概念\n\n计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\n\n\ti = i + 1;\n\t\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n\n这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n\n为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n\n 1. 通过在总线加LOCK#锁的方式\n\n 2. 通过缓存一致性协议\n\n这2种方式都是硬件层面上提供的方式。\n\n在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n### 二.并发编程中的三个概念\n\n在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：\n\n1. 原子性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n\ti = 9;\n\t\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n2. 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n举个简单的例子，看下面这段代码：\n\n\t//线程1执行的代码\n\tint i = 0;\n\ti = 10;\n\t \n\t//线程2执行的代码\n\tj = i;\n\t\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3. 有序性\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\n\tint i = 0;              \n\tboolean flag = false;\n\ti = 1;                //语句1  \n\tflag = true;          //语句2\n\t\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n\tint a = 10;    //语句1\n\tint r = 2;    //语句2\n\ta = a + 3;    //语句3\n\tr = a*a;     //语句4\n\t\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n语句2  语句1  语句3  语句4\n\n那么可不可能是这个执行顺序呢：\n\n 语句2   语句1    语句4   语句3\n \n 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n \n 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n \n\t //线程1:\n\tcontext = loadContext();   //语句1\n\tinited = true;             //语句2\n\t \n\t//线程2:\n\twhile(!inited ){\n\t  sleep()\n\t}\n\tdoSomethingwithconfig(context);\n\t\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n### 三.Java内存模型\n\n在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。\n\n在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n\ti  = 10;\n\t\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\n\n1. 原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n\tx = 10;         //语句1\n\ty = x;         //语句2\n\tx++;           //语句3\n\tx = x + 1;     //语句4\n\t\n咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n2. 可见性\n\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n\n* 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n\n\n* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n\n* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n\n* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n\n* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n\n* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条原则摘自《深入理解Java虚拟机》。\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n### 四.深入剖析volatile关键字\n\n在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。\n\n1. volatile关键字的两层语义\n\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n* 禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n\t//线程1\n\tboolean stop = false;\n\twhile(!stop){\n\t    doSomething();\n\t}\n\t \n\t//线程2\n\tstop = true;\n\t\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n* 第一，使用volatile关键字会强制将修改的值立即写入主存；\n\n* 第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n* 第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2. volatile保证原子性吗？\n\n从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n\n下面看一个例子：\n\n\tpublic class Test {\n\t    public volatile int inc = 0;\n\t \n\t    public void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n\t\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n采用synchronized：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t \n\t    public synchronized void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用Lock：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t    Lock lock = new ReentrantLock();\n\t \n\t    public  void increase() {\n\t        lock.lock();\n\t        try {\n\t            inc++;\n\t        } finally{\n\t            lock.unlock();\n\t        }\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用AtomicInteger：\n\n\tpublic class Test {\n\t    public  AtomicInteger inc = new AtomicInteger();\n\t \n\t    public  void increase() {\n\t        inc.getAndIncrement();\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3. volatile能保证有序性吗？\n\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n\t//x、y为非volatile变量\n\t//flag为volatile变量\n\t \n\tx = 2;        //语句1\n\ty = 0;        //语句2\n\tflag = true;  //语句3\n\tx = 4;         //语句4\n\ty = -1;       //语句5\n\t\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n4. volatile的原理和实现机制\n\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n下面这段话摘自《深入理解Java虚拟机》：\n\n“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n\n  1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n\n  2. 它会强制将对缓存的修改操作立即写入主存；\n\n  3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n  \n### 五.使用volatile关键字的场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n  * 对变量的写操作不依赖于当前值\n\n  * 该变量没有包含在具有其他变量的不变式中\n\n实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n\n事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n\n下面列举几个Java中使用volatile的几个场景。\n\n1. 状态标记量\n\n\t\tvolatile boolean flag = false;\n\t\t \n\t\twhile(!flag){\n\t\t    doSomething();\n\t\t}\n\t\t \n\t\tpublic void setFlag() {\n\t\t    flag = true;\n\t\t}\n\t\t\n\t\tvolatile boolean inited = false;\n\t\t//线程1:\n\t\tcontext = loadContext();  \n\t\tinited = true;            \n\t\t \n\t\t//线程2:\n\t\twhile(!inited ){\n\t\tsleep()\n\t\t}\n\t\tdoSomethingwithconfig(context);\n\t\t\n2. double check\n\n\t\tclass Singleton{\n\t\t    private volatile static Singleton instance = null;\n\t\t \n\t\t    private Singleton() {\n\t\t \n\t\t    }\n\t\t \n\t\t    public static Singleton getInstance() {\n\t\t        if(instance==null) {\n\t\t            synchronized (Singleton.class) {\n\t\t                if(instance==null)\n\t\t                    instance = new Singleton();\n\t\t            }\n\t\t        }\n\t\t        return instance;\n\t\t    }\n\t\t}\n\t\t\n为什么要用volatile修饰instance?\n\n主要在于ImportNew\n首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源\n你真的了解volatile关键字吗？\n2017/04/01 | 分类： 基础技术 | 6 条评论 | 标签： VOLATILE\n\n分享到： 35\n原文出处： Ruheng\n一、Java内存模型\n想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。\n\nJava内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。\n\n\n基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n1\ni  = 10++;\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。\n\n最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n那么如何确保共享变量在多线程访问时能够正确输出结果呢？\n\n在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。\n\n二、原子性\n1.定义\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n2.实例\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n1\ni = 9;\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n3.Java中的原子性\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n1\n2\n3\n4\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解\n\n三、可见性\n1.定义\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n2.实例\n举个简单的例子，看下面这段代码：\n\n1\n2\n3\n4\n5\n6\n//线程1执行的代码\nint i = 0;\ni = 10;\n \n//线程2执行的代码\nj = i;\n由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3.Java中的可见性\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n四、有序性\n1.定义\n有序性：即程序执行的顺序按照代码的先后顺序执行。\n\n2.实例\n举个简单的例子，看下面这段代码：\n\n1\n2\n3\n4\n5\n6\nint i = 0;              \n \nboolean flag = false;\n \ni = 1;                //语句1  \nflag = true;          //语句2\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n1\n2\n3\n4\nint a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n\n那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3\n\n不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n\n虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n//线程1:\n \ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n //线程2:\nwhile(!inited ){\n   sleep()\n}\ndoSomethingwithconfig(context);\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n3.Java中的有序性\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作\n\n③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n五、深入理解volatile关键字\n1.volatile保证可见性\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n2）禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n1\n2\n3\n4\n5\n6\n7\n8\n//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n \n//线程2\nstop = true;\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n第一：使用volatile关键字会强制将修改的值立即写入主存；\n\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2.volatile不能确保原子性\n下面看一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\npublic class Test {\n    public volatile int inc = 0;\n \n    public void increase() {\n        inc++;\n    }\n \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n \n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。\n\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3.volatile保证有序性\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n//x、y为非volatile变量\n//flag为volatile变量\n \nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\n\n并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。\n\n那么我们回到前面举的一个例子：\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n//线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n六、volatile的实现原理\n1.可见性\n处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。\n\n如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。\n\n但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。\n\n2.有序性\nLock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n七、volatile的应用场景\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n1）对变量的写操作不依赖于当前值\n\n2）该变量没有包含在具有其他变量的不变式中\n\n下面列举几个Java中使用volatile的几个场景。\n\n①.状态标记量\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvolatile boolean flag = false;\n //线程1\nwhile(!flag){\n    doSomething();\n}\n  //线程2\npublic void setFlag() {\n    flag = true;\n}\n根据状态标记，终止线程。\n\n②.单例模式中的double check\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n\n\n为什么要使用volatile 修饰instance？\n\n主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:\n\n1.给 instance 分配内存\n\n2.调用 Singleton 的构造函数来初始化成员变量\n\n3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。\n\n\t\t\n\t\t\n参考资料：\n\n《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024\n\n和http://www.iteye.com/topic/652440\n\n\n《Java编程思想》\n\n《深入理解Java虚拟机》\n\nhttp://jiangzhengjun.iteye.com/blog/652532\n\nhttp://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\n\nhttp://ifeve.com/volatile/\n\nhttp://blog.csdn.net/ccit0519/article/details/11241403\n\nhttp://blog.csdn.net/ns_code/article/details/17101369\n\nhttp://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\n\nhttp://www.cppblog.com/elva/archive/2011/01/21/139019.html\n\nhttp://ifeve.com/volatile-array-visiblity/\n\nhttp://www.bdqn.cn/news/201312/12579.shtml\n\nhttp://exploer.blog.51cto.com/7123589/1193399\n\nhttp://www.cnblogs.com/Mainz/p/3556430.html","slug":"Java并发编程：volatile关键字解析","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnq001ox3c0rotb5u6m","content":"<p>原文出处：<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<h3 id=\"一-内存模型的相关概念\"><a href=\"#一-内存模型的相关概念\" class=\"headerlink\" title=\"一.内存模型的相关概念\"></a>一.内存模型的相关概念</h3><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>\n<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>\n<pre><code>i = i + 1;\n</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>\n<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>\n<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>\n<ol>\n<li><p>通过在总线加LOCK#锁的方式</p>\n</li>\n<li><p>通过缓存一致性协议</p>\n</li>\n</ol>\n<p>这2种方式都是硬件层面上提供的方式。</p>\n<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>\n<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>\n<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<h3 id=\"二-并发编程中的三个概念\"><a href=\"#二-并发编程中的三个概念\" class=\"headerlink\" title=\"二.并发编程中的三个概念\"></a>二.并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<pre><code>i = 9;\n</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>举个简单的例子，看下面这段代码：</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n\n//线程2执行的代码\nj = i;\n</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>\n<pre><code>int i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<pre><code>int a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>语句2  语句1  语句3  语句4</p>\n<p>那么可不可能是这个执行顺序呢：</p>\n<p> 语句2   语句1    语句4   语句3</p>\n<p> 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p> 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<pre><code> //线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<h3 id=\"三-Java内存模型\"><a href=\"#三-Java内存模型\" class=\"headerlink\" title=\"三.Java内存模型\"></a>三.Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>\n<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<pre><code>i  = 10;\n</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<pre><code>x = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n</ul>\n<ul>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n</ul>\n<ul>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n</ul>\n<ul>\n<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n</li>\n<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n</li>\n</ul>\n<ul>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n</ul>\n<ul>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n</ul>\n<ul>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<p>这8条原则摘自《深入理解Java虚拟机》。</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<h3 id=\"四-深入剖析volatile关键字\"><a href=\"#四-深入剖析volatile关键字\" class=\"headerlink\" title=\"四.深入剖析volatile关键字\"></a>四.深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>\n<ol>\n<li>volatile关键字的两层语义</li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n</li>\n<li><p>禁止进行指令重排序。</p>\n</li>\n</ul>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<pre><code>//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n\n//线程2\nstop = true;\n</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<ul>\n<li><p>第一，使用volatile关键字会强制将修改的值立即写入主存；</p>\n</li>\n<li><p>第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n</li>\n<li><p>第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</li>\n</ul>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<ol>\n<li>volatile保证原子性吗？</li>\n</ol>\n<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>\n<p>下面看一个例子：</p>\n<pre><code>public class Test {\n    public volatile int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>把上面的代码改成以下任何一种都可以达到效果：</p>\n<p>采用synchronized：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n\n    public synchronized void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用Lock：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n\n    public  void increase() {\n        lock.lock();\n        try {\n            inc++;\n        } finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用AtomicInteger：</p>\n<pre><code>public class Test {\n    public  AtomicInteger inc = new AtomicInteger();\n\n    public  void increase() {\n        inc.getAndIncrement();\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<ol>\n<li>volatile能保证有序性吗？</li>\n</ol>\n<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<ul>\n<li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n</li>\n<li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n</li>\n</ul>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<pre><code>//x、y为非volatile变量\n//flag为volatile变量\n\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<ol>\n<li>volatile的原理和实现机制</li>\n</ol>\n<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>\n<p>下面这段话摘自《深入理解Java虚拟机》：</p>\n<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>\n<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>\n<ol>\n<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>\n</li>\n<li><p>它会强制将对缓存的修改操作立即写入主存；</p>\n</li>\n<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>\n</li>\n</ol>\n<h3 id=\"五-使用volatile关键字的场景\"><a href=\"#五-使用volatile关键字的场景\" class=\"headerlink\" title=\"五.使用volatile关键字的场景\"></a>五.使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<ul>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ul>\n<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>\n<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<ol>\n<li><p>状态标记量</p>\n<pre><code>volatile boolean flag = false;\n\nwhile(!flag){\n    doSomething();\n}\n\npublic void setFlag() {\n    flag = true;\n}\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;            \n\n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n</code></pre></li>\n<li><p>double check</p>\n<pre><code>class Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n</code></pre></li>\n</ol>\n<p>为什么要用volatile修饰instance?</p>\n<p>主要在于ImportNew<br>首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源<br>你真的了解volatile关键字吗？<br>2017/04/01 | 分类： 基础技术 | 6 条评论 | 标签： VOLATILE</p>\n<p>分享到： 35<br>原文出处： Ruheng<br>一、Java内存模型<br>想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。</p>\n<p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>\n<p>基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<p>1<br>i  = 10++;<br>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>那么如何确保共享变量在多线程访问时能够正确输出结果呢？</p>\n<p>在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。</p>\n<p>二、原子性<br>1.定义<br>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>2.实例<br>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<p>1<br>i = 9;<br>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<p>3.Java中的原子性<br>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<p>1<br>2<br>3<br>4<br>x = 10;         //语句1<br>y = x;         //语句2<br>x++;           //语句3<br>x = x + 1;     //语句4<br>咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<p>关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解</p>\n<p>三、可见性<br>1.定义<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>2.实例<br>举个简单的例子，看下面这段代码：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>//线程1执行的代码<br>int i = 0;<br>i = 10;</p>\n<p>//线程2执行的代码<br>j = i;<br>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<p>3.Java中的可见性<br>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<p>四、有序性<br>1.定义<br>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>\n<p>2.实例<br>举个简单的例子，看下面这段代码：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>int i = 0;              </p>\n<p>boolean flag = false;</p>\n<p>i = 1;                //语句1<br>flag = true;          //语句2<br>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<p>1<br>2<br>3<br>4<br>int a = 10;    //语句1<br>int r = 2;    //语句2<br>a = a + 3;    //语句3<br>r = a*a;     //语句4<br>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3</p>\n<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>//线程1:</p>\n<p>context = loadContext();   //语句1<br>inited = true;             //语句2</p>\n<p> //线程2:<br>while(!inited ){<br>   sleep()<br>}<br>doSomethingwithconfig(context);<br>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<p>3.Java中的有序性<br>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：<br>①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>\n<p>②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p>\n<p>③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>\n<p>④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n<p>⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n<p>⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>\n<p>⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p>\n<p>⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<p>五、深入理解volatile关键字<br>1.volatile保证可见性<br>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n<p>2）禁止进行指令重排序。</p>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>//线程1<br>boolean stop = false;<br>while(!stop){<br>    doSomething();<br>}</p>\n<p>//线程2<br>stop = true;<br>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>\n<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<p>2.volatile不能确保原子性<br>下面看一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>public class Test {<br>    public volatile int inc = 0;</p>\n<pre><code>public void increase() {\n    inc++;\n}\n\npublic static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i&lt;10;i++){\n        new Thread(){\n            public void run() {\n                for(int j=0;j&lt;1000;j++)\n                    test.increase();\n            };\n        }.start();\n    }\n\n    while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n        Thread.yield();\n    System.out.println(test.inc);\n}\n</code></pre><p>}<br>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</p>\n<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<p>3.volatile保证有序性<br>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n<p>2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>//x、y为非volatile变量<br>//flag为volatile变量</p>\n<p>x = 2;        //语句1<br>y = 0;        //语句2<br>flag = true;  //语句3<br>x = 4;         //语句4<br>y = -1;       //语句5<br>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>\n<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>\n<p>那么我们回到前面举的一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>//线程1:<br>context = loadContext();   //语句1<br>inited = true;             //语句2</p>\n<p>//线程2:<br>while(!inited ){<br>  sleep()<br>}<br>doSomethingwithconfig(context);<br>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<p>六、volatile的实现原理<br>1.可见性<br>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>\n<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>\n<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>\n<p>2.有序性<br>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>\n<p>七、volatile的应用场景<br>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<p>1）对变量的写操作不依赖于当前值</p>\n<p>2）该变量没有包含在具有其他变量的不变式中</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<p>①.状态标记量</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>volatile boolean flag = false;<br> //线程1<br>while(!flag){<br>    doSomething();<br>}<br>  //线程2<br>public void setFlag() {<br>    flag = true;<br>}<br>根据状态标记，终止线程。</p>\n<p>②.单例模式中的double check</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>class Singleton{<br>    private volatile static Singleton instance = null;</p>\n<pre><code>private Singleton() {\n\n}\n\npublic static Singleton getInstance() {\n    if(instance==null) {\n        synchronized (Singleton.class) {\n            if(instance==null)\n                instance = new Singleton();\n        }\n    }\n    return instance;\n}\n</code></pre><p>}</p>\n<p>为什么要使用volatile 修饰instance？</p>\n<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>\n<p>1.给 instance 分配内存</p>\n<p>2.调用 Singleton 的构造函数来初始化成员变量</p>\n<p>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>\n<p>参考资料：</p>\n<p>《Java 中的双重检查（Double-Check）》<a href=\"http://blog.csdn.net/dl88250/article/details/5439024\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dl88250/article/details/5439024</a></p>\n<p>和<a href=\"http://www.iteye.com/topic/652440\" target=\"_blank\" rel=\"external\">http://www.iteye.com/topic/652440</a></p>\n<p>《Java编程思想》</p>\n<p>《深入理解Java虚拟机》</p>\n<p><a href=\"http://jiangzhengjun.iteye.com/blog/652532\" target=\"_blank\" rel=\"external\">http://jiangzhengjun.iteye.com/blog/652532</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>\n<p><a href=\"http://ifeve.com/volatile/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile/</a></p>\n<p><a href=\"http://blog.csdn.net/ccit0519/article/details/11241403\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>\n<p><a href=\"http://blog.csdn.net/ns_code/article/details/17101369\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ns_code/article/details/17101369</a></p>\n<p><a href=\"http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>\n<p><a href=\"http://www.cppblog.com/elva/archive/2011/01/21/139019.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>\n<p><a href=\"http://ifeve.com/volatile-array-visiblity/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile-array-visiblity/</a></p>\n<p><a href=\"http://www.bdqn.cn/news/201312/12579.shtml\" target=\"_blank\" rel=\"external\">http://www.bdqn.cn/news/201312/12579.shtml</a></p>\n<p><a href=\"http://exploer.blog.51cto.com/7123589/1193399\" target=\"_blank\" rel=\"external\">http://exploer.blog.51cto.com/7123589/1193399</a></p>\n<p><a href=\"http://www.cnblogs.com/Mainz/p/3556430.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文出处：<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<h3 id=\"一-内存模型的相关概念\"><a href=\"#一-内存模型的相关概念\" class=\"headerlink\" title=\"一.内存模型的相关概念\"></a>一.内存模型的相关概念</h3><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>\n<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>\n<pre><code>i = i + 1;\n</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>\n<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>\n<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>\n<ol>\n<li><p>通过在总线加LOCK#锁的方式</p>\n</li>\n<li><p>通过缓存一致性协议</p>\n</li>\n</ol>\n<p>这2种方式都是硬件层面上提供的方式。</p>\n<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>\n<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>\n<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<h3 id=\"二-并发编程中的三个概念\"><a href=\"#二-并发编程中的三个概念\" class=\"headerlink\" title=\"二.并发编程中的三个概念\"></a>二.并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<pre><code>i = 9;\n</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>举个简单的例子，看下面这段代码：</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n\n//线程2执行的代码\nj = i;\n</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>\n<pre><code>int i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<pre><code>int a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>语句2  语句1  语句3  语句4</p>\n<p>那么可不可能是这个执行顺序呢：</p>\n<p> 语句2   语句1    语句4   语句3</p>\n<p> 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p> 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<pre><code> //线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<h3 id=\"三-Java内存模型\"><a href=\"#三-Java内存模型\" class=\"headerlink\" title=\"三.Java内存模型\"></a>三.Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>\n<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<pre><code>i  = 10;\n</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<pre><code>x = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n</ul>\n<ul>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n</ul>\n<ul>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n</ul>\n<ul>\n<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n</li>\n<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n</li>\n</ul>\n<ul>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n</ul>\n<ul>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n</ul>\n<ul>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<p>这8条原则摘自《深入理解Java虚拟机》。</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<h3 id=\"四-深入剖析volatile关键字\"><a href=\"#四-深入剖析volatile关键字\" class=\"headerlink\" title=\"四.深入剖析volatile关键字\"></a>四.深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>\n<ol>\n<li>volatile关键字的两层语义</li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n</li>\n<li><p>禁止进行指令重排序。</p>\n</li>\n</ul>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<pre><code>//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n\n//线程2\nstop = true;\n</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<ul>\n<li><p>第一，使用volatile关键字会强制将修改的值立即写入主存；</p>\n</li>\n<li><p>第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n</li>\n<li><p>第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</li>\n</ul>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<ol>\n<li>volatile保证原子性吗？</li>\n</ol>\n<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>\n<p>下面看一个例子：</p>\n<pre><code>public class Test {\n    public volatile int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>把上面的代码改成以下任何一种都可以达到效果：</p>\n<p>采用synchronized：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n\n    public synchronized void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用Lock：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n\n    public  void increase() {\n        lock.lock();\n        try {\n            inc++;\n        } finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用AtomicInteger：</p>\n<pre><code>public class Test {\n    public  AtomicInteger inc = new AtomicInteger();\n\n    public  void increase() {\n        inc.getAndIncrement();\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<ol>\n<li>volatile能保证有序性吗？</li>\n</ol>\n<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<ul>\n<li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n</li>\n<li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n</li>\n</ul>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<pre><code>//x、y为非volatile变量\n//flag为volatile变量\n\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<ol>\n<li>volatile的原理和实现机制</li>\n</ol>\n<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>\n<p>下面这段话摘自《深入理解Java虚拟机》：</p>\n<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>\n<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>\n<ol>\n<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>\n</li>\n<li><p>它会强制将对缓存的修改操作立即写入主存；</p>\n</li>\n<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>\n</li>\n</ol>\n<h3 id=\"五-使用volatile关键字的场景\"><a href=\"#五-使用volatile关键字的场景\" class=\"headerlink\" title=\"五.使用volatile关键字的场景\"></a>五.使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<ul>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ul>\n<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>\n<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<ol>\n<li><p>状态标记量</p>\n<pre><code>volatile boolean flag = false;\n\nwhile(!flag){\n    doSomething();\n}\n\npublic void setFlag() {\n    flag = true;\n}\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;            \n\n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n</code></pre></li>\n<li><p>double check</p>\n<pre><code>class Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n</code></pre></li>\n</ol>\n<p>为什么要用volatile修饰instance?</p>\n<p>主要在于ImportNew<br>首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源<br>你真的了解volatile关键字吗？<br>2017/04/01 | 分类： 基础技术 | 6 条评论 | 标签： VOLATILE</p>\n<p>分享到： 35<br>原文出处： Ruheng<br>一、Java内存模型<br>想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。</p>\n<p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>\n<p>基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<p>1<br>i  = 10++;<br>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>那么如何确保共享变量在多线程访问时能够正确输出结果呢？</p>\n<p>在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。</p>\n<p>二、原子性<br>1.定义<br>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>2.实例<br>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<p>1<br>i = 9;<br>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<p>3.Java中的原子性<br>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<p>1<br>2<br>3<br>4<br>x = 10;         //语句1<br>y = x;         //语句2<br>x++;           //语句3<br>x = x + 1;     //语句4<br>咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<p>关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解</p>\n<p>三、可见性<br>1.定义<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>2.实例<br>举个简单的例子，看下面这段代码：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>//线程1执行的代码<br>int i = 0;<br>i = 10;</p>\n<p>//线程2执行的代码<br>j = i;<br>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<p>3.Java中的可见性<br>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<p>四、有序性<br>1.定义<br>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>\n<p>2.实例<br>举个简单的例子，看下面这段代码：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>int i = 0;              </p>\n<p>boolean flag = false;</p>\n<p>i = 1;                //语句1<br>flag = true;          //语句2<br>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<p>1<br>2<br>3<br>4<br>int a = 10;    //语句1<br>int r = 2;    //语句2<br>a = a + 3;    //语句3<br>r = a*a;     //语句4<br>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3</p>\n<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>//线程1:</p>\n<p>context = loadContext();   //语句1<br>inited = true;             //语句2</p>\n<p> //线程2:<br>while(!inited ){<br>   sleep()<br>}<br>doSomethingwithconfig(context);<br>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<p>3.Java中的有序性<br>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：<br>①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>\n<p>②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</p>\n<p>③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>\n<p>④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n<p>⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n<p>⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>\n<p>⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p>\n<p>⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<p>五、深入理解volatile关键字<br>1.volatile保证可见性<br>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n<p>2）禁止进行指令重排序。</p>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>//线程1<br>boolean stop = false;<br>while(!stop){<br>    doSomething();<br>}</p>\n<p>//线程2<br>stop = true;<br>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>\n<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<p>2.volatile不能确保原子性<br>下面看一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>public class Test {<br>    public volatile int inc = 0;</p>\n<pre><code>public void increase() {\n    inc++;\n}\n\npublic static void main(String[] args) {\n    final Test test = new Test();\n    for(int i=0;i&lt;10;i++){\n        new Thread(){\n            public void run() {\n                for(int j=0;j&lt;1000;j++)\n                    test.increase();\n            };\n        }.start();\n    }\n\n    while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n        Thread.yield();\n    System.out.println(test.inc);\n}\n</code></pre><p>}<br>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</p>\n<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<p>3.volatile保证有序性<br>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<p>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n<p>2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>//x、y为非volatile变量<br>//flag为volatile变量</p>\n<p>x = 2;        //语句1<br>y = 0;        //语句2<br>flag = true;  //语句3<br>x = 4;         //语句4<br>y = -1;       //语句5<br>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>\n<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>\n<p>那么我们回到前面举的一个例子：</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>//线程1:<br>context = loadContext();   //语句1<br>inited = true;             //语句2</p>\n<p>//线程2:<br>while(!inited ){<br>  sleep()<br>}<br>doSomethingwithconfig(context);<br>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<p>六、volatile的实现原理<br>1.可见性<br>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>\n<p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>\n<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>\n<p>2.有序性<br>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>\n<p>七、volatile的应用场景<br>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<p>1）对变量的写操作不依赖于当前值</p>\n<p>2）该变量没有包含在具有其他变量的不变式中</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<p>①.状态标记量</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>volatile boolean flag = false;<br> //线程1<br>while(!flag){<br>    doSomething();<br>}<br>  //线程2<br>public void setFlag() {<br>    flag = true;<br>}<br>根据状态标记，终止线程。</p>\n<p>②.单例模式中的double check</p>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>class Singleton{<br>    private volatile static Singleton instance = null;</p>\n<pre><code>private Singleton() {\n\n}\n\npublic static Singleton getInstance() {\n    if(instance==null) {\n        synchronized (Singleton.class) {\n            if(instance==null)\n                instance = new Singleton();\n        }\n    }\n    return instance;\n}\n</code></pre><p>}</p>\n<p>为什么要使用volatile 修饰instance？</p>\n<p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>\n<p>1.给 instance 分配内存</p>\n<p>2.调用 Singleton 的构造函数来初始化成员变量</p>\n<p>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。</p>\n<p>参考资料：</p>\n<p>《Java 中的双重检查（Double-Check）》<a href=\"http://blog.csdn.net/dl88250/article/details/5439024\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dl88250/article/details/5439024</a></p>\n<p>和<a href=\"http://www.iteye.com/topic/652440\" target=\"_blank\" rel=\"external\">http://www.iteye.com/topic/652440</a></p>\n<p>《Java编程思想》</p>\n<p>《深入理解Java虚拟机》</p>\n<p><a href=\"http://jiangzhengjun.iteye.com/blog/652532\" target=\"_blank\" rel=\"external\">http://jiangzhengjun.iteye.com/blog/652532</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>\n<p><a href=\"http://ifeve.com/volatile/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile/</a></p>\n<p><a href=\"http://blog.csdn.net/ccit0519/article/details/11241403\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>\n<p><a href=\"http://blog.csdn.net/ns_code/article/details/17101369\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ns_code/article/details/17101369</a></p>\n<p><a href=\"http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>\n<p><a href=\"http://www.cppblog.com/elva/archive/2011/01/21/139019.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>\n<p><a href=\"http://ifeve.com/volatile-array-visiblity/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile-array-visiblity/</a></p>\n<p><a href=\"http://www.bdqn.cn/news/201312/12579.shtml\" target=\"_blank\" rel=\"external\">http://www.bdqn.cn/news/201312/12579.shtml</a></p>\n<p><a href=\"http://exploer.blog.51cto.com/7123589/1193399\" target=\"_blank\" rel=\"external\">http://exploer.blog.51cto.com/7123589/1193399</a></p>\n<p><a href=\"http://www.cnblogs.com/Mainz/p/3556430.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>\n"},{"title":"LruCache源码及原理分析","date":"2018-04-19T09:02:25.000Z","_content":"\n### 一、源码及解析\n\n因为源码不多，就直接全部贴出来分析。源码及分析如下：\n\n\t/*\n\t * Copyright (C) 2011 The Android Open Source Project\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tpackage android.util;\n\t\n\timport java.util.LinkedHashMap;\n\timport java.util.Map;\n\t\n\t/**\n\t * BEGIN LAYOUTLIB CHANGE\n\t * This is a custom version that doesn't use the non standard LinkedHashMap#eldest.\n\t * END LAYOUTLIB CHANGE\n\t *\n\t * A cache that holds strong references to a limited number of values. Each time\n\t * a value is accessed, it is moved to the head of a queue. When a value is\n\t * added to a full cache, the value at the end of that queue is evicted and may\n\t * become eligible for garbage collection.\n\t *\n\t * <p>If your cached values hold resources that need to be explicitly released,\n\t * override {@link #entryRemoved}.\n\t *\n\t * <p>If a cache miss should be computed on demand for the corresponding keys,\n\t * override {@link #create}. This simplifies the calling code, allowing it to\n\t * assume a value will always be returned, even when there's a cache miss.\n\t *\n\t * <p>By default, the cache size is measured in the number of entries. Override\n\t * {@link #sizeOf} to size the cache in different units. For example, this cache\n\t * is limited to 4MiB of bitmaps:\n\t * <pre>   {@code\n\t *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n\t *   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n\t *       protected int sizeOf(String key, Bitmap value) {\n\t *           return value.getByteCount();\n\t *       }\n\t *   }}</pre>\n\t *\n\t * <p>This class is thread-safe. Perform multiple cache operations atomically by\n\t * synchronizing on the cache: <pre>   {@code\n\t *   synchronized (cache) {\n\t *     if (cache.get(key) == null) {\n\t *         cache.put(key, value);\n\t *     }\n\t *   }}</pre>\n\t *\n\t * <p>This class does not allow null to be used as a key or value. A return\n\t * value of null from {@link #get}, {@link #put} or {@link #remove} is\n\t * unambiguous: the key was not in the cache.\n\t *\n\t * <p>This class appeared in Android 3.1 (Honeycomb MR1); it's available as part\n\t * of <a href=\"http://developer.android.com/sdk/compatibility-library.html\">Android's\n\t * Support Package</a> for earlier releases.\n\t */\n\t// note: ssh \n\t//date: 20170418\n\tpublic class LruCache<K, V> {\n\t    private final LinkedHashMap<K, V> map;//存放数据的集合\n\t\n\t    /** Size of this cache in units. Not necessarily the number of elements. */\n\t    private int size;//当前LruCache的内存占用的大小\n\t    private int maxSize;//Lrucache的最大容量\n\t\n\t    private int putCount;//put的次数\n\t    private int createCount;//create的次数\n\t    private int evictionCount;//回收的次数\n\t    private int hitCount;//命中的次数\n\t    private int missCount;//丢失的次数\n\t\n\t    /**\n\t     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n\t     *     the maximum number of entries in the cache. For all other caches,\n\t     *     this is the maximum sum of the sizes of the entries in this cache.\n\t     */\n\t    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。\n\t    public LruCache(int maxSize) {\n\t        if (maxSize <= 0) {\n\t            throw new IllegalArgumentException(\"maxSize <= 0\");\n\t        }\n\t        this.maxSize = maxSize;\n\t        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序\n\t        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t    }\n\t\n\t    /**\n\t     * Sets the size of the cache.\n\t     * @param maxSize The new maximum size.\n\t     *\n\t     * @hide\n\t     */\n\t    //重置最大容量，调用trimToSize来实现\n\t    public void resize(int maxSize) {\n\t        if (maxSize <= 0) {\n\t            throw new IllegalArgumentException(\"maxSize <= 0\");\n\t        }\n\t\n\t        synchronized (this) {\n\t            this.maxSize = maxSize;\n\t        }\n\t        trimToSize(maxSize);\n\t    }\n\t\n\t    /**\n\t     * Returns the value for {@code key} if it exists in the cache or can be\n\t     * created by {@code #create}. If a value was returned, it is moved to the\n\t     * head of the queue. This returns null if a value is not cached and cannot\n\t     * be created.\n\t     */\n\t    //通过key获取元素值，如果缓存中存在的话\n\t    public final V get(K key) {\n\t        if (key == null) {\n\t            throw new NullPointerException(\"key == null\");\n\t        }\n\t\n\t        V mapValue;\n\t        synchronized (this) {\n\t            mapValue = map.get(key);\n\t            if (mapValue != null) {\n\t                hitCount++;\n\t                return mapValue;\n\t            }\n\t            missCount++;\n\t        }\n\t\n\t        /*\n\t         * Attempt to create a value. This may take a long time, and the map\n\t         * may be different when create() returns. If a conflicting value was\n\t         * added to the map while create() was working, we leave that value in\n\t         * the map and release the created value.\n\t         */\n\t        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法\n\t        V createdValue = create(key);\n\t        if (createdValue == null) {\n\t            return null;\n\t        }\n\t        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中\n\t        synchronized (this) {\n\t            createCount++;\n\t            mapValue = map.put(key, createdValue);\n\t\n\t            if (mapValue != null) {\n\t                // There was a conflict so undo that last put\n\t                map.put(key, mapValue);\n\t            } else {\n\t                size += safeSizeOf(key, createdValue);\n\t            }\n\t        }\n\t\n\t        if (mapValue != null) {\n\t            entryRemoved(false, key, createdValue, mapValue);\n\t            return mapValue;\n\t        } else {\n\t            trimToSize(maxSize);\n\t            return createdValue;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Caches {@code value} for {@code key}. The value is moved to the head of\n\t     * the queue.\n\t     *\n\t     * @return the previous value mapped by {@code key}.\n\t     */\n\t    //向缓存中添加数据\n\t    public final V put(K key, V value) {\n\t        if (key == null || value == null) {\n\t            throw new NullPointerException(\"key == null || value == null\");\n\t        }\n\t\n\t        V previous;\n\t        synchronized (this) {\n\t            putCount++;\n\t            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1\n\t            previous = map.put(key, value);//Hashmap.put()\n\t            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小\n\t                size -= safeSizeOf(key, previous);\n\t            }\n\t        }\n\t\n\t        if (previous != null) {\n\t            entryRemoved(false, key, previous, value);\n\t        }\n\t\n\t        trimToSize(maxSize);\n\t        return previous;\n\t    }\n\t\n\t    /**\n\t     * @param maxSize the maximum size of the cache before returning. May be -1\n\t     *     to evict even 0-sized elements.\n\t     */\n\t    private void trimToSize(int maxSize) {\n\t        while (true) {//开启死循环\n\t            K key;\n\t            V value;\n\t            synchronized (this) {\n\t                if (size < 0 || (map.isEmpty() && size != 0)) {\n\t                    throw new IllegalStateException(getClass().getName()\n\t                            + \".sizeOf() is reporting inconsistent results!\");\n\t                }\n\t\n\t                if (size <= maxSize) {\n\t                    break;//当已用的缓存小于最大缓存时，推出循环\n\t                }\n\t\n\t                // BEGIN LAYOUTLIB CHANGE\n\t                // get the last item in the linked list.\n\t                // This is not efficient, the goal here is to minimize the changes\n\t                // compared to the platform version.\n\t                //否则就在缓存中找到最近最少使用的元素\n\t                Map.Entry<K, V> toEvict = null;\n\t                for (Map.Entry<K, V> entry : map.entrySet()) {\n\t                    toEvict = entry;\n\t                }\n\t                // END LAYOUTLIB CHANGE\n\t\n\t                if (toEvict == null) {\n\t                    break;\n\t                }\n\t\n\t                key = toEvict.getKey();\n\t                value = toEvict.getValue();\n\t                map.remove(key);//然后删掉找到的最近最少使用的元素\n\t                size -= safeSizeOf(key, value);//减少了已使用的缓存空间\n\t                evictionCount++;\n\t            }\n\t\n\t            entryRemoved(true, key, value, null);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Removes the entry for {@code key} if it exists.\n\t     *\n\t     * @return the previous value mapped by {@code key}.\n\t     */\n\t    //删除元素\n\t    //删去元素，缩减已使用缓存值\n\t    public final V remove(K key) {\n\t        if (key == null) {\n\t            throw new NullPointerException(\"key == null\");\n\t        }\n\t\n\t        V previous;\n\t        synchronized (this) {\n\t            previous = map.remove(key);\n\t            if (previous != null) {\n\t                size -= safeSizeOf(key, previous);\n\t            }\n\t        }\n\t\n\t        if (previous != null) {\n\t            entryRemoved(false, key, previous, null);\n\t        }\n\t\n\t        return previous;\n\t    }\n\t\n\t    /**\n\t     * Called for entries that have been evicted or removed. This method is\n\t     * invoked when a value is evicted to make space, removed by a call to\n\t     * {@link #remove}, or replaced by a call to {@link #put}. The default\n\t     * implementation does nothing.\n\t     *\n\t     * <p>The method is called without synchronization: other threads may\n\t     * access the cache while this method is executing.\n\t     *\n\t     * @param evicted true if the entry is being removed to make space, false\n\t     *     if the removal was caused by a {@link #put} or {@link #remove}.\n\t     * @param newValue the new value for {@code key}, if it exists. If non-null,\n\t     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n\t     *     an eviction or a {@link #remove}.\n\t     */\n\t    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n\t\n\t    /**\n\t     * Called after a cache miss to compute a value for the corresponding key.\n\t     * Returns the computed value or null if no value can be computed. The\n\t     * default implementation returns null.\n\t     *\n\t     * <p>The method is called without synchronization: other threads may\n\t     * access the cache while this method is executing.\n\t     *\n\t     * <p>If a value for {@code key} exists in the cache when this method\n\t     * returns, the created value will be released with {@link #entryRemoved}\n\t     * and discarded. This can occur when multiple threads request the same key\n\t     * at the same time (causing multiple values to be created), or when one\n\t     * thread calls {@link #put} while another is creating a value for the same\n\t     * key.\n\t     */\n\t    protected V create(K key) {\n\t        return null;\n\t    }\n\t\n\t    private int safeSizeOf(K key, V value) {\n\t        int result = sizeOf(key, value);\n\t        if (result < 0) {\n\t            throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Returns the size of the entry for {@code key} and {@code value} in\n\t     * user-defined units.  The default implementation returns 1 so that size\n\t     * is the number of entries and max size is the maximum number of entries.\n\t     *\n\t     * <p>An entry's size must not change while it is in the cache.\n\t     */\n\t    protected int sizeOf(K key, V value) {\n\t        return 1;\n\t    }\n\t\n\t    /**\n\t     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n\t     */\n\t    public final void evictAll() {\n\t        trimToSize(-1); // -1 will evict 0-sized elements\n\t    }\n\t\n\t    /**\n\t     * For caches that do not override {@link #sizeOf}, this returns the number\n\t     * of entries in the cache. For all other caches, this returns the sum of\n\t     * the sizes of the entries in this cache.\n\t     */\n\t    public synchronized final int size() {\n\t        return size;\n\t    }\n\t\n\t    /**\n\t     * For caches that do not override {@link #sizeOf}, this returns the maximum\n\t     * number of entries in the cache. For all other caches, this returns the\n\t     * maximum sum of the sizes of the entries in this cache.\n\t     */\n\t    public synchronized final int maxSize() {\n\t        return maxSize;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #get} returned a value that was\n\t     * already present in the cache.\n\t     */\n\t    public synchronized final int hitCount() {\n\t        return hitCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #get} returned null or required a new\n\t     * value to be created.\n\t     */\n\t    public synchronized final int missCount() {\n\t        return missCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #create(Object)} returned a value.\n\t     */\n\t    public synchronized final int createCount() {\n\t        return createCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #put} was called.\n\t     */\n\t    public synchronized final int putCount() {\n\t        return putCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of values that have been evicted.\n\t     */\n\t    public synchronized final int evictionCount() {\n\t        return evictionCount;\n\t    }\n\t\n\t    /**\n\t     * Returns a copy of the current contents of the cache, ordered from least\n\t     * recently accessed to most recently accessed.\n\t     */\n\t    public synchronized final Map<K, V> snapshot() {\n\t        return new LinkedHashMap<K, V>(map);\n\t    }\n\t\n\t    @Override public synchronized final String toString() {\n\t        int accesses = hitCount + missCount;\n\t        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n\t        return String.format(\"LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]\",\n\t                maxSize, hitCount, missCount, hitPercent);\n\t    }\n\t}\n\n以上就是全部源码和分析注释。\n\n\n### 二、简单使用\n\n举个例子，图片缓存：\n\n\tprivate static class BitmapLruCache extends LruCache<String, Bitmap> {\n\t        public BitmapLruCache() {\n\t            // 构造方法传入当前应用可用最大内存的八分之一\n\t            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));\n\t        }\n\t\n\t        @Override\n\t        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写\n\t        protected int sizeOf(String key, Bitmap value) {\n\t            return value.getByteCount() / 1024;\n\t        }\n\t\n\t        @Override\n\t        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写\n\t        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap\n\t                newValue) {\n\t            super.entryRemoved(evicted, key, oldValue, newValue);\n\t        }\n\t\n\t        @Override\n\t        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作\n\t        protected Bitmap create(String key) {\n\t            return super.create(key);\n\t        }\n\t    }\n\n\n* 1.初始化\n\n\t\tLruCache<String, Bitmap> mLruCache = new BitmapLruCache();\n\t\n* 2.将图片写入缓存中\n\n\t\tmLruCache.put(key, bitmap);\n\t\t\n* 3.从缓存中读取图片\n\n\t\tmLruCache.get(key, bitmap);\n\t\t\n* 4.将图片从缓存中删除\n\n\t\tmLruCache.remove(key);\n\t\t\n\t\t\n\t\t\n使用还是很简单的。\n\n\n### 三、小结\n\nLruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?\n因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。\n\n看一下LinkedHashMap的构造方法，\n\n\t/**\n\t     * Constructs a new {@code LinkedHashMap} instance with the specified\n\t     * capacity, load factor and a flag specifying the ordering behavior.\n\t     *\n\t     * @param initialCapacity\n\t     *            the initial capacity of this hash map.\n\t     * @param loadFactor\n\t     *            the initial load factor.\n\t     * @param accessOrder\n\t     *            {@code true} if the ordering should be done based on the last\n\t     *            access (from least-recently accessed to most-recently\n\t     *            accessed), and {@code false} if the ordering should be the\n\t     *            order in which the entries were inserted.\n\t     * @throws IllegalArgumentException\n\t     *             when the capacity is less than zero or the load factor is\n\t     *             less or equal to zero.\n\t     */\n\t    public LinkedHashMap(\n\t            int initialCapacity, float loadFactor, boolean accessOrder) {\n\t        super(initialCapacity, loadFactor);\n\t        init();\n\t        this.accessOrder = accessOrder;\n\t    }\n\t    \n参数在LruCache中已经分析过了，再说一遍具体含义。\n    \ninitialCapacity：这个哈希表的初始容量\n\nloadFactor：加载因子\n\naccessOrder：true,访问顺序；false,插入顺序。\n\n\n其实很简单。\n","source":"_posts/LruCache源码及原理分析.md","raw":"---\ntitle: LruCache源码及原理分析\ndate: 2018-04-19 17:02:25\ntags: [Android进阶]\n---\n\n### 一、源码及解析\n\n因为源码不多，就直接全部贴出来分析。源码及分析如下：\n\n\t/*\n\t * Copyright (C) 2011 The Android Open Source Project\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\tpackage android.util;\n\t\n\timport java.util.LinkedHashMap;\n\timport java.util.Map;\n\t\n\t/**\n\t * BEGIN LAYOUTLIB CHANGE\n\t * This is a custom version that doesn't use the non standard LinkedHashMap#eldest.\n\t * END LAYOUTLIB CHANGE\n\t *\n\t * A cache that holds strong references to a limited number of values. Each time\n\t * a value is accessed, it is moved to the head of a queue. When a value is\n\t * added to a full cache, the value at the end of that queue is evicted and may\n\t * become eligible for garbage collection.\n\t *\n\t * <p>If your cached values hold resources that need to be explicitly released,\n\t * override {@link #entryRemoved}.\n\t *\n\t * <p>If a cache miss should be computed on demand for the corresponding keys,\n\t * override {@link #create}. This simplifies the calling code, allowing it to\n\t * assume a value will always be returned, even when there's a cache miss.\n\t *\n\t * <p>By default, the cache size is measured in the number of entries. Override\n\t * {@link #sizeOf} to size the cache in different units. For example, this cache\n\t * is limited to 4MiB of bitmaps:\n\t * <pre>   {@code\n\t *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n\t *   LruCache<String, Bitmap> bitmapCache = new LruCache<String, Bitmap>(cacheSize) {\n\t *       protected int sizeOf(String key, Bitmap value) {\n\t *           return value.getByteCount();\n\t *       }\n\t *   }}</pre>\n\t *\n\t * <p>This class is thread-safe. Perform multiple cache operations atomically by\n\t * synchronizing on the cache: <pre>   {@code\n\t *   synchronized (cache) {\n\t *     if (cache.get(key) == null) {\n\t *         cache.put(key, value);\n\t *     }\n\t *   }}</pre>\n\t *\n\t * <p>This class does not allow null to be used as a key or value. A return\n\t * value of null from {@link #get}, {@link #put} or {@link #remove} is\n\t * unambiguous: the key was not in the cache.\n\t *\n\t * <p>This class appeared in Android 3.1 (Honeycomb MR1); it's available as part\n\t * of <a href=\"http://developer.android.com/sdk/compatibility-library.html\">Android's\n\t * Support Package</a> for earlier releases.\n\t */\n\t// note: ssh \n\t//date: 20170418\n\tpublic class LruCache<K, V> {\n\t    private final LinkedHashMap<K, V> map;//存放数据的集合\n\t\n\t    /** Size of this cache in units. Not necessarily the number of elements. */\n\t    private int size;//当前LruCache的内存占用的大小\n\t    private int maxSize;//Lrucache的最大容量\n\t\n\t    private int putCount;//put的次数\n\t    private int createCount;//create的次数\n\t    private int evictionCount;//回收的次数\n\t    private int hitCount;//命中的次数\n\t    private int missCount;//丢失的次数\n\t\n\t    /**\n\t     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n\t     *     the maximum number of entries in the cache. For all other caches,\n\t     *     this is the maximum sum of the sizes of the entries in this cache.\n\t     */\n\t    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。\n\t    public LruCache(int maxSize) {\n\t        if (maxSize <= 0) {\n\t            throw new IllegalArgumentException(\"maxSize <= 0\");\n\t        }\n\t        this.maxSize = maxSize;\n\t        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序\n\t        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);\n\t    }\n\t\n\t    /**\n\t     * Sets the size of the cache.\n\t     * @param maxSize The new maximum size.\n\t     *\n\t     * @hide\n\t     */\n\t    //重置最大容量，调用trimToSize来实现\n\t    public void resize(int maxSize) {\n\t        if (maxSize <= 0) {\n\t            throw new IllegalArgumentException(\"maxSize <= 0\");\n\t        }\n\t\n\t        synchronized (this) {\n\t            this.maxSize = maxSize;\n\t        }\n\t        trimToSize(maxSize);\n\t    }\n\t\n\t    /**\n\t     * Returns the value for {@code key} if it exists in the cache or can be\n\t     * created by {@code #create}. If a value was returned, it is moved to the\n\t     * head of the queue. This returns null if a value is not cached and cannot\n\t     * be created.\n\t     */\n\t    //通过key获取元素值，如果缓存中存在的话\n\t    public final V get(K key) {\n\t        if (key == null) {\n\t            throw new NullPointerException(\"key == null\");\n\t        }\n\t\n\t        V mapValue;\n\t        synchronized (this) {\n\t            mapValue = map.get(key);\n\t            if (mapValue != null) {\n\t                hitCount++;\n\t                return mapValue;\n\t            }\n\t            missCount++;\n\t        }\n\t\n\t        /*\n\t         * Attempt to create a value. This may take a long time, and the map\n\t         * may be different when create() returns. If a conflicting value was\n\t         * added to the map while create() was working, we leave that value in\n\t         * the map and release the created value.\n\t         */\n\t        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法\n\t        V createdValue = create(key);\n\t        if (createdValue == null) {\n\t            return null;\n\t        }\n\t        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中\n\t        synchronized (this) {\n\t            createCount++;\n\t            mapValue = map.put(key, createdValue);\n\t\n\t            if (mapValue != null) {\n\t                // There was a conflict so undo that last put\n\t                map.put(key, mapValue);\n\t            } else {\n\t                size += safeSizeOf(key, createdValue);\n\t            }\n\t        }\n\t\n\t        if (mapValue != null) {\n\t            entryRemoved(false, key, createdValue, mapValue);\n\t            return mapValue;\n\t        } else {\n\t            trimToSize(maxSize);\n\t            return createdValue;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Caches {@code value} for {@code key}. The value is moved to the head of\n\t     * the queue.\n\t     *\n\t     * @return the previous value mapped by {@code key}.\n\t     */\n\t    //向缓存中添加数据\n\t    public final V put(K key, V value) {\n\t        if (key == null || value == null) {\n\t            throw new NullPointerException(\"key == null || value == null\");\n\t        }\n\t\n\t        V previous;\n\t        synchronized (this) {\n\t            putCount++;\n\t            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1\n\t            previous = map.put(key, value);//Hashmap.put()\n\t            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小\n\t                size -= safeSizeOf(key, previous);\n\t            }\n\t        }\n\t\n\t        if (previous != null) {\n\t            entryRemoved(false, key, previous, value);\n\t        }\n\t\n\t        trimToSize(maxSize);\n\t        return previous;\n\t    }\n\t\n\t    /**\n\t     * @param maxSize the maximum size of the cache before returning. May be -1\n\t     *     to evict even 0-sized elements.\n\t     */\n\t    private void trimToSize(int maxSize) {\n\t        while (true) {//开启死循环\n\t            K key;\n\t            V value;\n\t            synchronized (this) {\n\t                if (size < 0 || (map.isEmpty() && size != 0)) {\n\t                    throw new IllegalStateException(getClass().getName()\n\t                            + \".sizeOf() is reporting inconsistent results!\");\n\t                }\n\t\n\t                if (size <= maxSize) {\n\t                    break;//当已用的缓存小于最大缓存时，推出循环\n\t                }\n\t\n\t                // BEGIN LAYOUTLIB CHANGE\n\t                // get the last item in the linked list.\n\t                // This is not efficient, the goal here is to minimize the changes\n\t                // compared to the platform version.\n\t                //否则就在缓存中找到最近最少使用的元素\n\t                Map.Entry<K, V> toEvict = null;\n\t                for (Map.Entry<K, V> entry : map.entrySet()) {\n\t                    toEvict = entry;\n\t                }\n\t                // END LAYOUTLIB CHANGE\n\t\n\t                if (toEvict == null) {\n\t                    break;\n\t                }\n\t\n\t                key = toEvict.getKey();\n\t                value = toEvict.getValue();\n\t                map.remove(key);//然后删掉找到的最近最少使用的元素\n\t                size -= safeSizeOf(key, value);//减少了已使用的缓存空间\n\t                evictionCount++;\n\t            }\n\t\n\t            entryRemoved(true, key, value, null);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Removes the entry for {@code key} if it exists.\n\t     *\n\t     * @return the previous value mapped by {@code key}.\n\t     */\n\t    //删除元素\n\t    //删去元素，缩减已使用缓存值\n\t    public final V remove(K key) {\n\t        if (key == null) {\n\t            throw new NullPointerException(\"key == null\");\n\t        }\n\t\n\t        V previous;\n\t        synchronized (this) {\n\t            previous = map.remove(key);\n\t            if (previous != null) {\n\t                size -= safeSizeOf(key, previous);\n\t            }\n\t        }\n\t\n\t        if (previous != null) {\n\t            entryRemoved(false, key, previous, null);\n\t        }\n\t\n\t        return previous;\n\t    }\n\t\n\t    /**\n\t     * Called for entries that have been evicted or removed. This method is\n\t     * invoked when a value is evicted to make space, removed by a call to\n\t     * {@link #remove}, or replaced by a call to {@link #put}. The default\n\t     * implementation does nothing.\n\t     *\n\t     * <p>The method is called without synchronization: other threads may\n\t     * access the cache while this method is executing.\n\t     *\n\t     * @param evicted true if the entry is being removed to make space, false\n\t     *     if the removal was caused by a {@link #put} or {@link #remove}.\n\t     * @param newValue the new value for {@code key}, if it exists. If non-null,\n\t     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n\t     *     an eviction or a {@link #remove}.\n\t     */\n\t    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n\t\n\t    /**\n\t     * Called after a cache miss to compute a value for the corresponding key.\n\t     * Returns the computed value or null if no value can be computed. The\n\t     * default implementation returns null.\n\t     *\n\t     * <p>The method is called without synchronization: other threads may\n\t     * access the cache while this method is executing.\n\t     *\n\t     * <p>If a value for {@code key} exists in the cache when this method\n\t     * returns, the created value will be released with {@link #entryRemoved}\n\t     * and discarded. This can occur when multiple threads request the same key\n\t     * at the same time (causing multiple values to be created), or when one\n\t     * thread calls {@link #put} while another is creating a value for the same\n\t     * key.\n\t     */\n\t    protected V create(K key) {\n\t        return null;\n\t    }\n\t\n\t    private int safeSizeOf(K key, V value) {\n\t        int result = sizeOf(key, value);\n\t        if (result < 0) {\n\t            throw new IllegalStateException(\"Negative size: \" + key + \"=\" + value);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Returns the size of the entry for {@code key} and {@code value} in\n\t     * user-defined units.  The default implementation returns 1 so that size\n\t     * is the number of entries and max size is the maximum number of entries.\n\t     *\n\t     * <p>An entry's size must not change while it is in the cache.\n\t     */\n\t    protected int sizeOf(K key, V value) {\n\t        return 1;\n\t    }\n\t\n\t    /**\n\t     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n\t     */\n\t    public final void evictAll() {\n\t        trimToSize(-1); // -1 will evict 0-sized elements\n\t    }\n\t\n\t    /**\n\t     * For caches that do not override {@link #sizeOf}, this returns the number\n\t     * of entries in the cache. For all other caches, this returns the sum of\n\t     * the sizes of the entries in this cache.\n\t     */\n\t    public synchronized final int size() {\n\t        return size;\n\t    }\n\t\n\t    /**\n\t     * For caches that do not override {@link #sizeOf}, this returns the maximum\n\t     * number of entries in the cache. For all other caches, this returns the\n\t     * maximum sum of the sizes of the entries in this cache.\n\t     */\n\t    public synchronized final int maxSize() {\n\t        return maxSize;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #get} returned a value that was\n\t     * already present in the cache.\n\t     */\n\t    public synchronized final int hitCount() {\n\t        return hitCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #get} returned null or required a new\n\t     * value to be created.\n\t     */\n\t    public synchronized final int missCount() {\n\t        return missCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #create(Object)} returned a value.\n\t     */\n\t    public synchronized final int createCount() {\n\t        return createCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of times {@link #put} was called.\n\t     */\n\t    public synchronized final int putCount() {\n\t        return putCount;\n\t    }\n\t\n\t    /**\n\t     * Returns the number of values that have been evicted.\n\t     */\n\t    public synchronized final int evictionCount() {\n\t        return evictionCount;\n\t    }\n\t\n\t    /**\n\t     * Returns a copy of the current contents of the cache, ordered from least\n\t     * recently accessed to most recently accessed.\n\t     */\n\t    public synchronized final Map<K, V> snapshot() {\n\t        return new LinkedHashMap<K, V>(map);\n\t    }\n\t\n\t    @Override public synchronized final String toString() {\n\t        int accesses = hitCount + missCount;\n\t        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n\t        return String.format(\"LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]\",\n\t                maxSize, hitCount, missCount, hitPercent);\n\t    }\n\t}\n\n以上就是全部源码和分析注释。\n\n\n### 二、简单使用\n\n举个例子，图片缓存：\n\n\tprivate static class BitmapLruCache extends LruCache<String, Bitmap> {\n\t        public BitmapLruCache() {\n\t            // 构造方法传入当前应用可用最大内存的八分之一\n\t            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));\n\t        }\n\t\n\t        @Override\n\t        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写\n\t        protected int sizeOf(String key, Bitmap value) {\n\t            return value.getByteCount() / 1024;\n\t        }\n\t\n\t        @Override\n\t        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写\n\t        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap\n\t                newValue) {\n\t            super.entryRemoved(evicted, key, oldValue, newValue);\n\t        }\n\t\n\t        @Override\n\t        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作\n\t        protected Bitmap create(String key) {\n\t            return super.create(key);\n\t        }\n\t    }\n\n\n* 1.初始化\n\n\t\tLruCache<String, Bitmap> mLruCache = new BitmapLruCache();\n\t\n* 2.将图片写入缓存中\n\n\t\tmLruCache.put(key, bitmap);\n\t\t\n* 3.从缓存中读取图片\n\n\t\tmLruCache.get(key, bitmap);\n\t\t\n* 4.将图片从缓存中删除\n\n\t\tmLruCache.remove(key);\n\t\t\n\t\t\n\t\t\n使用还是很简单的。\n\n\n### 三、小结\n\nLruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?\n因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。\n\n看一下LinkedHashMap的构造方法，\n\n\t/**\n\t     * Constructs a new {@code LinkedHashMap} instance with the specified\n\t     * capacity, load factor and a flag specifying the ordering behavior.\n\t     *\n\t     * @param initialCapacity\n\t     *            the initial capacity of this hash map.\n\t     * @param loadFactor\n\t     *            the initial load factor.\n\t     * @param accessOrder\n\t     *            {@code true} if the ordering should be done based on the last\n\t     *            access (from least-recently accessed to most-recently\n\t     *            accessed), and {@code false} if the ordering should be the\n\t     *            order in which the entries were inserted.\n\t     * @throws IllegalArgumentException\n\t     *             when the capacity is less than zero or the load factor is\n\t     *             less or equal to zero.\n\t     */\n\t    public LinkedHashMap(\n\t            int initialCapacity, float loadFactor, boolean accessOrder) {\n\t        super(initialCapacity, loadFactor);\n\t        init();\n\t        this.accessOrder = accessOrder;\n\t    }\n\t    \n参数在LruCache中已经分析过了，再说一遍具体含义。\n    \ninitialCapacity：这个哈希表的初始容量\n\nloadFactor：加载因子\n\naccessOrder：true,访问顺序；false,插入顺序。\n\n\n其实很简单。\n","slug":"LruCache源码及原理分析","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnr001qx3c0xmxiqthj","content":"<h3 id=\"一、源码及解析\"><a href=\"#一、源码及解析\" class=\"headerlink\" title=\"一、源码及解析\"></a>一、源码及解析</h3><p>因为源码不多，就直接全部贴出来分析。源码及分析如下：</p>\n<pre><code>/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.util;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * BEGIN LAYOUTLIB CHANGE\n * This is a custom version that doesn&apos;t use the non standard LinkedHashMap#eldest.\n * END LAYOUTLIB CHANGE\n *\n * A cache that holds strong references to a limited number of values. Each time\n * a value is accessed, it is moved to the head of a queue. When a value is\n * added to a full cache, the value at the end of that queue is evicted and may\n * become eligible for garbage collection.\n *\n * &lt;p&gt;If your cached values hold resources that need to be explicitly released,\n * override {@link #entryRemoved}.\n *\n * &lt;p&gt;If a cache miss should be computed on demand for the corresponding keys,\n * override {@link #create}. This simplifies the calling code, allowing it to\n * assume a value will always be returned, even when there&apos;s a cache miss.\n *\n * &lt;p&gt;By default, the cache size is measured in the number of entries. Override\n * {@link #sizeOf} to size the cache in different units. For example, this cache\n * is limited to 4MiB of bitmaps:\n * &lt;pre&gt;   {@code\n *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n *   LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {\n *       protected int sizeOf(String key, Bitmap value) {\n *           return value.getByteCount();\n *       }\n *   }}&lt;/pre&gt;\n *\n * &lt;p&gt;This class is thread-safe. Perform multiple cache operations atomically by\n * synchronizing on the cache: &lt;pre&gt;   {@code\n *   synchronized (cache) {\n *     if (cache.get(key) == null) {\n *         cache.put(key, value);\n *     }\n *   }}&lt;/pre&gt;\n *\n * &lt;p&gt;This class does not allow null to be used as a key or value. A return\n * value of null from {@link #get}, {@link #put} or {@link #remove} is\n * unambiguous: the key was not in the cache.\n *\n * &lt;p&gt;This class appeared in Android 3.1 (Honeycomb MR1); it&apos;s available as part\n * of &lt;a href=&quot;http://developer.android.com/sdk/compatibility-library.html&quot;&gt;Android&apos;s\n * Support Package&lt;/a&gt; for earlier releases.\n */\n// note: ssh \n//date: 20170418\npublic class LruCache&lt;K, V&gt; {\n    private final LinkedHashMap&lt;K, V&gt; map;//存放数据的集合\n\n    /** Size of this cache in units. Not necessarily the number of elements. */\n    private int size;//当前LruCache的内存占用的大小\n    private int maxSize;//Lrucache的最大容量\n\n    private int putCount;//put的次数\n    private int createCount;//create的次数\n    private int evictionCount;//回收的次数\n    private int hitCount;//命中的次数\n    private int missCount;//丢失的次数\n\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *     the maximum number of entries in the cache. For all other caches,\n     *     this is the maximum sum of the sizes of the entries in this cache.\n     */\n    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。\n    public LruCache(int maxSize) {\n        if (maxSize &lt;= 0) {\n            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);\n        }\n        this.maxSize = maxSize;\n        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序\n        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);\n    }\n\n    /**\n     * Sets the size of the cache.\n     * @param maxSize The new maximum size.\n     *\n     * @hide\n     */\n    //重置最大容量，调用trimToSize来实现\n    public void resize(int maxSize) {\n        if (maxSize &lt;= 0) {\n            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);\n        }\n\n        synchronized (this) {\n            this.maxSize = maxSize;\n        }\n        trimToSize(maxSize);\n    }\n\n    /**\n     * Returns the value for {@code key} if it exists in the cache or can be\n     * created by {@code #create}. If a value was returned, it is moved to the\n     * head of the queue. This returns null if a value is not cached and cannot\n     * be created.\n     */\n    //通过key获取元素值，如果缓存中存在的话\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(&quot;key == null&quot;);\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n\n    /**\n     * Caches {@code value} for {@code key}. The value is moved to the head of\n     * the queue.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    //向缓存中添加数据\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(&quot;key == null || value == null&quot;);\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1\n            previous = map.put(key, value);//Hashmap.put()\n            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n\n    /**\n     * @param maxSize the maximum size of the cache before returning. May be -1\n     *     to evict even 0-sized elements.\n     */\n    private void trimToSize(int maxSize) {\n        while (true) {//开启死循环\n            K key;\n            V value;\n            synchronized (this) {\n                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);\n                }\n\n                if (size &lt;= maxSize) {\n                    break;//当已用的缓存小于最大缓存时，推出循环\n                }\n\n                // BEGIN LAYOUTLIB CHANGE\n                // get the last item in the linked list.\n                // This is not efficient, the goal here is to minimize the changes\n                // compared to the platform version.\n                //否则就在缓存中找到最近最少使用的元素\n                Map.Entry&lt;K, V&gt; toEvict = null;\n                for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {\n                    toEvict = entry;\n                }\n                // END LAYOUTLIB CHANGE\n\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);//然后删掉找到的最近最少使用的元素\n                size -= safeSizeOf(key, value);//减少了已使用的缓存空间\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n\n    /**\n     * Removes the entry for {@code key} if it exists.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    //删除元素\n    //删去元素，缩减已使用缓存值\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(&quot;key == null&quot;);\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n\n    /**\n     * Called for entries that have been evicted or removed. This method is\n     * invoked when a value is evicted to make space, removed by a call to\n     * {@link #remove}, or replaced by a call to {@link #put}. The default\n     * implementation does nothing.\n     *\n     * &lt;p&gt;The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * @param evicted true if the entry is being removed to make space, false\n     *     if the removal was caused by a {@link #put} or {@link #remove}.\n     * @param newValue the new value for {@code key}, if it exists. If non-null,\n     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n     *     an eviction or a {@link #remove}.\n     */\n    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n\n    /**\n     * Called after a cache miss to compute a value for the corresponding key.\n     * Returns the computed value or null if no value can be computed. The\n     * default implementation returns null.\n     *\n     * &lt;p&gt;The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * &lt;p&gt;If a value for {@code key} exists in the cache when this method\n     * returns, the created value will be released with {@link #entryRemoved}\n     * and discarded. This can occur when multiple threads request the same key\n     * at the same time (causing multiple values to be created), or when one\n     * thread calls {@link #put} while another is creating a value for the same\n     * key.\n     */\n    protected V create(K key) {\n        return null;\n    }\n\n    private int safeSizeOf(K key, V value) {\n        int result = sizeOf(key, value);\n        if (result &lt; 0) {\n            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the size of the entry for {@code key} and {@code value} in\n     * user-defined units.  The default implementation returns 1 so that size\n     * is the number of entries and max size is the maximum number of entries.\n     *\n     * &lt;p&gt;An entry&apos;s size must not change while it is in the cache.\n     */\n    protected int sizeOf(K key, V value) {\n        return 1;\n    }\n\n    /**\n     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n     */\n    public final void evictAll() {\n        trimToSize(-1); // -1 will evict 0-sized elements\n    }\n\n    /**\n     * For caches that do not override {@link #sizeOf}, this returns the number\n     * of entries in the cache. For all other caches, this returns the sum of\n     * the sizes of the entries in this cache.\n     */\n    public synchronized final int size() {\n        return size;\n    }\n\n    /**\n     * For caches that do not override {@link #sizeOf}, this returns the maximum\n     * number of entries in the cache. For all other caches, this returns the\n     * maximum sum of the sizes of the entries in this cache.\n     */\n    public synchronized final int maxSize() {\n        return maxSize;\n    }\n\n    /**\n     * Returns the number of times {@link #get} returned a value that was\n     * already present in the cache.\n     */\n    public synchronized final int hitCount() {\n        return hitCount;\n    }\n\n    /**\n     * Returns the number of times {@link #get} returned null or required a new\n     * value to be created.\n     */\n    public synchronized final int missCount() {\n        return missCount;\n    }\n\n    /**\n     * Returns the number of times {@link #create(Object)} returned a value.\n     */\n    public synchronized final int createCount() {\n        return createCount;\n    }\n\n    /**\n     * Returns the number of times {@link #put} was called.\n     */\n    public synchronized final int putCount() {\n        return putCount;\n    }\n\n    /**\n     * Returns the number of values that have been evicted.\n     */\n    public synchronized final int evictionCount() {\n        return evictionCount;\n    }\n\n    /**\n     * Returns a copy of the current contents of the cache, ordered from least\n     * recently accessed to most recently accessed.\n     */\n    public synchronized final Map&lt;K, V&gt; snapshot() {\n        return new LinkedHashMap&lt;K, V&gt;(map);\n    }\n\n    @Override public synchronized final String toString() {\n        int accesses = hitCount + missCount;\n        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n        return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,\n                maxSize, hitCount, missCount, hitPercent);\n    }\n}\n</code></pre><p>以上就是全部源码和分析注释。</p>\n<h3 id=\"二、简单使用\"><a href=\"#二、简单使用\" class=\"headerlink\" title=\"二、简单使用\"></a>二、简单使用</h3><p>举个例子，图片缓存：</p>\n<pre><code>private static class BitmapLruCache extends LruCache&lt;String, Bitmap&gt; {\n        public BitmapLruCache() {\n            // 构造方法传入当前应用可用最大内存的八分之一\n            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));\n        }\n\n        @Override\n        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount() / 1024;\n        }\n\n        @Override\n        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写\n        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap\n                newValue) {\n            super.entryRemoved(evicted, key, oldValue, newValue);\n        }\n\n        @Override\n        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作\n        protected Bitmap create(String key) {\n            return super.create(key);\n        }\n    }\n</code></pre><ul>\n<li><p>1.初始化</p>\n<pre><code>LruCache&lt;String, Bitmap&gt; mLruCache = new BitmapLruCache();\n</code></pre></li>\n<li><p>2.将图片写入缓存中</p>\n<pre><code>mLruCache.put(key, bitmap);\n</code></pre></li>\n<li><p>3.从缓存中读取图片</p>\n<pre><code>mLruCache.get(key, bitmap);\n</code></pre></li>\n<li><p>4.将图片从缓存中删除</p>\n<pre><code>mLruCache.remove(key);\n</code></pre></li>\n</ul>\n<p>使用还是很简单的。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>LruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?<br>因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。</p>\n<p>看一下LinkedHashMap的构造方法，</p>\n<pre><code>/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n</code></pre><p>参数在LruCache中已经分析过了，再说一遍具体含义。</p>\n<p>initialCapacity：这个哈希表的初始容量</p>\n<p>loadFactor：加载因子</p>\n<p>accessOrder：true,访问顺序；false,插入顺序。</p>\n<p>其实很简单。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、源码及解析\"><a href=\"#一、源码及解析\" class=\"headerlink\" title=\"一、源码及解析\"></a>一、源码及解析</h3><p>因为源码不多，就直接全部贴出来分析。源码及分析如下：</p>\n<pre><code>/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.util;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * BEGIN LAYOUTLIB CHANGE\n * This is a custom version that doesn&apos;t use the non standard LinkedHashMap#eldest.\n * END LAYOUTLIB CHANGE\n *\n * A cache that holds strong references to a limited number of values. Each time\n * a value is accessed, it is moved to the head of a queue. When a value is\n * added to a full cache, the value at the end of that queue is evicted and may\n * become eligible for garbage collection.\n *\n * &lt;p&gt;If your cached values hold resources that need to be explicitly released,\n * override {@link #entryRemoved}.\n *\n * &lt;p&gt;If a cache miss should be computed on demand for the corresponding keys,\n * override {@link #create}. This simplifies the calling code, allowing it to\n * assume a value will always be returned, even when there&apos;s a cache miss.\n *\n * &lt;p&gt;By default, the cache size is measured in the number of entries. Override\n * {@link #sizeOf} to size the cache in different units. For example, this cache\n * is limited to 4MiB of bitmaps:\n * &lt;pre&gt;   {@code\n *   int cacheSize = 4 * 1024 * 1024; // 4MiB\n *   LruCache&lt;String, Bitmap&gt; bitmapCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {\n *       protected int sizeOf(String key, Bitmap value) {\n *           return value.getByteCount();\n *       }\n *   }}&lt;/pre&gt;\n *\n * &lt;p&gt;This class is thread-safe. Perform multiple cache operations atomically by\n * synchronizing on the cache: &lt;pre&gt;   {@code\n *   synchronized (cache) {\n *     if (cache.get(key) == null) {\n *         cache.put(key, value);\n *     }\n *   }}&lt;/pre&gt;\n *\n * &lt;p&gt;This class does not allow null to be used as a key or value. A return\n * value of null from {@link #get}, {@link #put} or {@link #remove} is\n * unambiguous: the key was not in the cache.\n *\n * &lt;p&gt;This class appeared in Android 3.1 (Honeycomb MR1); it&apos;s available as part\n * of &lt;a href=&quot;http://developer.android.com/sdk/compatibility-library.html&quot;&gt;Android&apos;s\n * Support Package&lt;/a&gt; for earlier releases.\n */\n// note: ssh \n//date: 20170418\npublic class LruCache&lt;K, V&gt; {\n    private final LinkedHashMap&lt;K, V&gt; map;//存放数据的集合\n\n    /** Size of this cache in units. Not necessarily the number of elements. */\n    private int size;//当前LruCache的内存占用的大小\n    private int maxSize;//Lrucache的最大容量\n\n    private int putCount;//put的次数\n    private int createCount;//create的次数\n    private int evictionCount;//回收的次数\n    private int hitCount;//命中的次数\n    private int missCount;//丢失的次数\n\n    /**\n     * @param maxSize for caches that do not override {@link #sizeOf}, this is\n     *     the maximum number of entries in the cache. For all other caches,\n     *     this is the maximum sum of the sizes of the entries in this cache.\n     */\n    //构造函数，在这里设置maxsize,并且实例化一个LinkedHashMap.LinkedHashMap是LruCache的核心。\n    public LruCache(int maxSize) {\n        if (maxSize &lt;= 0) {\n            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);\n        }\n        this.maxSize = maxSize;\n        //初始容量为0，加载因子是0.75f即当容量达到最大容量的0.75时会把内存增加一半，accessOrder 为true：访问顺序，false:插入顺序\n        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);\n    }\n\n    /**\n     * Sets the size of the cache.\n     * @param maxSize The new maximum size.\n     *\n     * @hide\n     */\n    //重置最大容量，调用trimToSize来实现\n    public void resize(int maxSize) {\n        if (maxSize &lt;= 0) {\n            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);\n        }\n\n        synchronized (this) {\n            this.maxSize = maxSize;\n        }\n        trimToSize(maxSize);\n    }\n\n    /**\n     * Returns the value for {@code key} if it exists in the cache or can be\n     * created by {@code #create}. If a value was returned, it is moved to the\n     * head of the queue. This returns null if a value is not cached and cannot\n     * be created.\n     */\n    //通过key获取元素值，如果缓存中存在的话\n    public final V get(K key) {\n        if (key == null) {\n            throw new NullPointerException(&quot;key == null&quot;);\n        }\n\n        V mapValue;\n        synchronized (this) {\n            mapValue = map.get(key);\n            if (mapValue != null) {\n                hitCount++;\n                return mapValue;\n            }\n            missCount++;\n        }\n\n        /*\n         * Attempt to create a value. This may take a long time, and the map\n         * may be different when create() returns. If a conflicting value was\n         * added to the map while create() was working, we leave that value in\n         * the map and release the created value.\n         */\n        //如果值不存在，那么就通过create（key）来创建一个，create(key)默认是返回null.如果需要自定义可重写这个方法\n        V createdValue = create(key);\n        if (createdValue == null) {\n            return null;\n        }\n        //如果重写了create(key)，返回并不为null,即创建了新的数据，那么就会将数据放进缓存中\n        synchronized (this) {\n            createCount++;\n            mapValue = map.put(key, createdValue);\n\n            if (mapValue != null) {\n                // There was a conflict so undo that last put\n                map.put(key, mapValue);\n            } else {\n                size += safeSizeOf(key, createdValue);\n            }\n        }\n\n        if (mapValue != null) {\n            entryRemoved(false, key, createdValue, mapValue);\n            return mapValue;\n        } else {\n            trimToSize(maxSize);\n            return createdValue;\n        }\n    }\n\n    /**\n     * Caches {@code value} for {@code key}. The value is moved to the head of\n     * the queue.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    //向缓存中添加数据\n    public final V put(K key, V value) {\n        if (key == null || value == null) {\n            throw new NullPointerException(&quot;key == null || value == null&quot;);\n        }\n\n        V previous;\n        synchronized (this) {\n            putCount++;\n            size += safeSizeOf(key, value);//safeSizeOf(key, value)会调用SizeOf(key, value)，返回的值为1\n            previous = map.put(key, value);//Hashmap.put()\n            if (previous != null) {//如果不为null,即添加失败，需要在缓存中减去这个元素，重置大小\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, value);\n        }\n\n        trimToSize(maxSize);\n        return previous;\n    }\n\n    /**\n     * @param maxSize the maximum size of the cache before returning. May be -1\n     *     to evict even 0-sized elements.\n     */\n    private void trimToSize(int maxSize) {\n        while (true) {//开启死循环\n            K key;\n            V value;\n            synchronized (this) {\n                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {\n                    throw new IllegalStateException(getClass().getName()\n                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);\n                }\n\n                if (size &lt;= maxSize) {\n                    break;//当已用的缓存小于最大缓存时，推出循环\n                }\n\n                // BEGIN LAYOUTLIB CHANGE\n                // get the last item in the linked list.\n                // This is not efficient, the goal here is to minimize the changes\n                // compared to the platform version.\n                //否则就在缓存中找到最近最少使用的元素\n                Map.Entry&lt;K, V&gt; toEvict = null;\n                for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {\n                    toEvict = entry;\n                }\n                // END LAYOUTLIB CHANGE\n\n                if (toEvict == null) {\n                    break;\n                }\n\n                key = toEvict.getKey();\n                value = toEvict.getValue();\n                map.remove(key);//然后删掉找到的最近最少使用的元素\n                size -= safeSizeOf(key, value);//减少了已使用的缓存空间\n                evictionCount++;\n            }\n\n            entryRemoved(true, key, value, null);\n        }\n    }\n\n    /**\n     * Removes the entry for {@code key} if it exists.\n     *\n     * @return the previous value mapped by {@code key}.\n     */\n    //删除元素\n    //删去元素，缩减已使用缓存值\n    public final V remove(K key) {\n        if (key == null) {\n            throw new NullPointerException(&quot;key == null&quot;);\n        }\n\n        V previous;\n        synchronized (this) {\n            previous = map.remove(key);\n            if (previous != null) {\n                size -= safeSizeOf(key, previous);\n            }\n        }\n\n        if (previous != null) {\n            entryRemoved(false, key, previous, null);\n        }\n\n        return previous;\n    }\n\n    /**\n     * Called for entries that have been evicted or removed. This method is\n     * invoked when a value is evicted to make space, removed by a call to\n     * {@link #remove}, or replaced by a call to {@link #put}. The default\n     * implementation does nothing.\n     *\n     * &lt;p&gt;The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * @param evicted true if the entry is being removed to make space, false\n     *     if the removal was caused by a {@link #put} or {@link #remove}.\n     * @param newValue the new value for {@code key}, if it exists. If non-null,\n     *     this removal was caused by a {@link #put}. Otherwise it was caused by\n     *     an eviction or a {@link #remove}.\n     */\n    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}\n\n    /**\n     * Called after a cache miss to compute a value for the corresponding key.\n     * Returns the computed value or null if no value can be computed. The\n     * default implementation returns null.\n     *\n     * &lt;p&gt;The method is called without synchronization: other threads may\n     * access the cache while this method is executing.\n     *\n     * &lt;p&gt;If a value for {@code key} exists in the cache when this method\n     * returns, the created value will be released with {@link #entryRemoved}\n     * and discarded. This can occur when multiple threads request the same key\n     * at the same time (causing multiple values to be created), or when one\n     * thread calls {@link #put} while another is creating a value for the same\n     * key.\n     */\n    protected V create(K key) {\n        return null;\n    }\n\n    private int safeSizeOf(K key, V value) {\n        int result = sizeOf(key, value);\n        if (result &lt; 0) {\n            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the size of the entry for {@code key} and {@code value} in\n     * user-defined units.  The default implementation returns 1 so that size\n     * is the number of entries and max size is the maximum number of entries.\n     *\n     * &lt;p&gt;An entry&apos;s size must not change while it is in the cache.\n     */\n    protected int sizeOf(K key, V value) {\n        return 1;\n    }\n\n    /**\n     * Clear the cache, calling {@link #entryRemoved} on each removed entry.\n     */\n    public final void evictAll() {\n        trimToSize(-1); // -1 will evict 0-sized elements\n    }\n\n    /**\n     * For caches that do not override {@link #sizeOf}, this returns the number\n     * of entries in the cache. For all other caches, this returns the sum of\n     * the sizes of the entries in this cache.\n     */\n    public synchronized final int size() {\n        return size;\n    }\n\n    /**\n     * For caches that do not override {@link #sizeOf}, this returns the maximum\n     * number of entries in the cache. For all other caches, this returns the\n     * maximum sum of the sizes of the entries in this cache.\n     */\n    public synchronized final int maxSize() {\n        return maxSize;\n    }\n\n    /**\n     * Returns the number of times {@link #get} returned a value that was\n     * already present in the cache.\n     */\n    public synchronized final int hitCount() {\n        return hitCount;\n    }\n\n    /**\n     * Returns the number of times {@link #get} returned null or required a new\n     * value to be created.\n     */\n    public synchronized final int missCount() {\n        return missCount;\n    }\n\n    /**\n     * Returns the number of times {@link #create(Object)} returned a value.\n     */\n    public synchronized final int createCount() {\n        return createCount;\n    }\n\n    /**\n     * Returns the number of times {@link #put} was called.\n     */\n    public synchronized final int putCount() {\n        return putCount;\n    }\n\n    /**\n     * Returns the number of values that have been evicted.\n     */\n    public synchronized final int evictionCount() {\n        return evictionCount;\n    }\n\n    /**\n     * Returns a copy of the current contents of the cache, ordered from least\n     * recently accessed to most recently accessed.\n     */\n    public synchronized final Map&lt;K, V&gt; snapshot() {\n        return new LinkedHashMap&lt;K, V&gt;(map);\n    }\n\n    @Override public synchronized final String toString() {\n        int accesses = hitCount + missCount;\n        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;\n        return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,\n                maxSize, hitCount, missCount, hitPercent);\n    }\n}\n</code></pre><p>以上就是全部源码和分析注释。</p>\n<h3 id=\"二、简单使用\"><a href=\"#二、简单使用\" class=\"headerlink\" title=\"二、简单使用\"></a>二、简单使用</h3><p>举个例子，图片缓存：</p>\n<pre><code>private static class BitmapLruCache extends LruCache&lt;String, Bitmap&gt; {\n        public BitmapLruCache() {\n            // 构造方法传入当前应用可用最大内存的八分之一\n            super((int) (Runtime.getRuntime().maxMemory() / 1024 / 8));\n        }\n\n        @Override\n        // 重写sizeOf方法，并计算返回每个Bitmap对象占用的内存，必须重写\n        protected int sizeOf(String key, Bitmap value) {\n            return value.getByteCount() / 1024;\n        }\n\n        @Override\n        // 当缓存被移除时调用，第一个参数是表明缓存移除的原因，true表示被LruCache移除，false表示被主动remove移除，可不重写\n        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap\n                newValue) {\n            super.entryRemoved(evicted, key, oldValue, newValue);\n        }\n\n        @Override\n        // 当get方法获取不到缓存的时候调用，如果需要创建自定义默认缓存，可以在这里添加逻辑，可不重写。可在取不到缓存图片的时候自定义操作\n        protected Bitmap create(String key) {\n            return super.create(key);\n        }\n    }\n</code></pre><ul>\n<li><p>1.初始化</p>\n<pre><code>LruCache&lt;String, Bitmap&gt; mLruCache = new BitmapLruCache();\n</code></pre></li>\n<li><p>2.将图片写入缓存中</p>\n<pre><code>mLruCache.put(key, bitmap);\n</code></pre></li>\n<li><p>3.从缓存中读取图片</p>\n<pre><code>mLruCache.get(key, bitmap);\n</code></pre></li>\n<li><p>4.将图片从缓存中删除</p>\n<pre><code>mLruCache.remove(key);\n</code></pre></li>\n</ul>\n<p>使用还是很简单的。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>LruCache实现的核心是LinkedHashMap，为什么会用LinkedHashMap?<br>因为LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序.那么利用这个特性就可以实现LRU了。</p>\n<p>看一下LinkedHashMap的构造方法，</p>\n<pre><code>/**\n     * Constructs a new {@code LinkedHashMap} instance with the specified\n     * capacity, load factor and a flag specifying the ordering behavior.\n     *\n     * @param initialCapacity\n     *            the initial capacity of this hash map.\n     * @param loadFactor\n     *            the initial load factor.\n     * @param accessOrder\n     *            {@code true} if the ordering should be done based on the last\n     *            access (from least-recently accessed to most-recently\n     *            accessed), and {@code false} if the ordering should be the\n     *            order in which the entries were inserted.\n     * @throws IllegalArgumentException\n     *             when the capacity is less than zero or the load factor is\n     *             less or equal to zero.\n     */\n    public LinkedHashMap(\n            int initialCapacity, float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        init();\n        this.accessOrder = accessOrder;\n    }\n</code></pre><p>参数在LruCache中已经分析过了，再说一遍具体含义。</p>\n<p>initialCapacity：这个哈希表的初始容量</p>\n<p>loadFactor：加载因子</p>\n<p>accessOrder：true,访问顺序；false,插入顺序。</p>\n<p>其实很简单。</p>\n"},{"title":"OkHttp3源码学习（1）-简单实用教程","date":"2017-07-25T02:19:43.000Z","_content":"\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","source":"_posts/OkHttp3源码学习（1）.md","raw":"---\ntitle: OkHttp3源码学习（1）-简单实用教程\ndate: 2017-07-25 10:19:43\ntags: [OkHttp3]\n---\n\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","slug":"OkHttp3源码学习（1）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnu001rx3c0307d2m5i","content":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n"},{"title":"OkHttp3源码学习（2）-发起请求源码实现","date":"2017-07-26T07:25:37.000Z","_content":"\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","source":"_posts/OkHttp3源码学习（2）.md","raw":"---\ntitle: OkHttp3源码学习（2）-发起请求源码实现\ndate: 2017-07-26 15:25:37\ntags: [OkHttp3]\n---\n\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","slug":"OkHttp3源码学习（2）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnv001ux3c0vqobqpqs","content":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n"},{"title":"OkHttp3源码学习（3）-拦截器链详解","date":"2017-07-27T09:02:28.000Z","_content":"#### 一、发起请求\n\n\tOkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"\")\n                .build();\n        Call call = client.newCall(request);\n        try {\n            call.enqueue(new okhttp3.Callback() {\n                @Override\n                public void onFailure(Call call, IOException e) {\n                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n                }\n\n                @Override\n                public void onResponse(Call call, Response response) throws IOException {\n                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n                }\n            });\n        } catch (Exception e) {\n            Log.e(\"OkHttp\",e.getMessage());\n        }\n        \n* 发起请求时：client.newCall(request)。\n\n\t\t@Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  \t}\n  \n  实际上就是创建一个RealCall的实例。\n  \n*  然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。\n\n\t\t@Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\n#### 二、AsyncCall\n\n\t @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  \n  \n  AsyncCall会执行execute方法。execute方法逻辑很简单：\n  \n\n* 通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功\n\n\t\tResponse response = getResponseWithInterceptorChain();\n  \n\n* 通知任务分发器该任务结束\n\n  \t\tclient.dispatcher().finished(this);\n\n\n        \n#### 三、构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n从源码来看，基本逻辑就是：\n\n* 创建一系列拦截器，加到拦截器数组中。\n* 创建拦截器链RealInterceptorChain\n* 执行拦截器链中的proceed方法\n\n\n\n#### 四、RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n\n* 创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。\n\n\t\t// Call the next interceptor in the chain.\n\t\tRealInterceptorChain next = new RealInterceptorChain(\n\t\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n        \n* 获取索引为index的interceptor,执行索引为index的intercept方法。\n\t\n\t\tInterceptor interceptor = interceptors.get(index);\n    \tResponse response = interceptor.intercept(next);\n\n\n#### 五、拦截器链\n\n##### 1.RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n\t请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n\t毁掉,再新建一个StreamAllocation连接,进行重试。\n      if (!sameConnection(response, followUp.url(s))) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.\n\n\n\n\n\n下面就来对几种拦截器一一介绍。\n\n##### 2.BidgeInterceptor\n\n官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.\n\n整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。\n\n下面就看一下核心方法intercept()\n\n\t@Override public Response intercept(Chain chain) throws IOException {\n\t//拿到用户的请求\n    Request userRequest = chain.request();\n    Request.Builder requestBuilder = userRequest.newBuilder();\n\t//拿到用户请求body\n    RequestBody body = userRequest.body();\n    //对请求头的补充\n    if (body != null) {\n      MediaType contentType = body.contentType();\n      if (contentType != null) {\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n      }\n\n      long contentLength = body.contentLength();\n      if (contentLength != -1) {\n        requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n        requestBuilder.removeHeader(\"Transfer-Encoding\");\n      } else {\n        requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n        requestBuilder.removeHeader(\"Content-Length\");\n      }\n    }\n\n    if (userRequest.header(\"Host\") == null) {\n      requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false));\n    }\n\t//默认是保持连接的（Keep-Alive）\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n\t//默认GZIP压缩\n\t//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n    // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing\n    // the transfer stream.\n    boolean transparentGzip = false;\n    if (userRequest.header(\"Accept-Encoding\") == null && userRequest.header(\"Range\") == null) {\n      transparentGzip = true;\n      requestBuilder.header(\"Accept-Encoding\", \"gzip\");\n    }\n\t//添加cookie头\n    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());\n    if (!cookies.isEmpty()) {\n      requestBuilder.header(\"Cookie\", cookieHeader(cookies));\n    }\n\n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n\t//继续执行下一个拦截器的方法\n    Response networkResponse = chain.proceed(requestBuilder.build());\n\t//接收服务器返回的cookie\n    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\n    Response.Builder responseBuilder = networkResponse.newBuilder()\n        .request(userRequest);\n\n    if (transparentGzip\n        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n        && HttpHeaders.hasBody(networkResponse)) {\n      //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n      Headers strippedHeaders = networkResponse.headers().newBuilder()\n          .removeAll(\"Content-Encoding\")\n          .removeAll(\"Content-Length\")\n          .build();\n      responseBuilder.headers(strippedHeaders);\n      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n    }\n\t//构建一个Response\n    return responseBuilder.build();\n  \t}\n\n\nBridgeInterceptor主要流程逻辑：\n\n1. 拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求\n2. 将这个符合网络请求的Request进行网络请求\n3. 将网络请求返回的Response转化为用户可用的Response\n\t\n\t\n代码中构建网络Request添加的请求头信息：\n\n* 简单了解一下先，头信息\n\n协议头字段名 |说明| 示例 | 状态\n---- | --- | --- | ---\nContent-Type | 请求体的 多媒体类型 （用于POST和PUT请求中）|Content-Type: application/x-www-form-urlencoded|常设\nContent-Length |  以 八位字节数组 （8位的字节）表示的请求体的长度|Content-Length: 348|常设\nTransfer-Encoding|用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity|Transfer-Encoding: chunked|常设\nHost|服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。| Host: en.wikipedia.org:80 Host: en.wikipedia.org|常设\nConnection|该浏览器想要优先使用的连接类型|Connection: keep-alive  \t，Connection: Upgrade|常设\nAccept-Encoding|能够接受的编码方式列表|Accept-Encoding: gzip, deflate|常设\nCookie|之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109|Cookie: $Version=1; Skin=new;|常设: 标准\n\n###### 小结：\n\n* 构建完头信息后，进行网络请求\n\n\t\tResponse networkResponse = chain.proceed(requestBuilder.build());\n\t\t\n* 获取到返回的Response,转化为客户端可用的Response\n\t\n\t\t Response.Builder responseBuilder = networkResponse.newBuilder()\n\t        .request(userRequest);\n\t\n\t    if (transparentGzip\n\t        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n\t        && HttpHeaders.hasBody(networkResponse)) {\n\t      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n\t      Headers strippedHeaders = networkResponse.headers().newBuilder()\n\t          .removeAll(\"Content-Encoding\")\n\t          .removeAll(\"Content-Length\")\n\t          .build();\n\t      responseBuilder.headers(strippedHeaders);\n\t      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n\n\t\n\t\n\n##### 3.CacheIntetceptor\n\nCacheIntetceptor的职责就是负责Cache的管理\n\n看一下核心方法：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t //1.读取候选的缓存\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n\t//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //4.不需要访问网络的情况下，取本地缓存作为结果返回。\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n    //5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    //6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\t\t//8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n\t//9.读取网络请求\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\t//10.对数据进行缓存\n    if (cache != null) {\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        CacheRequest cacheRequest = cache.put(response);\n        return cacheWritingResponse(cacheRequest, response);\n      }\n\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\t//11.返回网络请求的结果\n    return response;\n  \t}\n\t\n\t\n####### 整个过程大致：\n\nCacheInterceptor主要就是负责Cache的管理\n\n   * 当网络被禁止访问，缓存不完整，那么返回失败（504）\n   * 缓存可用，返回缓存结果\n   * 当网络访问，返回（304），更新本地缓存\n   * 当Cache失效，删除缓存\n\n  \n##### 4.ConnectInterceptor\n\n代码不多，但包含的内容很多。\n\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    Request request = realChain.request();\n\t    //拿到StreamAllocation对象。\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t\n\t    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n\t    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n\t    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n\t    RealConnection connection = streamAllocation.connection();\n\t\n\t    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n\t  \t}\n\t\n\t\n从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化\n\n\t    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n        \n三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用\n\n看一下StreamAllocation的构造方法\n\n\tpublic StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\n    this.connectionPool = connectionPool;\n    this.address = address;\n    this.routeSelector = new RouteSelector(address, routeDatabase());\n    this.callStackTrace = callStackTrace;\n  \t}\n在把这个三个参数保存为内部变量的同时也创建了一个线路选择器\n\nstreamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。\n\n接下来继续看StreamAllocation中的newSream()方法\n\n\tpublic HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n\t//读取从OkHttpClient配置的超时时间\n    int connectTimeout = client.connectTimeoutMillis();\n    //获取读写超时时间\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    //连接重试\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n    //找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  \t}\n  \t\n 下面就再看一下它是如何找到一个健康的连接的\n\t\t\n\t  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n\t      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n\t      throws IOException {\n\t    while (true) {\n\t    //找到健康的连接\n\t      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n\t          connectionRetryEnabled);\n\t\n\t      // If this is a brand new connection, we can skip the extensive health checks.\n\t      synchronized (connectionPool) {\n\t        if (candidate.successCount == 0) {\n\t          return candidate;\n\t        }\n\t      }\n\t\n\t      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n\t      // isn't, take it out of the pool and start again.\n\t      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n\t        noNewStreams();\n\t        continue;\n\t      }\n\t\n\t      return candidate;\n\t    }\n\t  }\n\t  \n从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。\n\n那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法\n\t          \n\t          \n\tprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n\t      boolean connectionRetryEnabled) throws IOException {\n\t    Route selectedRoute;\n\t    //同步线程池\n\t    synchronized (connectionPool) {\n\t      if (released) throw new IllegalStateException(\"released\");\n\t      if (codec != null) throw new IllegalStateException(\"codec != null\");\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t\t\t//尝试使用现有连接，判断是否可用\n\t      // Attempt to use an already-allocated connection.\n\t      RealConnection allocatedConnection = this.connection;\n\t      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {\n\t        return allocatedConnection;\n\t      }\n\t\t\t//尝试在连接池中获取一个连接，\n\t      // Attempt to get a connection from the pool.\n\t      Internal.instance.get(connectionPool, address, this, null);\n\t      if (connection != null) {\n\t        return connection;\n\t      }\n\t\n\t      selectedRoute = route;\n\t    }\n\t\n\t    // If we need a route, make one. This is a blocking operation.\n\t    if (selectedRoute == null) {\n\t      selectedRoute = routeSelector.next();\n\t    }\n\t\n\t    RealConnection result;\n\t    synchronized (connectionPool) {\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n\t      // This could match due to connection coalescing.\n\t      Internal.instance.get(connectionPool, address, this, selectedRoute);\n\t      if (connection != null) {\n\t        route = selectedRoute;\n\t        return connection;\n\t      }\n\t\n\t      // Create a connection and assign it to this allocation immediately. This makes it possible\n\t      // for an asynchronous cancel() to interrupt the handshake we're about to do.\n\t      route = selectedRoute;\n\t      refusedStreamCount = 0;\n\t      result = new RealConnection(connectionPool, selectedRoute);\n\t      acquire(result);\n\t    }\n\t\n\t    // Do TCP + TLS handshakes. This is a blocking operation.\n\t    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n\t    routeDatabase().connected(result.route());\n\t\n\t    Socket socket = null;\n\t    synchronized (connectionPool) {\n\t      // Pool the connection.\n\t      Internal.instance.put(connectionPool, result);\n\t\n\t      // If another multiplexed connection to the same address was created concurrently, then\n\t      // release this connection and acquire that one.\n\t      if (result.isMultiplexed()) {\n\t        socket = Internal.instance.deduplicate(connectionPool, address, this);\n\t        result = connection;\n\t      }\n\t    }\n\t    closeQuietly(socket);\n\t\n\t    return result;\n\t  }\n\n这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。\n\n那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。\n\n##### 5.CallServerInterceptor\n\n整个拦截器链中的最后一个拦截器，看一下源码。\n\n关键方法intercept,如下：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    HttpCodec httpCodec = realChain.httpStream();\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t    RealConnection connection = (RealConnection) realChain.connection();\n\t    Request request = realChain.request();\n\t\t\n\t    long sentRequestMillis = System.currentTimeMillis();\n\t\t //1.首先写请求头\n\t    realChain.eventListener().requestHeadersStart(realChain.call());\n\t    httpCodec.writeRequestHeaders(request);\n\t    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\t\n\t    Response.Builder responseBuilder = null;\n\t    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n\t      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n\t      // Continue\" response before transmitting the request body. If we don't get that, return\n\t      // what we did get (such as a 4xx response) without ever transmitting the request body.\n\t      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n\t        httpCodec.flushRequest();\n\t        realChain.eventListener().responseHeadersStart(realChain.call());\n\t        responseBuilder = httpCodec.readResponseHeaders(true);\n\t      }\n\t\t   //2.然后写请求体\n\t      if (responseBuilder == null) {\n\t        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n\t        realChain.eventListener().requestBodyStart(realChain.call());\n\t        long contentLength = request.body().contentLength();\n\t        CountingSink requestBodyOut =\n\t            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n\t        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\t\n\t        request.body().writeTo(bufferedRequestBody);\n\t        bufferedRequestBody.close();\n\t        realChain.eventListener()\n\t            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n\t      } else if (!connection.isMultiplexed()) {\n\t        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n\t        // from being reused. Otherwise we're still obligated to transmit the request body to\n\t        // leave the connection in a consistent state.\n\t        streamAllocation.noNewStreams();\n\t      }\n\t    }\n\t\n\t    httpCodec.finishRequest();\n\t\t //读取响应头\n\t    if (responseBuilder == null) {\n\t      realChain.eventListener().responseHeadersStart(realChain.call());\n\t      responseBuilder = httpCodec.readResponseHeaders(false);\n\t    }\n\t\n\t    Response response = responseBuilder\n\t        .request(request)\n\t        .handshake(streamAllocation.connection().handshake())\n\t        .sentRequestAtMillis(sentRequestMillis)\n\t        .receivedResponseAtMillis(System.currentTimeMillis())\n\t        .build();\n\t\n\t    realChain.eventListener()\n\t        .responseHeadersEnd(realChain.call(), response);\n\t    //判断响应码，读取响应体\n\t    int code = response.code();\n\t    if (forWebSocket && code == 101) {\n\t      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n\t      response = response.newBuilder()\n\t          .body(Util.EMPTY_RESPONSE)\n\t          .build();\n\t    } else {\n\t      response = response.newBuilder()\n\t          .body(httpCodec.openResponseBody(response))\n\t          .build();\n\t    }\n\t\n\t    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n\t        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n\t      streamAllocation.noNewStreams();\n\t    }\n\t\n\t    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n\t      throw new ProtocolException(\n\t          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n\t    }\n\t\n\t    return response;\n\t  }\n\n真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。\n\n\n##### 最后\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n","source":"_posts/OkHttp3源码学习（3）.md","raw":"---\ntitle: OkHttp3源码学习（3）-拦截器链详解\ndate: 2017-07-27 17:02:28\ntags: [OkHttp3]\n---\n#### 一、发起请求\n\n\tOkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"\")\n                .build();\n        Call call = client.newCall(request);\n        try {\n            call.enqueue(new okhttp3.Callback() {\n                @Override\n                public void onFailure(Call call, IOException e) {\n                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n                }\n\n                @Override\n                public void onResponse(Call call, Response response) throws IOException {\n                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n                }\n            });\n        } catch (Exception e) {\n            Log.e(\"OkHttp\",e.getMessage());\n        }\n        \n* 发起请求时：client.newCall(request)。\n\n\t\t@Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  \t}\n  \n  实际上就是创建一个RealCall的实例。\n  \n*  然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。\n\n\t\t@Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\n#### 二、AsyncCall\n\n\t @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  \n  \n  AsyncCall会执行execute方法。execute方法逻辑很简单：\n  \n\n* 通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功\n\n\t\tResponse response = getResponseWithInterceptorChain();\n  \n\n* 通知任务分发器该任务结束\n\n  \t\tclient.dispatcher().finished(this);\n\n\n        \n#### 三、构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n从源码来看，基本逻辑就是：\n\n* 创建一系列拦截器，加到拦截器数组中。\n* 创建拦截器链RealInterceptorChain\n* 执行拦截器链中的proceed方法\n\n\n\n#### 四、RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n\n* 创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。\n\n\t\t// Call the next interceptor in the chain.\n\t\tRealInterceptorChain next = new RealInterceptorChain(\n\t\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n        \n* 获取索引为index的interceptor,执行索引为index的intercept方法。\n\t\n\t\tInterceptor interceptor = interceptors.get(index);\n    \tResponse response = interceptor.intercept(next);\n\n\n#### 五、拦截器链\n\n##### 1.RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n\t请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n\t毁掉,再新建一个StreamAllocation连接,进行重试。\n      if (!sameConnection(response, followUp.url(s))) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.\n\n\n\n\n\n下面就来对几种拦截器一一介绍。\n\n##### 2.BidgeInterceptor\n\n官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.\n\n整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。\n\n下面就看一下核心方法intercept()\n\n\t@Override public Response intercept(Chain chain) throws IOException {\n\t//拿到用户的请求\n    Request userRequest = chain.request();\n    Request.Builder requestBuilder = userRequest.newBuilder();\n\t//拿到用户请求body\n    RequestBody body = userRequest.body();\n    //对请求头的补充\n    if (body != null) {\n      MediaType contentType = body.contentType();\n      if (contentType != null) {\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n      }\n\n      long contentLength = body.contentLength();\n      if (contentLength != -1) {\n        requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n        requestBuilder.removeHeader(\"Transfer-Encoding\");\n      } else {\n        requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n        requestBuilder.removeHeader(\"Content-Length\");\n      }\n    }\n\n    if (userRequest.header(\"Host\") == null) {\n      requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false));\n    }\n\t//默认是保持连接的（Keep-Alive）\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n\t//默认GZIP压缩\n\t//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n    // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing\n    // the transfer stream.\n    boolean transparentGzip = false;\n    if (userRequest.header(\"Accept-Encoding\") == null && userRequest.header(\"Range\") == null) {\n      transparentGzip = true;\n      requestBuilder.header(\"Accept-Encoding\", \"gzip\");\n    }\n\t//添加cookie头\n    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());\n    if (!cookies.isEmpty()) {\n      requestBuilder.header(\"Cookie\", cookieHeader(cookies));\n    }\n\n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n\t//继续执行下一个拦截器的方法\n    Response networkResponse = chain.proceed(requestBuilder.build());\n\t//接收服务器返回的cookie\n    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\n    Response.Builder responseBuilder = networkResponse.newBuilder()\n        .request(userRequest);\n\n    if (transparentGzip\n        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n        && HttpHeaders.hasBody(networkResponse)) {\n      //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n      Headers strippedHeaders = networkResponse.headers().newBuilder()\n          .removeAll(\"Content-Encoding\")\n          .removeAll(\"Content-Length\")\n          .build();\n      responseBuilder.headers(strippedHeaders);\n      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n    }\n\t//构建一个Response\n    return responseBuilder.build();\n  \t}\n\n\nBridgeInterceptor主要流程逻辑：\n\n1. 拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求\n2. 将这个符合网络请求的Request进行网络请求\n3. 将网络请求返回的Response转化为用户可用的Response\n\t\n\t\n代码中构建网络Request添加的请求头信息：\n\n* 简单了解一下先，头信息\n\n协议头字段名 |说明| 示例 | 状态\n---- | --- | --- | ---\nContent-Type | 请求体的 多媒体类型 （用于POST和PUT请求中）|Content-Type: application/x-www-form-urlencoded|常设\nContent-Length |  以 八位字节数组 （8位的字节）表示的请求体的长度|Content-Length: 348|常设\nTransfer-Encoding|用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity|Transfer-Encoding: chunked|常设\nHost|服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。| Host: en.wikipedia.org:80 Host: en.wikipedia.org|常设\nConnection|该浏览器想要优先使用的连接类型|Connection: keep-alive  \t，Connection: Upgrade|常设\nAccept-Encoding|能够接受的编码方式列表|Accept-Encoding: gzip, deflate|常设\nCookie|之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109|Cookie: $Version=1; Skin=new;|常设: 标准\n\n###### 小结：\n\n* 构建完头信息后，进行网络请求\n\n\t\tResponse networkResponse = chain.proceed(requestBuilder.build());\n\t\t\n* 获取到返回的Response,转化为客户端可用的Response\n\t\n\t\t Response.Builder responseBuilder = networkResponse.newBuilder()\n\t        .request(userRequest);\n\t\n\t    if (transparentGzip\n\t        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n\t        && HttpHeaders.hasBody(networkResponse)) {\n\t      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n\t      Headers strippedHeaders = networkResponse.headers().newBuilder()\n\t          .removeAll(\"Content-Encoding\")\n\t          .removeAll(\"Content-Length\")\n\t          .build();\n\t      responseBuilder.headers(strippedHeaders);\n\t      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n\n\t\n\t\n\n##### 3.CacheIntetceptor\n\nCacheIntetceptor的职责就是负责Cache的管理\n\n看一下核心方法：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t //1.读取候选的缓存\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n\t//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //4.不需要访问网络的情况下，取本地缓存作为结果返回。\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n    //5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    //6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\t\t//8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n\t//9.读取网络请求\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\t//10.对数据进行缓存\n    if (cache != null) {\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        CacheRequest cacheRequest = cache.put(response);\n        return cacheWritingResponse(cacheRequest, response);\n      }\n\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\t//11.返回网络请求的结果\n    return response;\n  \t}\n\t\n\t\n####### 整个过程大致：\n\nCacheInterceptor主要就是负责Cache的管理\n\n   * 当网络被禁止访问，缓存不完整，那么返回失败（504）\n   * 缓存可用，返回缓存结果\n   * 当网络访问，返回（304），更新本地缓存\n   * 当Cache失效，删除缓存\n\n  \n##### 4.ConnectInterceptor\n\n代码不多，但包含的内容很多。\n\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    Request request = realChain.request();\n\t    //拿到StreamAllocation对象。\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t\n\t    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n\t    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n\t    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n\t    RealConnection connection = streamAllocation.connection();\n\t\n\t    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n\t  \t}\n\t\n\t\n从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化\n\n\t    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n        \n三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用\n\n看一下StreamAllocation的构造方法\n\n\tpublic StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\n    this.connectionPool = connectionPool;\n    this.address = address;\n    this.routeSelector = new RouteSelector(address, routeDatabase());\n    this.callStackTrace = callStackTrace;\n  \t}\n在把这个三个参数保存为内部变量的同时也创建了一个线路选择器\n\nstreamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。\n\n接下来继续看StreamAllocation中的newSream()方法\n\n\tpublic HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n\t//读取从OkHttpClient配置的超时时间\n    int connectTimeout = client.connectTimeoutMillis();\n    //获取读写超时时间\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    //连接重试\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n    //找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  \t}\n  \t\n 下面就再看一下它是如何找到一个健康的连接的\n\t\t\n\t  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n\t      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n\t      throws IOException {\n\t    while (true) {\n\t    //找到健康的连接\n\t      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n\t          connectionRetryEnabled);\n\t\n\t      // If this is a brand new connection, we can skip the extensive health checks.\n\t      synchronized (connectionPool) {\n\t        if (candidate.successCount == 0) {\n\t          return candidate;\n\t        }\n\t      }\n\t\n\t      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n\t      // isn't, take it out of the pool and start again.\n\t      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n\t        noNewStreams();\n\t        continue;\n\t      }\n\t\n\t      return candidate;\n\t    }\n\t  }\n\t  \n从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。\n\n那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法\n\t          \n\t          \n\tprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n\t      boolean connectionRetryEnabled) throws IOException {\n\t    Route selectedRoute;\n\t    //同步线程池\n\t    synchronized (connectionPool) {\n\t      if (released) throw new IllegalStateException(\"released\");\n\t      if (codec != null) throw new IllegalStateException(\"codec != null\");\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t\t\t//尝试使用现有连接，判断是否可用\n\t      // Attempt to use an already-allocated connection.\n\t      RealConnection allocatedConnection = this.connection;\n\t      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {\n\t        return allocatedConnection;\n\t      }\n\t\t\t//尝试在连接池中获取一个连接，\n\t      // Attempt to get a connection from the pool.\n\t      Internal.instance.get(connectionPool, address, this, null);\n\t      if (connection != null) {\n\t        return connection;\n\t      }\n\t\n\t      selectedRoute = route;\n\t    }\n\t\n\t    // If we need a route, make one. This is a blocking operation.\n\t    if (selectedRoute == null) {\n\t      selectedRoute = routeSelector.next();\n\t    }\n\t\n\t    RealConnection result;\n\t    synchronized (connectionPool) {\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n\t      // This could match due to connection coalescing.\n\t      Internal.instance.get(connectionPool, address, this, selectedRoute);\n\t      if (connection != null) {\n\t        route = selectedRoute;\n\t        return connection;\n\t      }\n\t\n\t      // Create a connection and assign it to this allocation immediately. This makes it possible\n\t      // for an asynchronous cancel() to interrupt the handshake we're about to do.\n\t      route = selectedRoute;\n\t      refusedStreamCount = 0;\n\t      result = new RealConnection(connectionPool, selectedRoute);\n\t      acquire(result);\n\t    }\n\t\n\t    // Do TCP + TLS handshakes. This is a blocking operation.\n\t    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n\t    routeDatabase().connected(result.route());\n\t\n\t    Socket socket = null;\n\t    synchronized (connectionPool) {\n\t      // Pool the connection.\n\t      Internal.instance.put(connectionPool, result);\n\t\n\t      // If another multiplexed connection to the same address was created concurrently, then\n\t      // release this connection and acquire that one.\n\t      if (result.isMultiplexed()) {\n\t        socket = Internal.instance.deduplicate(connectionPool, address, this);\n\t        result = connection;\n\t      }\n\t    }\n\t    closeQuietly(socket);\n\t\n\t    return result;\n\t  }\n\n这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。\n\n那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。\n\n##### 5.CallServerInterceptor\n\n整个拦截器链中的最后一个拦截器，看一下源码。\n\n关键方法intercept,如下：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    HttpCodec httpCodec = realChain.httpStream();\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t    RealConnection connection = (RealConnection) realChain.connection();\n\t    Request request = realChain.request();\n\t\t\n\t    long sentRequestMillis = System.currentTimeMillis();\n\t\t //1.首先写请求头\n\t    realChain.eventListener().requestHeadersStart(realChain.call());\n\t    httpCodec.writeRequestHeaders(request);\n\t    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\t\n\t    Response.Builder responseBuilder = null;\n\t    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n\t      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n\t      // Continue\" response before transmitting the request body. If we don't get that, return\n\t      // what we did get (such as a 4xx response) without ever transmitting the request body.\n\t      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n\t        httpCodec.flushRequest();\n\t        realChain.eventListener().responseHeadersStart(realChain.call());\n\t        responseBuilder = httpCodec.readResponseHeaders(true);\n\t      }\n\t\t   //2.然后写请求体\n\t      if (responseBuilder == null) {\n\t        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n\t        realChain.eventListener().requestBodyStart(realChain.call());\n\t        long contentLength = request.body().contentLength();\n\t        CountingSink requestBodyOut =\n\t            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n\t        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\t\n\t        request.body().writeTo(bufferedRequestBody);\n\t        bufferedRequestBody.close();\n\t        realChain.eventListener()\n\t            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n\t      } else if (!connection.isMultiplexed()) {\n\t        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n\t        // from being reused. Otherwise we're still obligated to transmit the request body to\n\t        // leave the connection in a consistent state.\n\t        streamAllocation.noNewStreams();\n\t      }\n\t    }\n\t\n\t    httpCodec.finishRequest();\n\t\t //读取响应头\n\t    if (responseBuilder == null) {\n\t      realChain.eventListener().responseHeadersStart(realChain.call());\n\t      responseBuilder = httpCodec.readResponseHeaders(false);\n\t    }\n\t\n\t    Response response = responseBuilder\n\t        .request(request)\n\t        .handshake(streamAllocation.connection().handshake())\n\t        .sentRequestAtMillis(sentRequestMillis)\n\t        .receivedResponseAtMillis(System.currentTimeMillis())\n\t        .build();\n\t\n\t    realChain.eventListener()\n\t        .responseHeadersEnd(realChain.call(), response);\n\t    //判断响应码，读取响应体\n\t    int code = response.code();\n\t    if (forWebSocket && code == 101) {\n\t      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n\t      response = response.newBuilder()\n\t          .body(Util.EMPTY_RESPONSE)\n\t          .build();\n\t    } else {\n\t      response = response.newBuilder()\n\t          .body(httpCodec.openResponseBody(response))\n\t          .build();\n\t    }\n\t\n\t    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n\t        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n\t      streamAllocation.noNewStreams();\n\t    }\n\t\n\t    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n\t      throw new ProtocolException(\n\t          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n\t    }\n\t\n\t    return response;\n\t  }\n\n真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。\n\n\n##### 最后\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n","slug":"OkHttp3源码学习（3）","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnv001wx3c069f3y7cv","content":"<h4 id=\"一、发起请求\"><a href=\"#一、发起请求\" class=\"headerlink\" title=\"一、发起请求\"></a>一、发起请求</h4><pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre><ul>\n<li><p>发起请求时：client.newCall(request)。</p>\n<pre><code>@Override public Call newCall(Request request) {\nreturn new RealCall(this, request, false /* for web socket */);\n  }\n</code></pre><p>实际上就是创建一个RealCall的实例。</p>\n</li>\n<li><p>然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre></li>\n</ul>\n<h4 id=\"二、AsyncCall\"><a href=\"#二、AsyncCall\" class=\"headerlink\" title=\"二、AsyncCall\"></a>二、AsyncCall</h4><pre><code> @Override protected void execute() {\n  boolean signalledCallback = false;\n  try {\n    Response response = getResponseWithInterceptorChain();\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      signalledCallback = true;\n      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n    } else {\n      signalledCallback = true;\n      responseCallback.onResponse(RealCall.this, response);\n    }\n  } catch (IOException e) {\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n    } else {\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n</code></pre><p>  AsyncCall会执行execute方法。execute方法逻辑很简单：</p>\n<ul>\n<li><p>通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功</p>\n<pre><code>Response response = getResponseWithInterceptorChain();\n</code></pre></li>\n</ul>\n<ul>\n<li><p>通知任务分发器该任务结束</p>\n<pre><code>client.dispatcher().finished(this);\n</code></pre></li>\n</ul>\n<h4 id=\"三、构建拦截器链\"><a href=\"#三、构建拦截器链\" class=\"headerlink\" title=\"三、构建拦截器链\"></a>三、构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><p>从源码来看，基本逻辑就是：</p>\n<ul>\n<li>创建一系列拦截器，加到拦截器数组中。</li>\n<li>创建拦截器链RealInterceptorChain</li>\n<li>执行拦截器链中的proceed方法</li>\n</ul>\n<h4 id=\"四、RealInterceptorChain\"><a href=\"#四、RealInterceptorChain\" class=\"headerlink\" title=\"四、RealInterceptorChain\"></a>四、RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：</p>\n<ul>\n<li><p>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。</p>\n<pre><code>// Call the next interceptor in the chain.\nRealInterceptorChain next = new RealInterceptorChain(\n            interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n</code></pre></li>\n<li><p>获取索引为index的interceptor,执行索引为index的intercept方法。</p>\n<pre><code>Interceptor interceptor = interceptors.get(index);\nResponse response = interceptor.intercept(next);\n</code></pre></li>\n</ul>\n<h4 id=\"五、拦截器链\"><a href=\"#五、拦截器链\" class=\"headerlink\" title=\"五、拦截器链\"></a>五、拦截器链</h4><h5 id=\"1-RetryAndFollowUpInterceptor\"><a href=\"#1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"1.RetryAndFollowUpInterceptor\"></a>1.RetryAndFollowUpInterceptor</h5><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n毁掉,再新建一个StreamAllocation连接,进行重试。\n  if (!sameConnection(response, followUp.url(s))) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.</p>\n<p>下面就来对几种拦截器一一介绍。</p>\n<h5 id=\"2-BidgeInterceptor\"><a href=\"#2-BidgeInterceptor\" class=\"headerlink\" title=\"2.BidgeInterceptor\"></a>2.BidgeInterceptor</h5><p>官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.</p>\n<p>整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。</p>\n<p>下面就看一下核心方法intercept()</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n//拿到用户的请求\nRequest userRequest = chain.request();\nRequest.Builder requestBuilder = userRequest.newBuilder();\n//拿到用户请求body\nRequestBody body = userRequest.body();\n//对请求头的补充\nif (body != null) {\n  MediaType contentType = body.contentType();\n  if (contentType != null) {\n    requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());\n  }\n\n  long contentLength = body.contentLength();\n  if (contentLength != -1) {\n    requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));\n    requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);\n  } else {\n    requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);\n    requestBuilder.removeHeader(&quot;Content-Length&quot;);\n  }\n}\n\nif (userRequest.header(&quot;Host&quot;) == null) {\n  requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));\n}\n//默认是保持连接的（Keep-Alive）\nif (userRequest.header(&quot;Connection&quot;) == null) {\n  requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n}\n//默认GZIP压缩\n//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n// If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing\n// the transfer stream.\nboolean transparentGzip = false;\nif (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {\n  transparentGzip = true;\n  requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);\n}\n//添加cookie头\nList&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());\nif (!cookies.isEmpty()) {\n  requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));\n}\n\nif (userRequest.header(&quot;User-Agent&quot;) == null) {\n  requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());\n}\n//继续执行下一个拦截器的方法\nResponse networkResponse = chain.proceed(requestBuilder.build());\n//接收服务器返回的cookie\nHttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\nResponse.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n}\n//构建一个Response\nreturn responseBuilder.build();\n  }\n</code></pre><p>BridgeInterceptor主要流程逻辑：</p>\n<ol>\n<li>拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求</li>\n<li>将这个符合网络请求的Request进行网络请求</li>\n<li>将网络请求返回的Response转化为用户可用的Response</li>\n</ol>\n<p>代码中构建网络Request添加的请求头信息：</p>\n<ul>\n<li>简单了解一下先，头信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议头字段名</th>\n<th>说明</th>\n<th>示例</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content-Type</td>\n<td>请求体的 多媒体类型 （用于POST和PUT请求中）</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>\n<td>Content-Length: 348</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity</td>\n<td>Transfer-Encoding: chunked</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。</td>\n<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>该浏览器想要优先使用的连接类型</td>\n<td>Connection: keep-alive      ，Connection: Upgrade</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>能够接受的编码方式列表</td>\n<td>Accept-Encoding: gzip, deflate</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n<td>常设: 标准</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li><p>构建完头信息后，进行网络请求</p>\n<pre><code>Response networkResponse = chain.proceed(requestBuilder.build());\n</code></pre></li>\n<li><p>获取到返回的Response,转化为客户端可用的Response</p>\n<pre><code> Response.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n</code></pre></li>\n</ul>\n<h5 id=\"3-CacheIntetceptor\"><a href=\"#3-CacheIntetceptor\" class=\"headerlink\" title=\"3.CacheIntetceptor\"></a>3.CacheIntetceptor</h5><p>CacheIntetceptor的职责就是负责Cache的管理</p>\n<p>看一下核心方法：</p>\n<pre><code> @Override public Response intercept(Chain chain) throws IOException {\n //1.读取候选的缓存\nResponse cacheCandidate = cache != null\n    ? cache.get(chain.request())\n    : null;\n\nlong now = System.currentTimeMillis();\n//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\nCacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\nRequest networkRequest = strategy.networkRequest;\nResponse cacheResponse = strategy.cacheResponse;\n\nif (cache != null) {\n  cache.trackResponse(strategy);\n}\n\nif (cacheCandidate != null &amp;&amp; cacheResponse == null) {\n  closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.\n}\n\n// If we&apos;re forbidden from using the network and the cache is insufficient, fail.\n//3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\nif (networkRequest == null &amp;&amp; cacheResponse == null) {\n  return new Response.Builder()\n      .request(chain.request())\n      .protocol(Protocol.HTTP_1_1)\n      .code(504)\n      .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)\n      .body(Util.EMPTY_RESPONSE)\n      .sentRequestAtMillis(-1L)\n      .receivedResponseAtMillis(System.currentTimeMillis())\n      .build();\n}\n\n// If we don&apos;t need the network, we&apos;re done.\n//4.不需要访问网络的情况下，取本地缓存作为结果返回。\nif (networkRequest == null) {\n  return cacheResponse.newBuilder()\n      .cacheResponse(stripBody(cacheResponse))\n      .build();\n}\n\nResponse networkResponse = null;\ntry {\n//5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n  networkResponse = chain.proceed(networkRequest);\n} finally {\n  // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.\n  if (networkResponse == null &amp;&amp; cacheCandidate != null) {\n    closeQuietly(cacheCandidate.body());\n  }\n}\n\n// If we have a cache response too, then we&apos;re doing a conditional get.\n//6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\nif (cacheResponse != null) {\n  if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n    Response response = cacheResponse.newBuilder()\n        .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n    networkResponse.body().close();\n    //8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n    // Update the cache after combining headers but before stripping the\n    // Content-Encoding header (as performed by initContentStream()).\n    cache.trackConditionalCacheHit();\n    cache.update(cacheResponse, response);\n    return response;\n  } else {\n    closeQuietly(cacheResponse.body());\n  }\n}\n//9.读取网络请求\nResponse response = networkResponse.newBuilder()\n    .cacheResponse(stripBody(cacheResponse))\n    .networkResponse(stripBody(networkResponse))\n    .build();\n//10.对数据进行缓存\nif (cache != null) {\n  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {\n    // Offer this request to the cache.\n    CacheRequest cacheRequest = cache.put(response);\n    return cacheWritingResponse(cacheRequest, response);\n  }\n\n  if (HttpMethod.invalidatesCache(networkRequest.method())) {\n    try {\n      cache.remove(networkRequest);\n    } catch (IOException ignored) {\n      // The cache cannot be written.\n    }\n  }\n}\n//11.返回网络请求的结果\nreturn response;\n  }\n</code></pre><p>####### 整个过程大致：</p>\n<p>CacheInterceptor主要就是负责Cache的管理</p>\n<ul>\n<li>当网络被禁止访问，缓存不完整，那么返回失败（504）</li>\n<li>缓存可用，返回缓存结果</li>\n<li>当网络访问，返回（304），更新本地缓存</li>\n<li>当Cache失效，删除缓存</li>\n</ul>\n<h5 id=\"4-ConnectInterceptor\"><a href=\"#4-ConnectInterceptor\" class=\"headerlink\" title=\"4.ConnectInterceptor\"></a>4.ConnectInterceptor</h5><p>代码不多，但包含的内容很多。</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   Request request = realChain.request();\n   //拿到StreamAllocation对象。\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n\n   // We need the network to satisfy this request. Possibly for validating a conditional GET.\n   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);\n   HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n   RealConnection connection = streamAllocation.connection();\n\n   return realChain.proceed(request, streamAllocation, httpCodec, connection);\n     }\n</code></pre><p>从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化</p>\n<pre><code>streamAllocation = new StreamAllocation(\nclient.connectionPool(), createAddress(request.url()), callStackTrace);\n</code></pre><p>三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用</p>\n<p>看一下StreamAllocation的构造方法</p>\n<pre><code>public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\nthis.connectionPool = connectionPool;\nthis.address = address;\nthis.routeSelector = new RouteSelector(address, routeDatabase());\nthis.callStackTrace = callStackTrace;\n  }\n</code></pre><p>在把这个三个参数保存为内部变量的同时也创建了一个线路选择器</p>\n<p>streamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。</p>\n<p>接下来继续看StreamAllocation中的newSream()方法</p>\n<pre><code>public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n//读取从OkHttpClient配置的超时时间\nint connectTimeout = client.connectTimeoutMillis();\n//获取读写超时时间\nint readTimeout = client.readTimeoutMillis();\nint writeTimeout = client.writeTimeoutMillis();\n//连接重试\nboolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\ntry {\n//找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n  //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n  HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n  synchronized (connectionPool) {\n    codec = resultCodec;\n    return resultCodec;\n  }\n} catch (IOException e) {\n  throw new RouteException(e);\n}\n  }\n</code></pre><p> 下面就再看一下它是如何找到一个健康的连接的</p>\n<pre><code>private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n    int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n    throws IOException {\n  while (true) {\n  //找到健康的连接\n    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n        connectionRetryEnabled);\n\n    // If this is a brand new connection, we can skip the extensive health checks.\n    synchronized (connectionPool) {\n      if (candidate.successCount == 0) {\n        return candidate;\n      }\n    }\n\n    // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n    // isn&apos;t, take it out of the pool and start again.\n    if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n      noNewStreams();\n      continue;\n    }\n\n    return candidate;\n  }\n}\n</code></pre><p>从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。</p>\n<p>那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法</p>\n<pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    Route selectedRoute;\n    //同步线程池\n    synchronized (connectionPool) {\n      if (released) throw new IllegalStateException(&quot;released&quot;);\n      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n        //尝试使用现有连接，判断是否可用\n      // Attempt to use an already-allocated connection.\n      RealConnection allocatedConnection = this.connection;\n      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) {\n        return allocatedConnection;\n      }\n        //尝试在连接池中获取一个连接，\n      // Attempt to get a connection from the pool.\n      Internal.instance.get(connectionPool, address, this, null);\n      if (connection != null) {\n        return connection;\n      }\n\n      selectedRoute = route;\n    }\n\n    // If we need a route, make one. This is a blocking operation.\n    if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n    }\n\n    RealConnection result;\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n      // This could match due to connection coalescing.\n      Internal.instance.get(connectionPool, address, this, selectedRoute);\n      if (connection != null) {\n        route = selectedRoute;\n        return connection;\n      }\n\n      // Create a connection and assign it to this allocation immediately. This makes it possible\n      // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.\n      route = selectedRoute;\n      refusedStreamCount = 0;\n      result = new RealConnection(connectionPool, selectedRoute);\n      acquire(result);\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      // Pool the connection.\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    return result;\n  }\n</code></pre><p>这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。</p>\n<p>那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p>\n<h5 id=\"5-CallServerInterceptor\"><a href=\"#5-CallServerInterceptor\" class=\"headerlink\" title=\"5.CallServerInterceptor\"></a>5.CallServerInterceptor</h5><p>整个拦截器链中的最后一个拦截器，看一下源码。</p>\n<p>关键方法intercept,如下：</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   HttpCodec httpCodec = realChain.httpStream();\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n   RealConnection connection = (RealConnection) realChain.connection();\n   Request request = realChain.request();\n\n   long sentRequestMillis = System.currentTimeMillis();\n    //1.首先写请求头\n   realChain.eventListener().requestHeadersStart(realChain.call());\n   httpCodec.writeRequestHeaders(request);\n   realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n   Response.Builder responseBuilder = null;\n   if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {\n     // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100\n     // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return\n     // what we did get (such as a 4xx response) without ever transmitting the request body.\n     if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {\n       httpCodec.flushRequest();\n       realChain.eventListener().responseHeadersStart(realChain.call());\n       responseBuilder = httpCodec.readResponseHeaders(true);\n     }\n      //2.然后写请求体\n     if (responseBuilder == null) {\n       // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.\n       realChain.eventListener().requestBodyStart(realChain.call());\n       long contentLength = request.body().contentLength();\n       CountingSink requestBodyOut =\n           new CountingSink(httpCodec.createRequestBody(request, contentLength));\n       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n       request.body().writeTo(bufferedRequestBody);\n       bufferedRequestBody.close();\n       realChain.eventListener()\n           .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n     } else if (!connection.isMultiplexed()) {\n       // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection\n       // from being reused. Otherwise we&apos;re still obligated to transmit the request body to\n       // leave the connection in a consistent state.\n       streamAllocation.noNewStreams();\n     }\n   }\n\n   httpCodec.finishRequest();\n    //读取响应头\n   if (responseBuilder == null) {\n     realChain.eventListener().responseHeadersStart(realChain.call());\n     responseBuilder = httpCodec.readResponseHeaders(false);\n   }\n\n   Response response = responseBuilder\n       .request(request)\n       .handshake(streamAllocation.connection().handshake())\n       .sentRequestAtMillis(sentRequestMillis)\n       .receivedResponseAtMillis(System.currentTimeMillis())\n       .build();\n\n   realChain.eventListener()\n       .responseHeadersEnd(realChain.call(), response);\n   //判断响应码，读取响应体\n   int code = response.code();\n   if (forWebSocket &amp;&amp; code == 101) {\n     // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n     response = response.newBuilder()\n         .body(Util.EMPTY_RESPONSE)\n         .build();\n   } else {\n     response = response.newBuilder()\n         .body(httpCodec.openResponseBody(response))\n         .build();\n   }\n\n   if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))\n       || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {\n     streamAllocation.noNewStreams();\n   }\n\n   if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {\n     throw new ProtocolException(\n         &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());\n   }\n\n   return response;\n }\n</code></pre><p>真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、发起请求\"><a href=\"#一、发起请求\" class=\"headerlink\" title=\"一、发起请求\"></a>一、发起请求</h4><pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre><ul>\n<li><p>发起请求时：client.newCall(request)。</p>\n<pre><code>@Override public Call newCall(Request request) {\nreturn new RealCall(this, request, false /* for web socket */);\n  }\n</code></pre><p>实际上就是创建一个RealCall的实例。</p>\n</li>\n<li><p>然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre></li>\n</ul>\n<h4 id=\"二、AsyncCall\"><a href=\"#二、AsyncCall\" class=\"headerlink\" title=\"二、AsyncCall\"></a>二、AsyncCall</h4><pre><code> @Override protected void execute() {\n  boolean signalledCallback = false;\n  try {\n    Response response = getResponseWithInterceptorChain();\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      signalledCallback = true;\n      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n    } else {\n      signalledCallback = true;\n      responseCallback.onResponse(RealCall.this, response);\n    }\n  } catch (IOException e) {\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n    } else {\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n</code></pre><p>  AsyncCall会执行execute方法。execute方法逻辑很简单：</p>\n<ul>\n<li><p>通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功</p>\n<pre><code>Response response = getResponseWithInterceptorChain();\n</code></pre></li>\n</ul>\n<ul>\n<li><p>通知任务分发器该任务结束</p>\n<pre><code>client.dispatcher().finished(this);\n</code></pre></li>\n</ul>\n<h4 id=\"三、构建拦截器链\"><a href=\"#三、构建拦截器链\" class=\"headerlink\" title=\"三、构建拦截器链\"></a>三、构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><p>从源码来看，基本逻辑就是：</p>\n<ul>\n<li>创建一系列拦截器，加到拦截器数组中。</li>\n<li>创建拦截器链RealInterceptorChain</li>\n<li>执行拦截器链中的proceed方法</li>\n</ul>\n<h4 id=\"四、RealInterceptorChain\"><a href=\"#四、RealInterceptorChain\" class=\"headerlink\" title=\"四、RealInterceptorChain\"></a>四、RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：</p>\n<ul>\n<li><p>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。</p>\n<pre><code>// Call the next interceptor in the chain.\nRealInterceptorChain next = new RealInterceptorChain(\n            interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n</code></pre></li>\n<li><p>获取索引为index的interceptor,执行索引为index的intercept方法。</p>\n<pre><code>Interceptor interceptor = interceptors.get(index);\nResponse response = interceptor.intercept(next);\n</code></pre></li>\n</ul>\n<h4 id=\"五、拦截器链\"><a href=\"#五、拦截器链\" class=\"headerlink\" title=\"五、拦截器链\"></a>五、拦截器链</h4><h5 id=\"1-RetryAndFollowUpInterceptor\"><a href=\"#1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"1.RetryAndFollowUpInterceptor\"></a>1.RetryAndFollowUpInterceptor</h5><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n毁掉,再新建一个StreamAllocation连接,进行重试。\n  if (!sameConnection(response, followUp.url(s))) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.</p>\n<p>下面就来对几种拦截器一一介绍。</p>\n<h5 id=\"2-BidgeInterceptor\"><a href=\"#2-BidgeInterceptor\" class=\"headerlink\" title=\"2.BidgeInterceptor\"></a>2.BidgeInterceptor</h5><p>官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.</p>\n<p>整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。</p>\n<p>下面就看一下核心方法intercept()</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n//拿到用户的请求\nRequest userRequest = chain.request();\nRequest.Builder requestBuilder = userRequest.newBuilder();\n//拿到用户请求body\nRequestBody body = userRequest.body();\n//对请求头的补充\nif (body != null) {\n  MediaType contentType = body.contentType();\n  if (contentType != null) {\n    requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());\n  }\n\n  long contentLength = body.contentLength();\n  if (contentLength != -1) {\n    requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));\n    requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);\n  } else {\n    requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);\n    requestBuilder.removeHeader(&quot;Content-Length&quot;);\n  }\n}\n\nif (userRequest.header(&quot;Host&quot;) == null) {\n  requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));\n}\n//默认是保持连接的（Keep-Alive）\nif (userRequest.header(&quot;Connection&quot;) == null) {\n  requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n}\n//默认GZIP压缩\n//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n// If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing\n// the transfer stream.\nboolean transparentGzip = false;\nif (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {\n  transparentGzip = true;\n  requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);\n}\n//添加cookie头\nList&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());\nif (!cookies.isEmpty()) {\n  requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));\n}\n\nif (userRequest.header(&quot;User-Agent&quot;) == null) {\n  requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());\n}\n//继续执行下一个拦截器的方法\nResponse networkResponse = chain.proceed(requestBuilder.build());\n//接收服务器返回的cookie\nHttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\nResponse.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n}\n//构建一个Response\nreturn responseBuilder.build();\n  }\n</code></pre><p>BridgeInterceptor主要流程逻辑：</p>\n<ol>\n<li>拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求</li>\n<li>将这个符合网络请求的Request进行网络请求</li>\n<li>将网络请求返回的Response转化为用户可用的Response</li>\n</ol>\n<p>代码中构建网络Request添加的请求头信息：</p>\n<ul>\n<li>简单了解一下先，头信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议头字段名</th>\n<th>说明</th>\n<th>示例</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content-Type</td>\n<td>请求体的 多媒体类型 （用于POST和PUT请求中）</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>\n<td>Content-Length: 348</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity</td>\n<td>Transfer-Encoding: chunked</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。</td>\n<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>该浏览器想要优先使用的连接类型</td>\n<td>Connection: keep-alive      ，Connection: Upgrade</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>能够接受的编码方式列表</td>\n<td>Accept-Encoding: gzip, deflate</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n<td>常设: 标准</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li><p>构建完头信息后，进行网络请求</p>\n<pre><code>Response networkResponse = chain.proceed(requestBuilder.build());\n</code></pre></li>\n<li><p>获取到返回的Response,转化为客户端可用的Response</p>\n<pre><code> Response.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n</code></pre></li>\n</ul>\n<h5 id=\"3-CacheIntetceptor\"><a href=\"#3-CacheIntetceptor\" class=\"headerlink\" title=\"3.CacheIntetceptor\"></a>3.CacheIntetceptor</h5><p>CacheIntetceptor的职责就是负责Cache的管理</p>\n<p>看一下核心方法：</p>\n<pre><code> @Override public Response intercept(Chain chain) throws IOException {\n //1.读取候选的缓存\nResponse cacheCandidate = cache != null\n    ? cache.get(chain.request())\n    : null;\n\nlong now = System.currentTimeMillis();\n//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\nCacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\nRequest networkRequest = strategy.networkRequest;\nResponse cacheResponse = strategy.cacheResponse;\n\nif (cache != null) {\n  cache.trackResponse(strategy);\n}\n\nif (cacheCandidate != null &amp;&amp; cacheResponse == null) {\n  closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.\n}\n\n// If we&apos;re forbidden from using the network and the cache is insufficient, fail.\n//3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\nif (networkRequest == null &amp;&amp; cacheResponse == null) {\n  return new Response.Builder()\n      .request(chain.request())\n      .protocol(Protocol.HTTP_1_1)\n      .code(504)\n      .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)\n      .body(Util.EMPTY_RESPONSE)\n      .sentRequestAtMillis(-1L)\n      .receivedResponseAtMillis(System.currentTimeMillis())\n      .build();\n}\n\n// If we don&apos;t need the network, we&apos;re done.\n//4.不需要访问网络的情况下，取本地缓存作为结果返回。\nif (networkRequest == null) {\n  return cacheResponse.newBuilder()\n      .cacheResponse(stripBody(cacheResponse))\n      .build();\n}\n\nResponse networkResponse = null;\ntry {\n//5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n  networkResponse = chain.proceed(networkRequest);\n} finally {\n  // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.\n  if (networkResponse == null &amp;&amp; cacheCandidate != null) {\n    closeQuietly(cacheCandidate.body());\n  }\n}\n\n// If we have a cache response too, then we&apos;re doing a conditional get.\n//6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\nif (cacheResponse != null) {\n  if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n    Response response = cacheResponse.newBuilder()\n        .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n    networkResponse.body().close();\n    //8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n    // Update the cache after combining headers but before stripping the\n    // Content-Encoding header (as performed by initContentStream()).\n    cache.trackConditionalCacheHit();\n    cache.update(cacheResponse, response);\n    return response;\n  } else {\n    closeQuietly(cacheResponse.body());\n  }\n}\n//9.读取网络请求\nResponse response = networkResponse.newBuilder()\n    .cacheResponse(stripBody(cacheResponse))\n    .networkResponse(stripBody(networkResponse))\n    .build();\n//10.对数据进行缓存\nif (cache != null) {\n  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {\n    // Offer this request to the cache.\n    CacheRequest cacheRequest = cache.put(response);\n    return cacheWritingResponse(cacheRequest, response);\n  }\n\n  if (HttpMethod.invalidatesCache(networkRequest.method())) {\n    try {\n      cache.remove(networkRequest);\n    } catch (IOException ignored) {\n      // The cache cannot be written.\n    }\n  }\n}\n//11.返回网络请求的结果\nreturn response;\n  }\n</code></pre><p>####### 整个过程大致：</p>\n<p>CacheInterceptor主要就是负责Cache的管理</p>\n<ul>\n<li>当网络被禁止访问，缓存不完整，那么返回失败（504）</li>\n<li>缓存可用，返回缓存结果</li>\n<li>当网络访问，返回（304），更新本地缓存</li>\n<li>当Cache失效，删除缓存</li>\n</ul>\n<h5 id=\"4-ConnectInterceptor\"><a href=\"#4-ConnectInterceptor\" class=\"headerlink\" title=\"4.ConnectInterceptor\"></a>4.ConnectInterceptor</h5><p>代码不多，但包含的内容很多。</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   Request request = realChain.request();\n   //拿到StreamAllocation对象。\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n\n   // We need the network to satisfy this request. Possibly for validating a conditional GET.\n   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);\n   HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n   RealConnection connection = streamAllocation.connection();\n\n   return realChain.proceed(request, streamAllocation, httpCodec, connection);\n     }\n</code></pre><p>从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化</p>\n<pre><code>streamAllocation = new StreamAllocation(\nclient.connectionPool(), createAddress(request.url()), callStackTrace);\n</code></pre><p>三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用</p>\n<p>看一下StreamAllocation的构造方法</p>\n<pre><code>public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\nthis.connectionPool = connectionPool;\nthis.address = address;\nthis.routeSelector = new RouteSelector(address, routeDatabase());\nthis.callStackTrace = callStackTrace;\n  }\n</code></pre><p>在把这个三个参数保存为内部变量的同时也创建了一个线路选择器</p>\n<p>streamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。</p>\n<p>接下来继续看StreamAllocation中的newSream()方法</p>\n<pre><code>public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n//读取从OkHttpClient配置的超时时间\nint connectTimeout = client.connectTimeoutMillis();\n//获取读写超时时间\nint readTimeout = client.readTimeoutMillis();\nint writeTimeout = client.writeTimeoutMillis();\n//连接重试\nboolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\ntry {\n//找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n  //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n  HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n  synchronized (connectionPool) {\n    codec = resultCodec;\n    return resultCodec;\n  }\n} catch (IOException e) {\n  throw new RouteException(e);\n}\n  }\n</code></pre><p> 下面就再看一下它是如何找到一个健康的连接的</p>\n<pre><code>private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n    int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n    throws IOException {\n  while (true) {\n  //找到健康的连接\n    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n        connectionRetryEnabled);\n\n    // If this is a brand new connection, we can skip the extensive health checks.\n    synchronized (connectionPool) {\n      if (candidate.successCount == 0) {\n        return candidate;\n      }\n    }\n\n    // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n    // isn&apos;t, take it out of the pool and start again.\n    if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n      noNewStreams();\n      continue;\n    }\n\n    return candidate;\n  }\n}\n</code></pre><p>从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。</p>\n<p>那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法</p>\n<pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    Route selectedRoute;\n    //同步线程池\n    synchronized (connectionPool) {\n      if (released) throw new IllegalStateException(&quot;released&quot;);\n      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n        //尝试使用现有连接，判断是否可用\n      // Attempt to use an already-allocated connection.\n      RealConnection allocatedConnection = this.connection;\n      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) {\n        return allocatedConnection;\n      }\n        //尝试在连接池中获取一个连接，\n      // Attempt to get a connection from the pool.\n      Internal.instance.get(connectionPool, address, this, null);\n      if (connection != null) {\n        return connection;\n      }\n\n      selectedRoute = route;\n    }\n\n    // If we need a route, make one. This is a blocking operation.\n    if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n    }\n\n    RealConnection result;\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n      // This could match due to connection coalescing.\n      Internal.instance.get(connectionPool, address, this, selectedRoute);\n      if (connection != null) {\n        route = selectedRoute;\n        return connection;\n      }\n\n      // Create a connection and assign it to this allocation immediately. This makes it possible\n      // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.\n      route = selectedRoute;\n      refusedStreamCount = 0;\n      result = new RealConnection(connectionPool, selectedRoute);\n      acquire(result);\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      // Pool the connection.\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    return result;\n  }\n</code></pre><p>这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。</p>\n<p>那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p>\n<h5 id=\"5-CallServerInterceptor\"><a href=\"#5-CallServerInterceptor\" class=\"headerlink\" title=\"5.CallServerInterceptor\"></a>5.CallServerInterceptor</h5><p>整个拦截器链中的最后一个拦截器，看一下源码。</p>\n<p>关键方法intercept,如下：</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   HttpCodec httpCodec = realChain.httpStream();\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n   RealConnection connection = (RealConnection) realChain.connection();\n   Request request = realChain.request();\n\n   long sentRequestMillis = System.currentTimeMillis();\n    //1.首先写请求头\n   realChain.eventListener().requestHeadersStart(realChain.call());\n   httpCodec.writeRequestHeaders(request);\n   realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n   Response.Builder responseBuilder = null;\n   if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {\n     // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100\n     // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return\n     // what we did get (such as a 4xx response) without ever transmitting the request body.\n     if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {\n       httpCodec.flushRequest();\n       realChain.eventListener().responseHeadersStart(realChain.call());\n       responseBuilder = httpCodec.readResponseHeaders(true);\n     }\n      //2.然后写请求体\n     if (responseBuilder == null) {\n       // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.\n       realChain.eventListener().requestBodyStart(realChain.call());\n       long contentLength = request.body().contentLength();\n       CountingSink requestBodyOut =\n           new CountingSink(httpCodec.createRequestBody(request, contentLength));\n       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n       request.body().writeTo(bufferedRequestBody);\n       bufferedRequestBody.close();\n       realChain.eventListener()\n           .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n     } else if (!connection.isMultiplexed()) {\n       // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection\n       // from being reused. Otherwise we&apos;re still obligated to transmit the request body to\n       // leave the connection in a consistent state.\n       streamAllocation.noNewStreams();\n     }\n   }\n\n   httpCodec.finishRequest();\n    //读取响应头\n   if (responseBuilder == null) {\n     realChain.eventListener().responseHeadersStart(realChain.call());\n     responseBuilder = httpCodec.readResponseHeaders(false);\n   }\n\n   Response response = responseBuilder\n       .request(request)\n       .handshake(streamAllocation.connection().handshake())\n       .sentRequestAtMillis(sentRequestMillis)\n       .receivedResponseAtMillis(System.currentTimeMillis())\n       .build();\n\n   realChain.eventListener()\n       .responseHeadersEnd(realChain.call(), response);\n   //判断响应码，读取响应体\n   int code = response.code();\n   if (forWebSocket &amp;&amp; code == 101) {\n     // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n     response = response.newBuilder()\n         .body(Util.EMPTY_RESPONSE)\n         .build();\n   } else {\n     response = response.newBuilder()\n         .body(httpCodec.openResponseBody(response))\n         .build();\n   }\n\n   if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))\n       || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {\n     streamAllocation.noNewStreams();\n   }\n\n   if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {\n     throw new ProtocolException(\n         &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());\n   }\n\n   return response;\n }\n</code></pre><p>真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n"},{"title":"OkHttp3源码学习（4）-Dispatcher","date":"2017-07-28T07:47:24.000Z","_content":"\n### 一、基本概念\nOkHttp3 有两种运行方式：\n\n1.同步\n\n2.异步\n\n在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。\n\n* 线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.\n线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。\n\n* 多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程\n\n* 线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。\n\n了解了基本概念，就来看一下OkHttp的任务队列。\n\n从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：\n\t\n* 1.通过对线程进行缓存，减少了创建销毁的时间损失;\n\n* 2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.\n\n### 二、OkHttp请求方式\n\n* 1.同步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t\n\t\tString run(String url) throws IOException {\n\t\t  Request request = new Request.Builder()\n\t\t      .url(url)\n\t\t      .build();\n\t\t\n\t\t  Response response = client.newCall(request).execute();\n\t\t  return response.body().string();\n\t\t}\n\t\t\n* 2.异步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t        Request request = new Request.Builder()\n\t                .url(\"\")\n\t                .build();\n\t        Call call = client.newCall(request);\n\t        try {\n\t            call.enqueue(new okhttp3.Callback() {\n\t                @Override\n\t                public void onFailure(Call call, IOException e) {\n\t                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n\t                }\n\t\n\t                @Override\n\t                public void onResponse(Call call, Response response) throws IOException {\n\t                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n\t                }\n\t            });\n\t        } catch (Exception e) {\n\t            Log.e(\"OkHttp\",e.getMessage());\n\t        }\n\t        \n\t        \n* 先看同步是如何实现的。看源码\n\n  RealCall.java\n\n\t\t@Override public Response execute() throws IOException {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    try {\n\t    //执行同步请求\n\t      client.dispatcher().executed(this);\n\t      Response result = getResponseWithInterceptorChain();\n\t      if (result == null) throw new IOException(\"Canceled\");\n\t      return result;\n\t    } finally {\n\t      client.dispatcher().finished(this);\n\t    }\n\t  \t}\n  \t\n   Dispatcher.java\n\n\t\t\t /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t  synchronized void executed(RealCall call) {\n\t\t    runningSyncCalls.add(call);\n\t\t  }\n\t  \n   直接加入到运行中同步任务队列runningSyncCalls中执行即完成。\n   \n   \n* 异步请求\n\n  RealCall.java\n  \n\t    @Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\t  \t\n  也是通过Dispatcher入队。\n    \n  Dispatcher.java\n  \n\t\t   synchronized void enqueue(AsyncCall call) {\n\t\t    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t      runningAsyncCalls.add(call);\n\t\t      executorService().execute(call);\n\t\t    } else {\n\t\t      readyAsyncCalls.add(call);\n\t\t    }\n\t\t  }\n\n\t\n    根据判断条件，加到对应的队列中。(runningRequests<64 && runningRequestsPerHost<5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n    \n    AsyncCall\n    \n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t\n\t\n\t\n\t当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\t\n\t再看promoteCalls方法\n\t\n\t\tprivate void promoteCalls() {\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t      AsyncCall call = i.next();\n\t\n\t      if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n\t        i.remove();\n\t        runningAsyncCalls.add(call);\n\t        executorService().execute(call);\n\t      }\n\t\n\t      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t    }\n\t  \t}\n\t  \t\n\t 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n\t \n\t \n### 三、OkHttp任务队列\n\n   看一下Dispacher源码\n   \n\t  public final class Dispatcher {\n\t  private int maxRequests = 64;\n\t  private int maxRequestsPerHost = 5;\n\t  private @Nullable Runnable idleCallback;\n\t\n\t  /** Executes calls. Created lazily. */\n\t  private @Nullable ExecutorService executorService;\n\t\n\t  /** Ready async calls in the order they'll be run. */\n\t  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\t\n\t  public Dispatcher(ExecutorService executorService) {\n\t    this.executorService = executorService;\n\t  }\n\t\n\t  public Dispatcher() {\n\t  }\n\t\n\t  public synchronized ExecutorService executorService() {\n\t    if (executorService == null) {\n\t      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t    }\n\t    return executorService;\n\t  }\n\n\n几个重要的知识点：\n\n* readyAsyncCalls ：待执行异步任务队列\n\n* runningAsyncCalls：运行中异步任务队列\n\n* runningSyncCalls：运行中同步任务队列\n\n* executorService：任务队列线程池\n\n几种队列很好理解，再解释一下OkHttp中的队列线程池\n\n 看一下ThreadPoolExecutor.java\n \n\t  public ThreadPoolExecutor(int corePoolSize,\n\t                              int maximumPoolSize,\n\t                              long keepAliveTime,\n\t                              TimeUnit unit,\n\t                              BlockingQueue<Runnable> workQueue,\n\t                              ThreadFactory threadFactory) {\n\t        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n\t             threadFactory, defaultHandler);\n\t    }\n\t    \n解释一下这些参数的具体含义：\n\n* int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁\n\n\n* int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理\n\n\n* long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n\n\n* TimeUnit unit: 时间单位，一般用秒\n\n\n* BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列\n\n\n* ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做\"OkHttp Dispatcher\"的线程工厂。\n\n也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。\n\n\n### 四、Dispatcher\n\ndispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接\n\n![dispatcher](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png)\n\n\n### 五、总结\n\n1. OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行\n\n\n2. Okhttp采用Deque作为缓存，按照入队的顺序先进先出\n\n\n3. OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性\n\n\t \n \n\n\t\n\t\n\t","source":"_posts/OkHttp3源码学习（4）-Dispatcher.md","raw":"---\ntitle: OkHttp3源码学习（4）-Dispatcher\ndate: 2017-07-28 15:47:24\ntags: [OkHttp3]\n---\n\n### 一、基本概念\nOkHttp3 有两种运行方式：\n\n1.同步\n\n2.异步\n\n在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。\n\n* 线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.\n线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。\n\n* 多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程\n\n* 线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。\n\n了解了基本概念，就来看一下OkHttp的任务队列。\n\n从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：\n\t\n* 1.通过对线程进行缓存，减少了创建销毁的时间损失;\n\n* 2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.\n\n### 二、OkHttp请求方式\n\n* 1.同步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t\n\t\tString run(String url) throws IOException {\n\t\t  Request request = new Request.Builder()\n\t\t      .url(url)\n\t\t      .build();\n\t\t\n\t\t  Response response = client.newCall(request).execute();\n\t\t  return response.body().string();\n\t\t}\n\t\t\n* 2.异步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t        Request request = new Request.Builder()\n\t                .url(\"\")\n\t                .build();\n\t        Call call = client.newCall(request);\n\t        try {\n\t            call.enqueue(new okhttp3.Callback() {\n\t                @Override\n\t                public void onFailure(Call call, IOException e) {\n\t                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n\t                }\n\t\n\t                @Override\n\t                public void onResponse(Call call, Response response) throws IOException {\n\t                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n\t                }\n\t            });\n\t        } catch (Exception e) {\n\t            Log.e(\"OkHttp\",e.getMessage());\n\t        }\n\t        \n\t        \n* 先看同步是如何实现的。看源码\n\n  RealCall.java\n\n\t\t@Override public Response execute() throws IOException {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    try {\n\t    //执行同步请求\n\t      client.dispatcher().executed(this);\n\t      Response result = getResponseWithInterceptorChain();\n\t      if (result == null) throw new IOException(\"Canceled\");\n\t      return result;\n\t    } finally {\n\t      client.dispatcher().finished(this);\n\t    }\n\t  \t}\n  \t\n   Dispatcher.java\n\n\t\t\t /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t  synchronized void executed(RealCall call) {\n\t\t    runningSyncCalls.add(call);\n\t\t  }\n\t  \n   直接加入到运行中同步任务队列runningSyncCalls中执行即完成。\n   \n   \n* 异步请求\n\n  RealCall.java\n  \n\t    @Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\t  \t\n  也是通过Dispatcher入队。\n    \n  Dispatcher.java\n  \n\t\t   synchronized void enqueue(AsyncCall call) {\n\t\t    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t      runningAsyncCalls.add(call);\n\t\t      executorService().execute(call);\n\t\t    } else {\n\t\t      readyAsyncCalls.add(call);\n\t\t    }\n\t\t  }\n\n\t\n    根据判断条件，加到对应的队列中。(runningRequests<64 && runningRequestsPerHost<5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n    \n    AsyncCall\n    \n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t\n\t\n\t\n\t当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\t\n\t再看promoteCalls方法\n\t\n\t\tprivate void promoteCalls() {\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t      AsyncCall call = i.next();\n\t\n\t      if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n\t        i.remove();\n\t        runningAsyncCalls.add(call);\n\t        executorService().execute(call);\n\t      }\n\t\n\t      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t    }\n\t  \t}\n\t  \t\n\t 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n\t \n\t \n### 三、OkHttp任务队列\n\n   看一下Dispacher源码\n   \n\t  public final class Dispatcher {\n\t  private int maxRequests = 64;\n\t  private int maxRequestsPerHost = 5;\n\t  private @Nullable Runnable idleCallback;\n\t\n\t  /** Executes calls. Created lazily. */\n\t  private @Nullable ExecutorService executorService;\n\t\n\t  /** Ready async calls in the order they'll be run. */\n\t  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\t\n\t  public Dispatcher(ExecutorService executorService) {\n\t    this.executorService = executorService;\n\t  }\n\t\n\t  public Dispatcher() {\n\t  }\n\t\n\t  public synchronized ExecutorService executorService() {\n\t    if (executorService == null) {\n\t      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t    }\n\t    return executorService;\n\t  }\n\n\n几个重要的知识点：\n\n* readyAsyncCalls ：待执行异步任务队列\n\n* runningAsyncCalls：运行中异步任务队列\n\n* runningSyncCalls：运行中同步任务队列\n\n* executorService：任务队列线程池\n\n几种队列很好理解，再解释一下OkHttp中的队列线程池\n\n 看一下ThreadPoolExecutor.java\n \n\t  public ThreadPoolExecutor(int corePoolSize,\n\t                              int maximumPoolSize,\n\t                              long keepAliveTime,\n\t                              TimeUnit unit,\n\t                              BlockingQueue<Runnable> workQueue,\n\t                              ThreadFactory threadFactory) {\n\t        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n\t             threadFactory, defaultHandler);\n\t    }\n\t    \n解释一下这些参数的具体含义：\n\n* int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁\n\n\n* int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理\n\n\n* long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n\n\n* TimeUnit unit: 时间单位，一般用秒\n\n\n* BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列\n\n\n* ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做\"OkHttp Dispatcher\"的线程工厂。\n\n也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。\n\n\n### 四、Dispatcher\n\ndispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接\n\n![dispatcher](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png)\n\n\n### 五、总结\n\n1. OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行\n\n\n2. Okhttp采用Deque作为缓存，按照入队的顺序先进先出\n\n\n3. OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性\n\n\t \n \n\n\t\n\t\n\t","slug":"OkHttp3源码学习（4）-Dispatcher","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnx001zx3c0gr9g5uky","content":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>OkHttp3 有两种运行方式：</p>\n<p>1.同步</p>\n<p>2.异步</p>\n<p>在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。</p>\n<ul>\n<li><p>线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。<br>线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.<br>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。</p>\n</li>\n<li><p>多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程</p>\n</li>\n<li><p>线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>\n</li>\n</ul>\n<p>了解了基本概念，就来看一下OkHttp的任务队列。</p>\n<p>从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：</p>\n<ul>\n<li><p>1.通过对线程进行缓存，减少了创建销毁的时间损失;</p>\n</li>\n<li><p>2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.</p>\n</li>\n</ul>\n<h3 id=\"二、OkHttp请求方式\"><a href=\"#二、OkHttp请求方式\" class=\"headerlink\" title=\"二、OkHttp请求方式\"></a>二、OkHttp请求方式</h3><ul>\n<li><p>1.同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\n  Request request = new Request.Builder()\n      .url(url)\n      .build();\n\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>2.异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>先看同步是如何实现的。看源码</p>\n<p>RealCall.java</p>\n<pre><code>@Override public Response execute() throws IOException {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\ntry {\n//执行同步请求\n  client.dispatcher().executed(this);\n  Response result = getResponseWithInterceptorChain();\n  if (result == null) throw new IOException(&quot;Canceled&quot;);\n  return result;\n} finally {\n  client.dispatcher().finished(this);\n}\n  }\n</code></pre><p> Dispatcher.java</p>\n<pre><code>   /** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n  runningSyncCalls.add(call);\n}\n</code></pre><p> 直接加入到运行中同步任务队列runningSyncCalls中执行即完成。</p>\n</li>\n</ul>\n<ul>\n<li><p>异步请求</p>\n<p>RealCall.java</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre><p>也是通过Dispatcher入队。</p>\n<p>Dispatcher.java</p>\n<pre><code> synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n    runningAsyncCalls.add(call);\n    executorService().execute(call);\n  } else {\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>根据判断条件，加到对应的队列中。(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n\nAsyncCall\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n\n\n\n当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\n再看promoteCalls方法\n\n    private void promoteCalls() {\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n    }\n      }\n\n 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n</code></pre><h3 id=\"三、OkHttp任务队列\"><a href=\"#三、OkHttp任务队列\" class=\"headerlink\" title=\"三、OkHttp任务队列\"></a>三、OkHttp任务队列</h3><p>   看一下Dispacher源码</p>\n<pre><code>public final class Dispatcher {\nprivate int maxRequests = 64;\nprivate int maxRequestsPerHost = 5;\nprivate @Nullable Runnable idleCallback;\n\n/** Executes calls. Created lazily. */\nprivate @Nullable ExecutorService executorService;\n\n/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n\npublic Dispatcher(ExecutorService executorService) {\n  this.executorService = executorService;\n}\n\npublic Dispatcher() {\n}\n\npublic synchronized ExecutorService executorService() {\n  if (executorService == null) {\n    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n  }\n  return executorService;\n}\n</code></pre><p>几个重要的知识点：</p>\n<ul>\n<li><p>readyAsyncCalls ：待执行异步任务队列</p>\n</li>\n<li><p>runningAsyncCalls：运行中异步任务队列</p>\n</li>\n<li><p>runningSyncCalls：运行中同步任务队列</p>\n</li>\n<li><p>executorService：任务队列线程池</p>\n</li>\n</ul>\n<p>几种队列很好理解，再解释一下OkHttp中的队列线程池</p>\n<p> 看一下ThreadPoolExecutor.java</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue&lt;Runnable&gt; workQueue,\n                            ThreadFactory threadFactory) {\n      this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n           threadFactory, defaultHandler);\n  }\n</code></pre><p>解释一下这些参数的具体含义：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>\n</ul>\n<ul>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>\n</ul>\n<ul>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n</ul>\n<ul>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n</ul>\n<ul>\n<li>BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列</li>\n</ul>\n<ul>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p>\n<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>\n<h3 id=\"四、Dispatcher\"><a href=\"#四、Dispatcher\" class=\"headerlink\" title=\"四、Dispatcher\"></a>四、Dispatcher</h3><p>dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png\" alt=\"dispatcher\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><ol>\n<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行</li>\n</ol>\n<ol>\n<li>Okhttp采用Deque作为缓存，按照入队的顺序先进先出</li>\n</ol>\n<ol>\n<li>OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>OkHttp3 有两种运行方式：</p>\n<p>1.同步</p>\n<p>2.异步</p>\n<p>在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。</p>\n<ul>\n<li><p>线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。<br>线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.<br>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。</p>\n</li>\n<li><p>多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程</p>\n</li>\n<li><p>线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>\n</li>\n</ul>\n<p>了解了基本概念，就来看一下OkHttp的任务队列。</p>\n<p>从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：</p>\n<ul>\n<li><p>1.通过对线程进行缓存，减少了创建销毁的时间损失;</p>\n</li>\n<li><p>2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.</p>\n</li>\n</ul>\n<h3 id=\"二、OkHttp请求方式\"><a href=\"#二、OkHttp请求方式\" class=\"headerlink\" title=\"二、OkHttp请求方式\"></a>二、OkHttp请求方式</h3><ul>\n<li><p>1.同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\n  Request request = new Request.Builder()\n      .url(url)\n      .build();\n\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>2.异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>先看同步是如何实现的。看源码</p>\n<p>RealCall.java</p>\n<pre><code>@Override public Response execute() throws IOException {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\ntry {\n//执行同步请求\n  client.dispatcher().executed(this);\n  Response result = getResponseWithInterceptorChain();\n  if (result == null) throw new IOException(&quot;Canceled&quot;);\n  return result;\n} finally {\n  client.dispatcher().finished(this);\n}\n  }\n</code></pre><p> Dispatcher.java</p>\n<pre><code>   /** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n  runningSyncCalls.add(call);\n}\n</code></pre><p> 直接加入到运行中同步任务队列runningSyncCalls中执行即完成。</p>\n</li>\n</ul>\n<ul>\n<li><p>异步请求</p>\n<p>RealCall.java</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre><p>也是通过Dispatcher入队。</p>\n<p>Dispatcher.java</p>\n<pre><code> synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n    runningAsyncCalls.add(call);\n    executorService().execute(call);\n  } else {\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>根据判断条件，加到对应的队列中。(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n\nAsyncCall\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n\n\n\n当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\n再看promoteCalls方法\n\n    private void promoteCalls() {\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n    }\n      }\n\n 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n</code></pre><h3 id=\"三、OkHttp任务队列\"><a href=\"#三、OkHttp任务队列\" class=\"headerlink\" title=\"三、OkHttp任务队列\"></a>三、OkHttp任务队列</h3><p>   看一下Dispacher源码</p>\n<pre><code>public final class Dispatcher {\nprivate int maxRequests = 64;\nprivate int maxRequestsPerHost = 5;\nprivate @Nullable Runnable idleCallback;\n\n/** Executes calls. Created lazily. */\nprivate @Nullable ExecutorService executorService;\n\n/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n\npublic Dispatcher(ExecutorService executorService) {\n  this.executorService = executorService;\n}\n\npublic Dispatcher() {\n}\n\npublic synchronized ExecutorService executorService() {\n  if (executorService == null) {\n    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n  }\n  return executorService;\n}\n</code></pre><p>几个重要的知识点：</p>\n<ul>\n<li><p>readyAsyncCalls ：待执行异步任务队列</p>\n</li>\n<li><p>runningAsyncCalls：运行中异步任务队列</p>\n</li>\n<li><p>runningSyncCalls：运行中同步任务队列</p>\n</li>\n<li><p>executorService：任务队列线程池</p>\n</li>\n</ul>\n<p>几种队列很好理解，再解释一下OkHttp中的队列线程池</p>\n<p> 看一下ThreadPoolExecutor.java</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue&lt;Runnable&gt; workQueue,\n                            ThreadFactory threadFactory) {\n      this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n           threadFactory, defaultHandler);\n  }\n</code></pre><p>解释一下这些参数的具体含义：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>\n</ul>\n<ul>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>\n</ul>\n<ul>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n</ul>\n<ul>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n</ul>\n<ul>\n<li>BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列</li>\n</ul>\n<ul>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p>\n<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>\n<h3 id=\"四、Dispatcher\"><a href=\"#四、Dispatcher\" class=\"headerlink\" title=\"四、Dispatcher\"></a>四、Dispatcher</h3><p>dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png\" alt=\"dispatcher\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><ol>\n<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行</li>\n</ol>\n<ol>\n<li>Okhttp采用Deque作为缓存，按照入队的顺序先进先出</li>\n</ol>\n<ol>\n<li>OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性</li>\n</ol>\n"},{"title":"PackageManager使用姿势","date":"2017-10-25T12:04:03.000Z","_content":"\nPackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。\n\n#### 一、主要功能\n\n1. 安装、卸载应用\n2. 查询权限\n3. 查询Application相关信息\n\n#### 二、常用方法\n\n1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：\n GET_ACTIVITIES\nGET_GIDS\nGET_CONFIGURATIONS\nGET_INSTRUMENTATION\nGET_PERMISSIONS\nGET_PROVIDERS\nGET_RECEIVERS\nGET_SERVICES\nGET_SIGNATURES\nGET_UNINSTALLED_PACKAGES\n（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids\n\n（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息\n\n（4）、public abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合\n\n（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,\n    int flags)根据指定的Group名称获取PermissionGroupInfo对象。\n\n（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,\n            int flags)，根据指定的包名获取ApplicationInfo信息。\n\n（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,\n            int flags)，根据指定的组件，获取ActivityInfo信息\n\n（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,\n            int flags)，根据指定组件获取ServiceInfo\n\n（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,\n            int flags)，根据指定组件名称获取ProviderInfo信息\n\n（10）、public abstract List<PackageInfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息\n\n（11）、public abstract List<PackageInfo> getPackagesHoldingPermissions(\n            String[] permissions, int flags);获取具有特定权限的PackagInfo\n\n（12）、public abstract List<ApplicationInfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息\n\n（13）、public abstract boolean addPermission(PermissionInfo info);添加权限\n\n（14）、public abstract void removePermission(String name);移除权限\n\n2、PackageInfo用于描述mainfest中所有描述信息。    \n常见字段：   \n（1）、public String packageName;包名    \n（2）、public String[] splitNames;   \n（3）、public int versionCode;版本号　　　　　\n（4）、public String versionName;版本名称    \n（5）、public ApplicationInfo applicationInfo;    \n（6）、public long firstInstallTime;第一次安装时间   \n（7）、public long lastUpdateTime;上次更新时间     \n（8）、public ActivityInfo[] activities;所有的Activity信息     \n（9）、public ActivityInfo[] receivers; 所有的广播接收者    \n（10）、public ServiceInfo[] services;所有的服务信息     \n（11）、public ProviderInfo[] providers;获取ContentProvide     \n（12）、public PermissionInfo[] permissions;所有的权限信息\n\n\n#### 三、AndroidManifest文件结构\n\n首先看一下AndroidManifest.xml文件结构。\n\n例如：\n\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.test\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <service\n        \tandroid:name=\"testservice\"\n        \tandroid:enable=\"true\"\n        \tandroid:exproted=\"true\">\n        \t</service>\n    </application>\n\n\t</manifest>\n\t\n\t\n\t\n\t\n根据AndroidManifest的各个节点可以看出来其中的对应关系：\n\t\n\t* 一个Package对应一个Application\n\t* 一个Application对应n个Activity、Service等等\n\n* 通过包名判断APP是否安装\n* 通过遍历获取AndroidManifest.xml文件信息\n\t\n\t\n\n\n#### 四、获取信息\n\n\n##### 1.ApplicationInfo类测试：获取Application节点信息\n\n  * 示例：\n\n\t\t\tApplicationInfo applicationInfo = getApplicationInfo();  \n\t\t\t Log.d(\"lsh\",applicationInfo.className + \"\\n\" +  \n\t\t\t        applicationInfo.dataDir+\"\\n\" +  \n\t\t\t        applicationInfo.permission + \"\\n\"  \n\t\t\t        + applicationInfo.packageName + \"\\n\"  \n\t\t\t        + applicationInfo.processName + \"\\n\"  \n\t\t\t        + applicationInfo.taskAffinity + \"\\n\"  \n\t\t\t);  \n\t\n\n * Logcat:\n\n\t\t\t3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n\t\t\t    /data/data/com.example.liushihan.glidedemo\n\t\t\t    null\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \t\n##### 2. 获取所有安装的Packages\n\n  * 示例：\n\n\t\t\tList<PackageInfo> listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n\n\n   * Logcat:\n   部分日志\n\n\t\t\t D/lsh: PackageInfo{132b54a7 com.android.smoketest}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n\t\t\t\n\t\t\t\n\t\t\t\n##### 3. 获取指定应用的PackageInfo\n\n * 示例：\n\n\t\t\tPackageManager packageManager = getPackageManager();\n\t\t\t        PackageInfo packageInfo = null;\n\t\t\t        try {\n\t\t\t            packageInfo = packageManager.getPackageInfo(\"com.example.liushihan\",\n\t\t\t                    PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh\", packageInfo.packageName + \"\\n\"\n\t\t\t                    + packageInfo.versionName + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n * Logcat\n\n\t\t\t D/lsh: com.example.liushihan.glidedemo\n\t\t\t                             1.0\n\t\t\t                             \n\t\t\t                             \n\t\t\t       \n##### 4. 获取应用程序中的permission\n\n * 示例：\n\n\t\t\t   try {\n\t\t\t            PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(\"android.permission.INTERNET\",\n\t\t\t                    PermissionInfo.PROTECTION_NORMAL);\n\t\t\t            List<PermissionGroupInfo> list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n\t\t\t            Log.d(\"lsh\",\n\t\t\t                    permissionInfo.group + \"\\n\"\n\t\t\t                            + permissionInfo.packageName + \"\\n\"\n\t\t\t                            + permissionInfo.name + \"\\n\"\n\t\t\t                            + permissionInfo.flags + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n   * Logcat:\n\n\t\t    D/lsh: android.permission-group.NETWORK\n\t\t                                      android\n\t\t                                      android.permission.INTERNET\n\t\t                                      0\n\t\t                                      \n                  \n                  \n##### 5. 获取应用程序中执行的ActivityInfo\n\n * 示例：\n\n\n\t\t\tComponentName componentName = new ComponentName(\"com.example.liushihan.glidedemo\",\"com.example.liushihan.glidedemo.MainActivity\");\n\t\t\t        try {\n\t\t\t            @SuppressLint(\"WrongConstant\") ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh:activityInfo\",activityInfo.name + \"\\n\"\n\t\t\t                    + activityInfo.packageName +\"\\n\"\n\t\t\t                    + activityInfo.targetActivity\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }  \n\t\t        \n\t\t        \n * Logcat:\n\n\t\t\t\n\t\t\t4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n\t\t\t                                                                                 com.example.liushihan.glidedemo\n\t\t\t                                                                                 null\n\t\t                                                                                 \n\t\t                                                                                 ","source":"_posts/PackageManager使用姿势.md","raw":"---\ntitle: PackageManager使用姿势\ndate: 2017-10-25 20:04:03\ntags: [PackageManager]\n---\n\nPackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。\n\n#### 一、主要功能\n\n1. 安装、卸载应用\n2. 查询权限\n3. 查询Application相关信息\n\n#### 二、常用方法\n\n1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：\n GET_ACTIVITIES\nGET_GIDS\nGET_CONFIGURATIONS\nGET_INSTRUMENTATION\nGET_PERMISSIONS\nGET_PROVIDERS\nGET_RECEIVERS\nGET_SERVICES\nGET_SIGNATURES\nGET_UNINSTALLED_PACKAGES\n（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids\n\n（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息\n\n（4）、public abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合\n\n（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,\n    int flags)根据指定的Group名称获取PermissionGroupInfo对象。\n\n（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,\n            int flags)，根据指定的包名获取ApplicationInfo信息。\n\n（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,\n            int flags)，根据指定的组件，获取ActivityInfo信息\n\n（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,\n            int flags)，根据指定组件获取ServiceInfo\n\n（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,\n            int flags)，根据指定组件名称获取ProviderInfo信息\n\n（10）、public abstract List<PackageInfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息\n\n（11）、public abstract List<PackageInfo> getPackagesHoldingPermissions(\n            String[] permissions, int flags);获取具有特定权限的PackagInfo\n\n（12）、public abstract List<ApplicationInfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息\n\n（13）、public abstract boolean addPermission(PermissionInfo info);添加权限\n\n（14）、public abstract void removePermission(String name);移除权限\n\n2、PackageInfo用于描述mainfest中所有描述信息。    \n常见字段：   \n（1）、public String packageName;包名    \n（2）、public String[] splitNames;   \n（3）、public int versionCode;版本号　　　　　\n（4）、public String versionName;版本名称    \n（5）、public ApplicationInfo applicationInfo;    \n（6）、public long firstInstallTime;第一次安装时间   \n（7）、public long lastUpdateTime;上次更新时间     \n（8）、public ActivityInfo[] activities;所有的Activity信息     \n（9）、public ActivityInfo[] receivers; 所有的广播接收者    \n（10）、public ServiceInfo[] services;所有的服务信息     \n（11）、public ProviderInfo[] providers;获取ContentProvide     \n（12）、public PermissionInfo[] permissions;所有的权限信息\n\n\n#### 三、AndroidManifest文件结构\n\n首先看一下AndroidManifest.xml文件结构。\n\n例如：\n\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.test\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <service\n        \tandroid:name=\"testservice\"\n        \tandroid:enable=\"true\"\n        \tandroid:exproted=\"true\">\n        \t</service>\n    </application>\n\n\t</manifest>\n\t\n\t\n\t\n\t\n根据AndroidManifest的各个节点可以看出来其中的对应关系：\n\t\n\t* 一个Package对应一个Application\n\t* 一个Application对应n个Activity、Service等等\n\n* 通过包名判断APP是否安装\n* 通过遍历获取AndroidManifest.xml文件信息\n\t\n\t\n\n\n#### 四、获取信息\n\n\n##### 1.ApplicationInfo类测试：获取Application节点信息\n\n  * 示例：\n\n\t\t\tApplicationInfo applicationInfo = getApplicationInfo();  \n\t\t\t Log.d(\"lsh\",applicationInfo.className + \"\\n\" +  \n\t\t\t        applicationInfo.dataDir+\"\\n\" +  \n\t\t\t        applicationInfo.permission + \"\\n\"  \n\t\t\t        + applicationInfo.packageName + \"\\n\"  \n\t\t\t        + applicationInfo.processName + \"\\n\"  \n\t\t\t        + applicationInfo.taskAffinity + \"\\n\"  \n\t\t\t);  \n\t\n\n * Logcat:\n\n\t\t\t3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n\t\t\t    /data/data/com.example.liushihan.glidedemo\n\t\t\t    null\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \t\n##### 2. 获取所有安装的Packages\n\n  * 示例：\n\n\t\t\tList<PackageInfo> listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n\n\n   * Logcat:\n   部分日志\n\n\t\t\t D/lsh: PackageInfo{132b54a7 com.android.smoketest}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n\t\t\t\n\t\t\t\n\t\t\t\n##### 3. 获取指定应用的PackageInfo\n\n * 示例：\n\n\t\t\tPackageManager packageManager = getPackageManager();\n\t\t\t        PackageInfo packageInfo = null;\n\t\t\t        try {\n\t\t\t            packageInfo = packageManager.getPackageInfo(\"com.example.liushihan\",\n\t\t\t                    PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh\", packageInfo.packageName + \"\\n\"\n\t\t\t                    + packageInfo.versionName + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n * Logcat\n\n\t\t\t D/lsh: com.example.liushihan.glidedemo\n\t\t\t                             1.0\n\t\t\t                             \n\t\t\t                             \n\t\t\t       \n##### 4. 获取应用程序中的permission\n\n * 示例：\n\n\t\t\t   try {\n\t\t\t            PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(\"android.permission.INTERNET\",\n\t\t\t                    PermissionInfo.PROTECTION_NORMAL);\n\t\t\t            List<PermissionGroupInfo> list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n\t\t\t            Log.d(\"lsh\",\n\t\t\t                    permissionInfo.group + \"\\n\"\n\t\t\t                            + permissionInfo.packageName + \"\\n\"\n\t\t\t                            + permissionInfo.name + \"\\n\"\n\t\t\t                            + permissionInfo.flags + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n   * Logcat:\n\n\t\t    D/lsh: android.permission-group.NETWORK\n\t\t                                      android\n\t\t                                      android.permission.INTERNET\n\t\t                                      0\n\t\t                                      \n                  \n                  \n##### 5. 获取应用程序中执行的ActivityInfo\n\n * 示例：\n\n\n\t\t\tComponentName componentName = new ComponentName(\"com.example.liushihan.glidedemo\",\"com.example.liushihan.glidedemo.MainActivity\");\n\t\t\t        try {\n\t\t\t            @SuppressLint(\"WrongConstant\") ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh:activityInfo\",activityInfo.name + \"\\n\"\n\t\t\t                    + activityInfo.packageName +\"\\n\"\n\t\t\t                    + activityInfo.targetActivity\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }  \n\t\t        \n\t\t        \n * Logcat:\n\n\t\t\t\n\t\t\t4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n\t\t\t                                                                                 com.example.liushihan.glidedemo\n\t\t\t                                                                                 null\n\t\t                                                                                 \n\t\t                                                                                 ","slug":"PackageManager使用姿势","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tny0021x3c013edpurf","content":"<p>PackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。</p>\n<h4 id=\"一、主要功能\"><a href=\"#一、主要功能\" class=\"headerlink\" title=\"一、主要功能\"></a>一、主要功能</h4><ol>\n<li>安装、卸载应用</li>\n<li>查询权限</li>\n<li>查询Application相关信息</li>\n</ol>\n<h4 id=\"二、常用方法\"><a href=\"#二、常用方法\" class=\"headerlink\" title=\"二、常用方法\"></a>二、常用方法</h4><p>1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：<br> GET_ACTIVITIES<br>GET_GIDS<br>GET_CONFIGURATIONS<br>GET_INSTRUMENTATION<br>GET_PERMISSIONS<br>GET_PROVIDERS<br>GET_RECEIVERS<br>GET_SERVICES<br>GET_SIGNATURES<br>GET_UNINSTALLED_PACKAGES<br>（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids</p>\n<p>（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息</p>\n<p>（4）、public abstract List<permissiongroupinfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合</permissiongroupinfo></p>\n<p>（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,<br>    int flags)根据指定的Group名称获取PermissionGroupInfo对象。</p>\n<p>（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,<br>            int flags)，根据指定的包名获取ApplicationInfo信息。</p>\n<p>（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,<br>            int flags)，根据指定的组件，获取ActivityInfo信息</p>\n<p>（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,<br>            int flags)，根据指定组件获取ServiceInfo</p>\n<p>（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,<br>            int flags)，根据指定组件名称获取ProviderInfo信息</p>\n<p>（10）、public abstract List<packageinfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息</packageinfo></p>\n<p>（11）、public abstract List<packageinfo> getPackagesHoldingPermissions(<br>            String[] permissions, int flags);获取具有特定权限的PackagInfo</packageinfo></p>\n<p>（12）、public abstract List<applicationinfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息</applicationinfo></p>\n<p>（13）、public abstract boolean addPermission(PermissionInfo info);添加权限</p>\n<p>（14）、public abstract void removePermission(String name);移除权限</p>\n<p>2、PackageInfo用于描述mainfest中所有描述信息。<br>常见字段：<br>（1）、public String packageName;包名<br>（2）、public String[] splitNames;<br>（3）、public int versionCode;版本号　　　　　<br>（4）、public String versionName;版本名称<br>（5）、public ApplicationInfo applicationInfo;<br>（6）、public long firstInstallTime;第一次安装时间<br>（7）、public long lastUpdateTime;上次更新时间<br>（8）、public ActivityInfo[] activities;所有的Activity信息<br>（9）、public ActivityInfo[] receivers; 所有的广播接收者<br>（10）、public ServiceInfo[] services;所有的服务信息<br>（11）、public ProviderInfo[] providers;获取ContentProvide<br>（12）、public PermissionInfo[] permissions;所有的权限信息</p>\n<h4 id=\"三、AndroidManifest文件结构\"><a href=\"#三、AndroidManifest文件结构\" class=\"headerlink\" title=\"三、AndroidManifest文件结构\"></a>三、AndroidManifest文件结构</h4><p>首先看一下AndroidManifest.xml文件结构。</p>\n<p>例如：</p>\n<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.test&quot;&gt;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n&lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@mipmap/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n    android:supportsRtl=&quot;true&quot;\n    android:theme=&quot;@style/AppTheme&quot;&gt;\n    &lt;activity android:name=&quot;.TestActivity&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n    &lt;service\n        android:name=&quot;testservice&quot;\n        android:enable=&quot;true&quot;\n        android:exproted=&quot;true&quot;&gt;\n        &lt;/service&gt;\n&lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre><p>根据AndroidManifest的各个节点可以看出来其中的对应关系：</p>\n<pre><code>* 一个Package对应一个Application\n* 一个Application对应n个Activity、Service等等\n</code></pre><ul>\n<li>通过包名判断APP是否安装</li>\n<li>通过遍历获取AndroidManifest.xml文件信息</li>\n</ul>\n<h4 id=\"四、获取信息\"><a href=\"#四、获取信息\" class=\"headerlink\" title=\"四、获取信息\"></a>四、获取信息</h4><h5 id=\"1-ApplicationInfo类测试：获取Application节点信息\"><a href=\"#1-ApplicationInfo类测试：获取Application节点信息\" class=\"headerlink\" title=\"1.ApplicationInfo类测试：获取Application节点信息\"></a>1.ApplicationInfo类测试：获取Application节点信息</h5><ul>\n<li><p>示例：</p>\n<pre><code>ApplicationInfo applicationInfo = getApplicationInfo();  \n Log.d(&quot;lsh&quot;,applicationInfo.className + &quot;\\n&quot; +  \n        applicationInfo.dataDir+&quot;\\n&quot; +  \n        applicationInfo.permission + &quot;\\n&quot;  \n        + applicationInfo.packageName + &quot;\\n&quot;  \n        + applicationInfo.processName + &quot;\\n&quot;  \n        + applicationInfo.taskAffinity + &quot;\\n&quot;  \n);  \n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n    /data/data/com.example.liushihan.glidedemo\n    null\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n</code></pre></li>\n</ul>\n<h5 id=\"2-获取所有安装的Packages\"><a href=\"#2-获取所有安装的Packages\" class=\"headerlink\" title=\"2. 获取所有安装的Packages\"></a>2. 获取所有安装的Packages</h5><ul>\n<li><p>示例：</p>\n<pre><code>List&lt;PackageInfo&gt; listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:<br>部分日志</p>\n<pre><code> D/lsh: PackageInfo{132b54a7 com.android.smoketest}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n</code></pre></li>\n</ul>\n<h5 id=\"3-获取指定应用的PackageInfo\"><a href=\"#3-获取指定应用的PackageInfo\" class=\"headerlink\" title=\"3. 获取指定应用的PackageInfo\"></a>3. 获取指定应用的PackageInfo</h5><ul>\n<li><p>示例：</p>\n<pre><code>PackageManager packageManager = getPackageManager();\n        PackageInfo packageInfo = null;\n        try {\n            packageInfo = packageManager.getPackageInfo(&quot;com.example.liushihan&quot;,\n                    PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh&quot;, packageInfo.packageName + &quot;\\n&quot;\n                    + packageInfo.versionName + &quot;\\n&quot;\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat</p>\n<pre><code>D/lsh: com.example.liushihan.glidedemo\n                            1.0\n</code></pre></li>\n</ul>\n<h5 id=\"4-获取应用程序中的permission\"><a href=\"#4-获取应用程序中的permission\" class=\"headerlink\" title=\"4. 获取应用程序中的permission\"></a>4. 获取应用程序中的permission</h5><ul>\n<li><p>示例：</p>\n<pre><code>try {\n         PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(&quot;android.permission.INTERNET&quot;,\n                 PermissionInfo.PROTECTION_NORMAL);\n         List&lt;PermissionGroupInfo&gt; list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n         Log.d(&quot;lsh&quot;,\n                 permissionInfo.group + &quot;\\n&quot;\n                         + permissionInfo.packageName + &quot;\\n&quot;\n                         + permissionInfo.name + &quot;\\n&quot;\n                         + permissionInfo.flags + &quot;\\n&quot;\n         );\n     } catch (PackageManager.NameNotFoundException e) {\n         e.printStackTrace();\n     }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>D/lsh: android.permission-group.NETWORK\n                                  android\n                                  android.permission.INTERNET\n                                  0\n</code></pre></li>\n</ul>\n<h5 id=\"5-获取应用程序中执行的ActivityInfo\"><a href=\"#5-获取应用程序中执行的ActivityInfo\" class=\"headerlink\" title=\"5. 获取应用程序中执行的ActivityInfo\"></a>5. 获取应用程序中执行的ActivityInfo</h5><ul>\n<li>示例：</li>\n</ul>\n<pre><code>ComponentName componentName = new ComponentName(&quot;com.example.liushihan.glidedemo&quot;,&quot;com.example.liushihan.glidedemo.MainActivity&quot;);\n        try {\n            @SuppressLint(&quot;WrongConstant&quot;) ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh:activityInfo&quot;,activityInfo.name + &quot;\\n&quot;\n                    + activityInfo.packageName +&quot;\\n&quot;\n                    + activityInfo.targetActivity\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }  \n</code></pre><ul>\n<li>Logcat:</li>\n</ul>\n<pre><code>4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n                                                                                 com.example.liushihan.glidedemo\n                                                                                 null\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>PackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。</p>\n<h4 id=\"一、主要功能\"><a href=\"#一、主要功能\" class=\"headerlink\" title=\"一、主要功能\"></a>一、主要功能</h4><ol>\n<li>安装、卸载应用</li>\n<li>查询权限</li>\n<li>查询Application相关信息</li>\n</ol>\n<h4 id=\"二、常用方法\"><a href=\"#二、常用方法\" class=\"headerlink\" title=\"二、常用方法\"></a>二、常用方法</h4><p>1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：<br> GET_ACTIVITIES<br>GET_GIDS<br>GET_CONFIGURATIONS<br>GET_INSTRUMENTATION<br>GET_PERMISSIONS<br>GET_PROVIDERS<br>GET_RECEIVERS<br>GET_SERVICES<br>GET_SIGNATURES<br>GET_UNINSTALLED_PACKAGES<br>（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids</p>\n<p>（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息</p>\n<p>（4）、public abstract List<permissiongroupinfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合</permissiongroupinfo></p>\n<p>（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,<br>    int flags)根据指定的Group名称获取PermissionGroupInfo对象。</p>\n<p>（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,<br>            int flags)，根据指定的包名获取ApplicationInfo信息。</p>\n<p>（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,<br>            int flags)，根据指定的组件，获取ActivityInfo信息</p>\n<p>（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,<br>            int flags)，根据指定组件获取ServiceInfo</p>\n<p>（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,<br>            int flags)，根据指定组件名称获取ProviderInfo信息</p>\n<p>（10）、public abstract List<packageinfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息</packageinfo></p>\n<p>（11）、public abstract List<packageinfo> getPackagesHoldingPermissions(<br>            String[] permissions, int flags);获取具有特定权限的PackagInfo</packageinfo></p>\n<p>（12）、public abstract List<applicationinfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息</applicationinfo></p>\n<p>（13）、public abstract boolean addPermission(PermissionInfo info);添加权限</p>\n<p>（14）、public abstract void removePermission(String name);移除权限</p>\n<p>2、PackageInfo用于描述mainfest中所有描述信息。<br>常见字段：<br>（1）、public String packageName;包名<br>（2）、public String[] splitNames;<br>（3）、public int versionCode;版本号　　　　　<br>（4）、public String versionName;版本名称<br>（5）、public ApplicationInfo applicationInfo;<br>（6）、public long firstInstallTime;第一次安装时间<br>（7）、public long lastUpdateTime;上次更新时间<br>（8）、public ActivityInfo[] activities;所有的Activity信息<br>（9）、public ActivityInfo[] receivers; 所有的广播接收者<br>（10）、public ServiceInfo[] services;所有的服务信息<br>（11）、public ProviderInfo[] providers;获取ContentProvide<br>（12）、public PermissionInfo[] permissions;所有的权限信息</p>\n<h4 id=\"三、AndroidManifest文件结构\"><a href=\"#三、AndroidManifest文件结构\" class=\"headerlink\" title=\"三、AndroidManifest文件结构\"></a>三、AndroidManifest文件结构</h4><p>首先看一下AndroidManifest.xml文件结构。</p>\n<p>例如：</p>\n<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.test&quot;&gt;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n&lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@mipmap/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n    android:supportsRtl=&quot;true&quot;\n    android:theme=&quot;@style/AppTheme&quot;&gt;\n    &lt;activity android:name=&quot;.TestActivity&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n    &lt;service\n        android:name=&quot;testservice&quot;\n        android:enable=&quot;true&quot;\n        android:exproted=&quot;true&quot;&gt;\n        &lt;/service&gt;\n&lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre><p>根据AndroidManifest的各个节点可以看出来其中的对应关系：</p>\n<pre><code>* 一个Package对应一个Application\n* 一个Application对应n个Activity、Service等等\n</code></pre><ul>\n<li>通过包名判断APP是否安装</li>\n<li>通过遍历获取AndroidManifest.xml文件信息</li>\n</ul>\n<h4 id=\"四、获取信息\"><a href=\"#四、获取信息\" class=\"headerlink\" title=\"四、获取信息\"></a>四、获取信息</h4><h5 id=\"1-ApplicationInfo类测试：获取Application节点信息\"><a href=\"#1-ApplicationInfo类测试：获取Application节点信息\" class=\"headerlink\" title=\"1.ApplicationInfo类测试：获取Application节点信息\"></a>1.ApplicationInfo类测试：获取Application节点信息</h5><ul>\n<li><p>示例：</p>\n<pre><code>ApplicationInfo applicationInfo = getApplicationInfo();  \n Log.d(&quot;lsh&quot;,applicationInfo.className + &quot;\\n&quot; +  \n        applicationInfo.dataDir+&quot;\\n&quot; +  \n        applicationInfo.permission + &quot;\\n&quot;  \n        + applicationInfo.packageName + &quot;\\n&quot;  \n        + applicationInfo.processName + &quot;\\n&quot;  \n        + applicationInfo.taskAffinity + &quot;\\n&quot;  \n);  \n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n    /data/data/com.example.liushihan.glidedemo\n    null\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n</code></pre></li>\n</ul>\n<h5 id=\"2-获取所有安装的Packages\"><a href=\"#2-获取所有安装的Packages\" class=\"headerlink\" title=\"2. 获取所有安装的Packages\"></a>2. 获取所有安装的Packages</h5><ul>\n<li><p>示例：</p>\n<pre><code>List&lt;PackageInfo&gt; listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:<br>部分日志</p>\n<pre><code> D/lsh: PackageInfo{132b54a7 com.android.smoketest}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n</code></pre></li>\n</ul>\n<h5 id=\"3-获取指定应用的PackageInfo\"><a href=\"#3-获取指定应用的PackageInfo\" class=\"headerlink\" title=\"3. 获取指定应用的PackageInfo\"></a>3. 获取指定应用的PackageInfo</h5><ul>\n<li><p>示例：</p>\n<pre><code>PackageManager packageManager = getPackageManager();\n        PackageInfo packageInfo = null;\n        try {\n            packageInfo = packageManager.getPackageInfo(&quot;com.example.liushihan&quot;,\n                    PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh&quot;, packageInfo.packageName + &quot;\\n&quot;\n                    + packageInfo.versionName + &quot;\\n&quot;\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat</p>\n<pre><code>D/lsh: com.example.liushihan.glidedemo\n                            1.0\n</code></pre></li>\n</ul>\n<h5 id=\"4-获取应用程序中的permission\"><a href=\"#4-获取应用程序中的permission\" class=\"headerlink\" title=\"4. 获取应用程序中的permission\"></a>4. 获取应用程序中的permission</h5><ul>\n<li><p>示例：</p>\n<pre><code>try {\n         PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(&quot;android.permission.INTERNET&quot;,\n                 PermissionInfo.PROTECTION_NORMAL);\n         List&lt;PermissionGroupInfo&gt; list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n         Log.d(&quot;lsh&quot;,\n                 permissionInfo.group + &quot;\\n&quot;\n                         + permissionInfo.packageName + &quot;\\n&quot;\n                         + permissionInfo.name + &quot;\\n&quot;\n                         + permissionInfo.flags + &quot;\\n&quot;\n         );\n     } catch (PackageManager.NameNotFoundException e) {\n         e.printStackTrace();\n     }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>D/lsh: android.permission-group.NETWORK\n                                  android\n                                  android.permission.INTERNET\n                                  0\n</code></pre></li>\n</ul>\n<h5 id=\"5-获取应用程序中执行的ActivityInfo\"><a href=\"#5-获取应用程序中执行的ActivityInfo\" class=\"headerlink\" title=\"5. 获取应用程序中执行的ActivityInfo\"></a>5. 获取应用程序中执行的ActivityInfo</h5><ul>\n<li>示例：</li>\n</ul>\n<pre><code>ComponentName componentName = new ComponentName(&quot;com.example.liushihan.glidedemo&quot;,&quot;com.example.liushihan.glidedemo.MainActivity&quot;);\n        try {\n            @SuppressLint(&quot;WrongConstant&quot;) ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh:activityInfo&quot;,activityInfo.name + &quot;\\n&quot;\n                    + activityInfo.packageName +&quot;\\n&quot;\n                    + activityInfo.targetActivity\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }  \n</code></pre><ul>\n<li>Logcat:</li>\n</ul>\n<pre><code>4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n                                                                                 com.example.liushihan.glidedemo\n                                                                                 null\n</code></pre>"},{"title":"RxJava2.0(一)基本使用","date":"2017-08-10T11:16:59.000Z","_content":"\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","source":"_posts/RxJava2-0-一.md","raw":"---\ntitle: RxJava2.0(一)基本使用\ndate: 2017-08-10 19:16:59\ntags: [RxJava]\n---\n\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","slug":"RxJava2-0-一","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tnz0022x3c0absfr45w","content":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n"},{"title":"RxJava2.0(三)操作符简介","date":"2017-08-12T07:58:33.000Z","_content":"\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n### 变换操作\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\t@Test\n    public void testConcat() throws Exception {\n        final Observable<String> factory = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"卫龙\");\n                e.onComplete();\n            }\n        });\n\n        Observable<String> price = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"5\");\n                e.onComplete();\n            }\n        });\n        Observable<String> material = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"chili\");\n                e.onComplete();\n            }\n        });\n\n        Observable.concat(factory, price,material).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"result\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n结果为：\n\n\tresult：卫龙\n\tresult：5\n\tresult：chili\n\t\n就拿到了辣条的所有信息了。\n\n\n\n### 过滤操作\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n\n\n\n\n\n\n\n\n","source":"_posts/RxJava2-0-三-变换操作.md","raw":"---\ntitle: RxJava2.0(三)操作符简介\ndate: 2017-08-12 15:58:33\ntags: [RxJava]\n---\n\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n### 变换操作\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\t@Test\n    public void testConcat() throws Exception {\n        final Observable<String> factory = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"卫龙\");\n                e.onComplete();\n            }\n        });\n\n        Observable<String> price = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"5\");\n                e.onComplete();\n            }\n        });\n        Observable<String> material = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"chili\");\n                e.onComplete();\n            }\n        });\n\n        Observable.concat(factory, price,material).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"result\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n结果为：\n\n\tresult：卫龙\n\tresult：5\n\tresult：chili\n\t\n就拿到了辣条的所有信息了。\n\n\n\n### 过滤操作\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n\n\n\n\n\n\n\n\n","slug":"RxJava2-0-三-变换操作","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to00025x3c0tyfibqr5","content":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h3 id=\"变换操作\"><a href=\"#变换操作\" class=\"headerlink\" title=\"变换操作\"></a>变换操作</h3><h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n<pre><code>@Test\npublic void testConcat() throws Exception {\n    final Observable&lt;String&gt; factory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;卫龙&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable&lt;String&gt; price = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;5&quot;);\n            e.onComplete();\n        }\n    });\n    Observable&lt;String&gt; material = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;chili&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable.concat(factory, price,material).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;result&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>结果为：</p>\n<pre><code>result：卫龙\nresult：5\nresult：chili\n</code></pre><p>就拿到了辣条的所有信息了。</p>\n<h3 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h3><h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h3 id=\"变换操作\"><a href=\"#变换操作\" class=\"headerlink\" title=\"变换操作\"></a>变换操作</h3><h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n<pre><code>@Test\npublic void testConcat() throws Exception {\n    final Observable&lt;String&gt; factory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;卫龙&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable&lt;String&gt; price = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;5&quot;);\n            e.onComplete();\n        }\n    });\n    Observable&lt;String&gt; material = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;chili&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable.concat(factory, price,material).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;result&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>结果为：</p>\n<pre><code>result：卫龙\nresult：5\nresult：chili\n</code></pre><p>就拿到了辣条的所有信息了。</p>\n<h3 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h3><h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n"},{"title":"RxJava2.0(二)线程控制","date":"2017-08-11T11:27:52.000Z","_content":"\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","source":"_posts/RxJava2-0-二.md","raw":"---\ntitle: RxJava2.0(二)线程控制\ndate: 2017-08-11 19:27:52\ntags: [RxJava]\n---\n\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","slug":"RxJava2-0-二","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to00026x3c04pn2vdja","content":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"RxJava2.0(四)Backpressure","date":"2017-09-04T15:27:16.000Z","_content":"\n上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。\n\n#### 一、什么是背压\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。\n\n例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？\n\n那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。\n\n简单来说，就是来控制事件流速。\n","source":"_posts/RxJava2-0-四-Backpressure.md","raw":"---\ntitle: RxJava2.0(四)Backpressure\ndate: 2017-09-04 23:27:16\ntags: [RxJava]\n---\n\n上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。\n\n#### 一、什么是背压\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。\n\n例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？\n\n那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。\n\n简单来说，就是来控制事件流速。\n","slug":"RxJava2-0-四-Backpressure","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to10028x3c0f1yyu45m","content":"<p>上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。</p>\n<h4 id=\"一、什么是背压\"><a href=\"#一、什么是背压\" class=\"headerlink\" title=\"一、什么是背压\"></a>一、什么是背压</h4><p>在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。</p>\n<p>例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？</p>\n<p>那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。</p>\n<p>简单来说，就是来控制事件流速。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。</p>\n<h4 id=\"一、什么是背压\"><a href=\"#一、什么是背压\" class=\"headerlink\" title=\"一、什么是背压\"></a>一、什么是背压</h4><p>在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。</p>\n<p>例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？</p>\n<p>那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。</p>\n<p>简单来说，就是来控制事件流速。</p>\n"},{"title":"Set集合使用注意tips","date":"2017-02-22T11:11:02.000Z","_content":"\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","source":"_posts/Set集合使用注意tips.md","raw":"---\ntitle: Set集合使用注意tips\ndate: 2017-02-22 19:11:02\ntags:\n---\n\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","slug":"Set集合使用注意tips","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to20029x3c0cime0x75","content":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n"},{"title":"Hello World","date":"2016-09-01T12:02:08.000Z","type":["Hello"],"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-09-01 20:02:08\ntype: [Hello]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to3002cx3c0q5bsy4ga","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"主线程的Loop.loop()一直无限循环为什么不会造成ANR?","date":"2018-05-30T03:27:35.000Z","_content":"\n#### 一、基本概念\n\n##### 什么是ANR?\n\n简单来说就是：\n\n1. 当前事件没有机会得到处理\n\n2. 当前事件正在处理但是没有及时完成\n\n\n\n\n\n\n\n\n\n\t\t   public static void main(String[] args) {\n\t\t        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n\t\t        SamplingProfilerIntegration.start();\n\t\t\n\t\t        // CloseGuard defaults to true and can be quite spammy.  We\n\t\t        // disable it here, but selectively enable it later (via\n\t\t        // StrictMode) on debug builds, but using DropBox, not logs.\n\t\t        CloseGuard.setEnabled(false);\n\t\t\n\t\t        Environment.initForCurrentUser();\n\t\t\n\t\t        // Set the reporter for event logging in libcore\n\t\t        EventLogger.setReporter(new EventLoggingReporter());\n\t\t\n\t\t        AndroidKeyStoreProvider.install();\n\t\t\n\t\t        // Make sure TrustedCertificateStore looks in the right place for CA certificates\n\t\t        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n\t\t        TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\t\t\n\t\t        Process.setArgV0(\"<pre-initialized>\");\n\t\t\n\t\t        Looper.prepareMainLooper();\n\t\t\n\t\t        ActivityThread thread = new ActivityThread();\n\t\t        thread.attach(false);\n\t\t\n\t\t        if (sMainThreadHandler == null) {\n\t\t            sMainThreadHandler = thread.getHandler();\n\t\t        }\n\t\t\n\t\t        if (false) {\n\t\t            Looper.myLooper().setMessageLogging(new\n\t\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t\t        }\n\t\t\n\t\t        // End of event ActivityThreadMain.\n\t\t        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t\t        Looper.loop();\n\t\t\n\t\t        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n\t\t    }\n\t\t    \n\t\t    \n","source":"_posts/主线程的Loop-loop-一直无限循环为什么不会造成ANR.md","raw":"---\ntitle: 主线程的Loop.loop()一直无限循环为什么不会造成ANR?\ndate: 2018-05-30 11:27:35\ntags: [Android]\n---\n\n#### 一、基本概念\n\n##### 什么是ANR?\n\n简单来说就是：\n\n1. 当前事件没有机会得到处理\n\n2. 当前事件正在处理但是没有及时完成\n\n\n\n\n\n\n\n\n\n\t\t   public static void main(String[] args) {\n\t\t        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n\t\t        SamplingProfilerIntegration.start();\n\t\t\n\t\t        // CloseGuard defaults to true and can be quite spammy.  We\n\t\t        // disable it here, but selectively enable it later (via\n\t\t        // StrictMode) on debug builds, but using DropBox, not logs.\n\t\t        CloseGuard.setEnabled(false);\n\t\t\n\t\t        Environment.initForCurrentUser();\n\t\t\n\t\t        // Set the reporter for event logging in libcore\n\t\t        EventLogger.setReporter(new EventLoggingReporter());\n\t\t\n\t\t        AndroidKeyStoreProvider.install();\n\t\t\n\t\t        // Make sure TrustedCertificateStore looks in the right place for CA certificates\n\t\t        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n\t\t        TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\t\t\n\t\t        Process.setArgV0(\"<pre-initialized>\");\n\t\t\n\t\t        Looper.prepareMainLooper();\n\t\t\n\t\t        ActivityThread thread = new ActivityThread();\n\t\t        thread.attach(false);\n\t\t\n\t\t        if (sMainThreadHandler == null) {\n\t\t            sMainThreadHandler = thread.getHandler();\n\t\t        }\n\t\t\n\t\t        if (false) {\n\t\t            Looper.myLooper().setMessageLogging(new\n\t\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t\t        }\n\t\t\n\t\t        // End of event ActivityThreadMain.\n\t\t        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t\t        Looper.loop();\n\t\t\n\t\t        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n\t\t    }\n\t\t    \n\t\t    \n","slug":"主线程的Loop-loop-一直无限循环为什么不会造成ANR","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to4002ex3c059pz2188","content":"<h4 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h4><h5 id=\"什么是ANR\"><a href=\"#什么是ANR\" class=\"headerlink\" title=\"什么是ANR?\"></a>什么是ANR?</h5><p>简单来说就是：</p>\n<ol>\n<li><p>当前事件没有机会得到处理</p>\n</li>\n<li><p>当前事件正在处理但是没有及时完成</p>\n</li>\n</ol>\n<pre><code>public static void main(String[] args) {\n     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);\n     SamplingProfilerIntegration.start();\n\n     // CloseGuard defaults to true and can be quite spammy.  We\n     // disable it here, but selectively enable it later (via\n     // StrictMode) on debug builds, but using DropBox, not logs.\n     CloseGuard.setEnabled(false);\n\n     Environment.initForCurrentUser();\n\n     // Set the reporter for event logging in libcore\n     EventLogger.setReporter(new EventLoggingReporter());\n\n     AndroidKeyStoreProvider.install();\n\n     // Make sure TrustedCertificateStore looks in the right place for CA certificates\n     final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n     TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\n     Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);\n\n     Looper.prepareMainLooper();\n\n     ActivityThread thread = new ActivityThread();\n     thread.attach(false);\n\n     if (sMainThreadHandler == null) {\n         sMainThreadHandler = thread.getHandler();\n     }\n\n     if (false) {\n         Looper.myLooper().setMessageLogging(new\n                 LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n     }\n\n     // End of event ActivityThreadMain.\n     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n     Looper.loop();\n\n     throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);\n }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h4><h5 id=\"什么是ANR\"><a href=\"#什么是ANR\" class=\"headerlink\" title=\"什么是ANR?\"></a>什么是ANR?</h5><p>简单来说就是：</p>\n<ol>\n<li><p>当前事件没有机会得到处理</p>\n</li>\n<li><p>当前事件正在处理但是没有及时完成</p>\n</li>\n</ol>\n<pre><code>public static void main(String[] args) {\n     Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);\n     SamplingProfilerIntegration.start();\n\n     // CloseGuard defaults to true and can be quite spammy.  We\n     // disable it here, but selectively enable it later (via\n     // StrictMode) on debug builds, but using DropBox, not logs.\n     CloseGuard.setEnabled(false);\n\n     Environment.initForCurrentUser();\n\n     // Set the reporter for event logging in libcore\n     EventLogger.setReporter(new EventLoggingReporter());\n\n     AndroidKeyStoreProvider.install();\n\n     // Make sure TrustedCertificateStore looks in the right place for CA certificates\n     final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n     TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\n     Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);\n\n     Looper.prepareMainLooper();\n\n     ActivityThread thread = new ActivityThread();\n     thread.attach(false);\n\n     if (sMainThreadHandler == null) {\n         sMainThreadHandler = thread.getHandler();\n     }\n\n     if (false) {\n         Looper.myLooper().setMessageLogging(new\n                 LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n     }\n\n     // End of event ActivityThreadMain.\n     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n     Looper.loop();\n\n     throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);\n }\n</code></pre>"},{"title":"书读的不多，却想的太多","date":"2017-09-03T06:54:22.000Z","_content":"\n书读得不多却想的太多。\n先好好看书。\n持续更新···\n\n![程序设计](http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png)\n\n\n![软件工程](http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png)\n","source":"_posts/书读的不多，却想的太多.md","raw":"---\ntitle: 书读的不多，却想的太多\ndate: 2017-09-03 14:54:22\ntags: [Book推荐]\n---\n\n书读得不多却想的太多。\n先好好看书。\n持续更新···\n\n![程序设计](http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png)\n\n\n![软件工程](http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png)\n","slug":"书读的不多，却想的太多","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to4002gx3c0ebx8fbmj","content":"<p>书读得不多却想的太多。<br>先好好看书。<br>持续更新···</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png\" alt=\"程序设计\"></p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png\" alt=\"软件工程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>书读得不多却想的太多。<br>先好好看书。<br>持续更新···</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png\" alt=\"程序设计\"></p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png\" alt=\"软件工程\"></p>\n"},{"title":"关于HTTP需要理解的知识点","date":"2016-11-13T07:24:05.000Z","_content":"\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","source":"_posts/关于HTTP需要理解的知识点.md","raw":"---\ntitle: 关于HTTP需要理解的知识点\ndate: 2016-11-13 15:24:05\ntags: [HTTP]\n---\n\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","slug":"关于HTTP需要理解的知识点","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to6002ix3c0zjfv3427","content":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n"},{"title":"多的是，你不知道的事","date":"2017-09-02T16:09:12.000Z","_content":"\n### 多的是，你不知道的事\n\n---\n\n\n#### Android系统源码学习\n\n* Binder机制和AIDL\n* Activity的启动过程\n* 进程的优先级\n* ServiceManager\n* Window和WindowManager\n\n\n#### 开源框架学习\n\n* OKHTTP\n* Retrofit\n* Glide\n* Gson\n* fastjson\n* Jackson\n* Realm\n* Ormlite\n* ButterKnief\n* GreenDao\n* RePlugin\n* Leakcanary\n* EventBus\n* otto\n* MPAndroidChart\n* ZXing\n* PhotoView\n* dragger\n* DisLruCache\n\n\n#### 多线程处理\n\n* Handler原理\n* AsyncTask\n* HandlerThread\n* IntentService\n* RxJava\n\n#### 自定义控件\n\n* measure\n* layout\n* draw\n* 事件分发\n* 自定义动画\n\n#### 性能优化\n\n* ANR处理\n* OOM处理\n* 布局优化\n* 线程优化\n\n#### Java高级知识\n\n* 反射\n* 动态代理\n* NIO\n* 垃圾回收\n* 多线程（并发锁）\n* 网络协议\n\n#### APP架构\n\n* MVC\n* MVP\n* MVVM\n\n#### 插件化技术\n\n* class和dex学习\n* ClassLoader原理\n* 插件化原理\n* 插件化框架学习\n\n#### NDK开发\n\n* 调用JNI方法\n* 回调JAVA方法\n* CMAKE语法\n* NDK MakeFile语法\n\n\n#### 音视频处理\n\n* 音频编解码\n* AudioTrack播放\n* 视频解码\n* OpenGL绘制\n* 视频编辑转码\n* 视频滤镜\n\n\n#### 工具\n\n* AndroidStudio\n* Gradle脚本\n* Git\n","source":"_posts/多的是，你不知道的事.md","raw":"---\ntitle: 多的是，你不知道的事\ndate: 2017-09-03 00:09:12\ntags: [Android进阶]\n---\n\n### 多的是，你不知道的事\n\n---\n\n\n#### Android系统源码学习\n\n* Binder机制和AIDL\n* Activity的启动过程\n* 进程的优先级\n* ServiceManager\n* Window和WindowManager\n\n\n#### 开源框架学习\n\n* OKHTTP\n* Retrofit\n* Glide\n* Gson\n* fastjson\n* Jackson\n* Realm\n* Ormlite\n* ButterKnief\n* GreenDao\n* RePlugin\n* Leakcanary\n* EventBus\n* otto\n* MPAndroidChart\n* ZXing\n* PhotoView\n* dragger\n* DisLruCache\n\n\n#### 多线程处理\n\n* Handler原理\n* AsyncTask\n* HandlerThread\n* IntentService\n* RxJava\n\n#### 自定义控件\n\n* measure\n* layout\n* draw\n* 事件分发\n* 自定义动画\n\n#### 性能优化\n\n* ANR处理\n* OOM处理\n* 布局优化\n* 线程优化\n\n#### Java高级知识\n\n* 反射\n* 动态代理\n* NIO\n* 垃圾回收\n* 多线程（并发锁）\n* 网络协议\n\n#### APP架构\n\n* MVC\n* MVP\n* MVVM\n\n#### 插件化技术\n\n* class和dex学习\n* ClassLoader原理\n* 插件化原理\n* 插件化框架学习\n\n#### NDK开发\n\n* 调用JNI方法\n* 回调JAVA方法\n* CMAKE语法\n* NDK MakeFile语法\n\n\n#### 音视频处理\n\n* 音频编解码\n* AudioTrack播放\n* 视频解码\n* OpenGL绘制\n* 视频编辑转码\n* 视频滤镜\n\n\n#### 工具\n\n* AndroidStudio\n* Gradle脚本\n* Git\n","slug":"多的是，你不知道的事","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to7002lx3c03d0tm5ru","content":"<h3 id=\"多的是，你不知道的事\"><a href=\"#多的是，你不知道的事\" class=\"headerlink\" title=\"多的是，你不知道的事\"></a>多的是，你不知道的事</h3><hr>\n<h4 id=\"Android系统源码学习\"><a href=\"#Android系统源码学习\" class=\"headerlink\" title=\"Android系统源码学习\"></a>Android系统源码学习</h4><ul>\n<li>Binder机制和AIDL</li>\n<li>Activity的启动过程</li>\n<li>进程的优先级</li>\n<li>ServiceManager</li>\n<li>Window和WindowManager</li>\n</ul>\n<h4 id=\"开源框架学习\"><a href=\"#开源框架学习\" class=\"headerlink\" title=\"开源框架学习\"></a>开源框架学习</h4><ul>\n<li>OKHTTP</li>\n<li>Retrofit</li>\n<li>Glide</li>\n<li>Gson</li>\n<li>fastjson</li>\n<li>Jackson</li>\n<li>Realm</li>\n<li>Ormlite</li>\n<li>ButterKnief</li>\n<li>GreenDao</li>\n<li>RePlugin</li>\n<li>Leakcanary</li>\n<li>EventBus</li>\n<li>otto</li>\n<li>MPAndroidChart</li>\n<li>ZXing</li>\n<li>PhotoView</li>\n<li>dragger</li>\n<li>DisLruCache</li>\n</ul>\n<h4 id=\"多线程处理\"><a href=\"#多线程处理\" class=\"headerlink\" title=\"多线程处理\"></a>多线程处理</h4><ul>\n<li>Handler原理</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>IntentService</li>\n<li>RxJava</li>\n</ul>\n<h4 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h4><ul>\n<li>measure</li>\n<li>layout</li>\n<li>draw</li>\n<li>事件分发</li>\n<li>自定义动画</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>ANR处理</li>\n<li>OOM处理</li>\n<li>布局优化</li>\n<li>线程优化</li>\n</ul>\n<h4 id=\"Java高级知识\"><a href=\"#Java高级知识\" class=\"headerlink\" title=\"Java高级知识\"></a>Java高级知识</h4><ul>\n<li>反射</li>\n<li>动态代理</li>\n<li>NIO</li>\n<li>垃圾回收</li>\n<li>多线程（并发锁）</li>\n<li>网络协议</li>\n</ul>\n<h4 id=\"APP架构\"><a href=\"#APP架构\" class=\"headerlink\" title=\"APP架构\"></a>APP架构</h4><ul>\n<li>MVC</li>\n<li>MVP</li>\n<li>MVVM</li>\n</ul>\n<h4 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h4><ul>\n<li>class和dex学习</li>\n<li>ClassLoader原理</li>\n<li>插件化原理</li>\n<li>插件化框架学习</li>\n</ul>\n<h4 id=\"NDK开发\"><a href=\"#NDK开发\" class=\"headerlink\" title=\"NDK开发\"></a>NDK开发</h4><ul>\n<li>调用JNI方法</li>\n<li>回调JAVA方法</li>\n<li>CMAKE语法</li>\n<li>NDK MakeFile语法</li>\n</ul>\n<h4 id=\"音视频处理\"><a href=\"#音视频处理\" class=\"headerlink\" title=\"音视频处理\"></a>音视频处理</h4><ul>\n<li>音频编解码</li>\n<li>AudioTrack播放</li>\n<li>视频解码</li>\n<li>OpenGL绘制</li>\n<li>视频编辑转码</li>\n<li>视频滤镜</li>\n</ul>\n<h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>AndroidStudio</li>\n<li>Gradle脚本</li>\n<li>Git</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"多的是，你不知道的事\"><a href=\"#多的是，你不知道的事\" class=\"headerlink\" title=\"多的是，你不知道的事\"></a>多的是，你不知道的事</h3><hr>\n<h4 id=\"Android系统源码学习\"><a href=\"#Android系统源码学习\" class=\"headerlink\" title=\"Android系统源码学习\"></a>Android系统源码学习</h4><ul>\n<li>Binder机制和AIDL</li>\n<li>Activity的启动过程</li>\n<li>进程的优先级</li>\n<li>ServiceManager</li>\n<li>Window和WindowManager</li>\n</ul>\n<h4 id=\"开源框架学习\"><a href=\"#开源框架学习\" class=\"headerlink\" title=\"开源框架学习\"></a>开源框架学习</h4><ul>\n<li>OKHTTP</li>\n<li>Retrofit</li>\n<li>Glide</li>\n<li>Gson</li>\n<li>fastjson</li>\n<li>Jackson</li>\n<li>Realm</li>\n<li>Ormlite</li>\n<li>ButterKnief</li>\n<li>GreenDao</li>\n<li>RePlugin</li>\n<li>Leakcanary</li>\n<li>EventBus</li>\n<li>otto</li>\n<li>MPAndroidChart</li>\n<li>ZXing</li>\n<li>PhotoView</li>\n<li>dragger</li>\n<li>DisLruCache</li>\n</ul>\n<h4 id=\"多线程处理\"><a href=\"#多线程处理\" class=\"headerlink\" title=\"多线程处理\"></a>多线程处理</h4><ul>\n<li>Handler原理</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>IntentService</li>\n<li>RxJava</li>\n</ul>\n<h4 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h4><ul>\n<li>measure</li>\n<li>layout</li>\n<li>draw</li>\n<li>事件分发</li>\n<li>自定义动画</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>ANR处理</li>\n<li>OOM处理</li>\n<li>布局优化</li>\n<li>线程优化</li>\n</ul>\n<h4 id=\"Java高级知识\"><a href=\"#Java高级知识\" class=\"headerlink\" title=\"Java高级知识\"></a>Java高级知识</h4><ul>\n<li>反射</li>\n<li>动态代理</li>\n<li>NIO</li>\n<li>垃圾回收</li>\n<li>多线程（并发锁）</li>\n<li>网络协议</li>\n</ul>\n<h4 id=\"APP架构\"><a href=\"#APP架构\" class=\"headerlink\" title=\"APP架构\"></a>APP架构</h4><ul>\n<li>MVC</li>\n<li>MVP</li>\n<li>MVVM</li>\n</ul>\n<h4 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h4><ul>\n<li>class和dex学习</li>\n<li>ClassLoader原理</li>\n<li>插件化原理</li>\n<li>插件化框架学习</li>\n</ul>\n<h4 id=\"NDK开发\"><a href=\"#NDK开发\" class=\"headerlink\" title=\"NDK开发\"></a>NDK开发</h4><ul>\n<li>调用JNI方法</li>\n<li>回调JAVA方法</li>\n<li>CMAKE语法</li>\n<li>NDK MakeFile语法</li>\n</ul>\n<h4 id=\"音视频处理\"><a href=\"#音视频处理\" class=\"headerlink\" title=\"音视频处理\"></a>音视频处理</h4><ul>\n<li>音频编解码</li>\n<li>AudioTrack播放</li>\n<li>视频解码</li>\n<li>OpenGL绘制</li>\n<li>视频编辑转码</li>\n<li>视频滤镜</li>\n</ul>\n<h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>AndroidStudio</li>\n<li>Gradle脚本</li>\n<li>Git</li>\n</ul>\n"},{"title":"自定义View(2)Canvas简介","date":"2017-09-21T02:56:35.000Z","_content":"\n### 一、Canvas简介\n\n\n#### （1）Canvas简介\n\nCanvas,即画布。\n\n#### （2）Canvas详解\n\n画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。\n\n* 首先介绍一下画笔Paint\n\n\t* 1.三个构造函数\n\t\t\n\t\t* Paint()\t创建一个画笔\n\t\t* Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）\n\t\t* Paint(Paint paint)\t使用已构造的Paint创建一个画笔\n\n\t* 2.常用方法\n\t\n\t\t* setAlpha(int a)\t设置透明度\n\t\t* setARGB(int a, int r, int g, int b) \t设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue\n\t\t* setAntiAlias(boolean aa)\t设置抗锯齿\n\t\t* setColor(@ColorInt int color) 设置颜色\n\t\t* setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬\n\t\t* setUnderlineText(boolean underlineText)\t设置文本下划线\n\t\t* setStyle(Style style)\t设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边\n\t\t* setStrikeThruText(boolean strikeThruText)\t设置文本删除线\n\t\t* setFilterBitmap(boolean filter)\t\t对bitmap进行滤波处理，true-去除优化，加快显示\n\t\t* setColorFilter(ColorFilter filter) \t设置颜色过滤\n\t\t\n\t\t······\n\t\t\n\t* 3.ColorFilter\n\n\t\tColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。\n\t\t\n\t\t1. ColorMatrixColorFilter\n\n\t\t\t* ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.\n\t\t\t* 通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。\n\t\t\n\t\n","source":"_posts/自定义View-2-Canvas简介.md","raw":"---\ntitle: 自定义View(2)Canvas简介\ndate: 2017-09-21 10:56:35\ntags: [自定义View]\n---\n\n### 一、Canvas简介\n\n\n#### （1）Canvas简介\n\nCanvas,即画布。\n\n#### （2）Canvas详解\n\n画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。\n\n* 首先介绍一下画笔Paint\n\n\t* 1.三个构造函数\n\t\t\n\t\t* Paint()\t创建一个画笔\n\t\t* Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）\n\t\t* Paint(Paint paint)\t使用已构造的Paint创建一个画笔\n\n\t* 2.常用方法\n\t\n\t\t* setAlpha(int a)\t设置透明度\n\t\t* setARGB(int a, int r, int g, int b) \t设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue\n\t\t* setAntiAlias(boolean aa)\t设置抗锯齿\n\t\t* setColor(@ColorInt int color) 设置颜色\n\t\t* setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬\n\t\t* setUnderlineText(boolean underlineText)\t设置文本下划线\n\t\t* setStyle(Style style)\t设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边\n\t\t* setStrikeThruText(boolean strikeThruText)\t设置文本删除线\n\t\t* setFilterBitmap(boolean filter)\t\t对bitmap进行滤波处理，true-去除优化，加快显示\n\t\t* setColorFilter(ColorFilter filter) \t设置颜色过滤\n\t\t\n\t\t······\n\t\t\n\t* 3.ColorFilter\n\n\t\tColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。\n\t\t\n\t\t1. ColorMatrixColorFilter\n\n\t\t\t* ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.\n\t\t\t* 通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。\n\t\t\n\t\n","slug":"自定义View-2-Canvas简介","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8to9002nx3c0uwicuv34","content":"<h3 id=\"一、Canvas简介\"><a href=\"#一、Canvas简介\" class=\"headerlink\" title=\"一、Canvas简介\"></a>一、Canvas简介</h3><h4 id=\"（1）Canvas简介\"><a href=\"#（1）Canvas简介\" class=\"headerlink\" title=\"（1）Canvas简介\"></a>（1）Canvas简介</h4><p>Canvas,即画布。</p>\n<h4 id=\"（2）Canvas详解\"><a href=\"#（2）Canvas详解\" class=\"headerlink\" title=\"（2）Canvas详解\"></a>（2）Canvas详解</h4><p>画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。</p>\n<ul>\n<li><p>首先介绍一下画笔Paint</p>\n<ul>\n<li><p>1.三个构造函数</p>\n<ul>\n<li>Paint()    创建一个画笔</li>\n<li>Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）</li>\n<li>Paint(Paint paint)    使用已构造的Paint创建一个画笔</li>\n</ul>\n</li>\n<li><p>2.常用方法</p>\n<ul>\n<li>setAlpha(int a)    设置透明度</li>\n<li>setARGB(int a, int r, int g, int b)     设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue</li>\n<li>setAntiAlias(boolean aa)    设置抗锯齿</li>\n<li>setColor(@ColorInt int color) 设置颜色</li>\n<li>setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬</li>\n<li>setUnderlineText(boolean underlineText)    设置文本下划线</li>\n<li>setStyle(Style style)    设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边</li>\n<li>setStrikeThruText(boolean strikeThruText)    设置文本删除线</li>\n<li>setFilterBitmap(boolean filter)        对bitmap进行滤波处理，true-去除优化，加快显示</li>\n<li><p>setColorFilter(ColorFilter filter)     设置颜色过滤</p>\n<p>······</p>\n</li>\n</ul>\n</li>\n<li><p>3.ColorFilter</p>\n<p>  ColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。</p>\n<ol>\n<li><p>ColorMatrixColorFilter</p>\n<ul>\n<li>ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.</li>\n<li>通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Canvas简介\"><a href=\"#一、Canvas简介\" class=\"headerlink\" title=\"一、Canvas简介\"></a>一、Canvas简介</h3><h4 id=\"（1）Canvas简介\"><a href=\"#（1）Canvas简介\" class=\"headerlink\" title=\"（1）Canvas简介\"></a>（1）Canvas简介</h4><p>Canvas,即画布。</p>\n<h4 id=\"（2）Canvas详解\"><a href=\"#（2）Canvas详解\" class=\"headerlink\" title=\"（2）Canvas详解\"></a>（2）Canvas详解</h4><p>画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。</p>\n<ul>\n<li><p>首先介绍一下画笔Paint</p>\n<ul>\n<li><p>1.三个构造函数</p>\n<ul>\n<li>Paint()    创建一个画笔</li>\n<li>Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）</li>\n<li>Paint(Paint paint)    使用已构造的Paint创建一个画笔</li>\n</ul>\n</li>\n<li><p>2.常用方法</p>\n<ul>\n<li>setAlpha(int a)    设置透明度</li>\n<li>setARGB(int a, int r, int g, int b)     设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue</li>\n<li>setAntiAlias(boolean aa)    设置抗锯齿</li>\n<li>setColor(@ColorInt int color) 设置颜色</li>\n<li>setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬</li>\n<li>setUnderlineText(boolean underlineText)    设置文本下划线</li>\n<li>setStyle(Style style)    设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边</li>\n<li>setStrikeThruText(boolean strikeThruText)    设置文本删除线</li>\n<li>setFilterBitmap(boolean filter)        对bitmap进行滤波处理，true-去除优化，加快显示</li>\n<li><p>setColorFilter(ColorFilter filter)     设置颜色过滤</p>\n<p>······</p>\n</li>\n</ul>\n</li>\n<li><p>3.ColorFilter</p>\n<p>  ColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。</p>\n<ol>\n<li><p>ColorMatrixColorFilter</p>\n<ul>\n<li>ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.</li>\n<li>通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"自定义View(一)View简介","date":"2017-08-26T14:06:02.000Z","_content":"\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n1. 组合控件或继承基本控件\n\n\t像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View\n\t\n\t举个简单的例子：ToolBar\n\t\n\t在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。\n\t\n\t看源码：\n\t\n\t![toolbar](http://ot29getcp.bkt.clouddn.com/images/toolbar.png)\n\t\n\t可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。\n\t\n\t\n2. 自定义View\n\n 自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View\n\n * (1)屏幕坐标系\n\n \t![zuobiaoxi](http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png)\n \t\n \t手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。\n * （2）View坐标系\n \n ![viewzuobiao](http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png)\n \n View坐标系都是相对父控件而言来确定位置的。\n \t\n \t* getTop():view顶部相对于父控件顶部距离\n \t* getBottom():view底部相对于父控件顶部距离\n \t* getLeft():view左边相对于父控件距离\n \t* getRight():view右边相对于父控件距离\n \t\n \t\n \t\n3. View绘制流程\n\n![viewhuizhi](http://ot29getcp.bkt.clouddn.com/images/customview.jpg)\n\n ","source":"_posts/自定义View-一.md","raw":"---\ntitle: 自定义View(一)View简介\ndate: 2017-08-26 22:06:02\ntags: [自定义View]\n---\n\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n1. 组合控件或继承基本控件\n\n\t像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View\n\t\n\t举个简单的例子：ToolBar\n\t\n\t在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。\n\t\n\t看源码：\n\t\n\t![toolbar](http://ot29getcp.bkt.clouddn.com/images/toolbar.png)\n\t\n\t可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。\n\t\n\t\n2. 自定义View\n\n 自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View\n\n * (1)屏幕坐标系\n\n \t![zuobiaoxi](http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png)\n \t\n \t手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。\n * （2）View坐标系\n \n ![viewzuobiao](http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png)\n \n View坐标系都是相对父控件而言来确定位置的。\n \t\n \t* getTop():view顶部相对于父控件顶部距离\n \t* getBottom():view底部相对于父控件顶部距离\n \t* getLeft():view左边相对于父控件距离\n \t* getRight():view右边相对于父控件距离\n \t\n \t\n \t\n3. View绘制流程\n\n![viewhuizhi](http://ot29getcp.bkt.clouddn.com/images/customview.jpg)\n\n ","slug":"自定义View-一","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8toa002qx3c0aapaltmg","content":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>组合控件或继承基本控件</p>\n<p> 像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View</p>\n<p> 举个简单的例子：ToolBar</p>\n<p> 在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。</p>\n<p> 看源码：</p>\n<p> <img src=\"http://ot29getcp.bkt.clouddn.com/images/toolbar.png\" alt=\"toolbar\"></p>\n<p> 可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。</p>\n</li>\n</ol>\n<ol>\n<li><p>自定义View</p>\n<p>自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View</p>\n<ul>\n<li><p>(1)屏幕坐标系</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></p>\n<p>手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。</p>\n</li>\n<li>（2）View坐标系</li>\n</ul>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png\" alt=\"viewzuobiao\"></p>\n<p>View坐标系都是相对父控件而言来确定位置的。</p>\n<ul>\n<li>getTop():view顶部相对于父控件顶部距离</li>\n<li>getBottom():view底部相对于父控件顶部距离</li>\n<li>getLeft():view左边相对于父控件距离</li>\n<li>getRight():view右边相对于父控件距离</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>View绘制流程</li>\n</ol>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/customview.jpg\" alt=\"viewhuizhi\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>组合控件或继承基本控件</p>\n<p> 像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View</p>\n<p> 举个简单的例子：ToolBar</p>\n<p> 在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。</p>\n<p> 看源码：</p>\n<p> <img src=\"http://ot29getcp.bkt.clouddn.com/images/toolbar.png\" alt=\"toolbar\"></p>\n<p> 可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。</p>\n</li>\n</ol>\n<ol>\n<li><p>自定义View</p>\n<p>自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View</p>\n<ul>\n<li><p>(1)屏幕坐标系</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></p>\n<p>手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。</p>\n</li>\n<li>（2）View坐标系</li>\n</ul>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png\" alt=\"viewzuobiao\"></p>\n<p>View坐标系都是相对父控件而言来确定位置的。</p>\n<ul>\n<li>getTop():view顶部相对于父控件顶部距离</li>\n<li>getBottom():view底部相对于父控件顶部距离</li>\n<li>getLeft():view左边相对于父控件距离</li>\n<li>getRight():view右边相对于父控件距离</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>View绘制流程</li>\n</ol>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/customview.jpg\" alt=\"viewhuizhi\"></p>\n"},{"title":"设计模式之路（1）-简单工厂模式","date":"2017-07-17T04:48:01.000Z","_content":"\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","source":"_posts/设计模式之路（1）-简单工厂模式.md","raw":"---\ntitle: 设计模式之路（1）-简单工厂模式\ndate: 2017-07-17 12:48:01\ntags: [设计模式]\n---\n\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","slug":"设计模式之路（1）-简单工厂模式","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tob002sx3c0aloxrv2k","content":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n"},{"title":"设计模式之路（2）单一职责原则","date":"2017-07-18T07:06:41.000Z","_content":"\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","source":"_posts/设计模式之路（2）单一职责原则.md","raw":"---\ntitle: 设计模式之路（2）单一职责原则\ndate: 2017-07-18 15:06:41\ntags: [设计模式]\n---\n\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","slug":"设计模式之路（2）单一职责原则","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tod002vx3c0ikr914cp","content":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n"},{"title":"设计模式之路（3）开放-封闭原则","date":"2017-07-18T08:24:08.000Z","_content":"\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","source":"_posts/设计模式之路（3）开放-封闭原则.md","raw":"---\ntitle: 设计模式之路（3）开放-封闭原则\ndate: 2017-07-18 16:24:08\ntags: [设计模式]\n---\n\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","slug":"设计模式之路（3）开放-封闭原则","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8toe002wx3c0t8r1nsgp","content":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n"},{"title":"设计模式之路（4）装饰者模式","date":"2017-07-19T02:20:23.000Z","author":"Neil Liu","_content":"\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","source":"_posts/设计模式之路（4）装饰者模式.md","raw":"---\ntitle: 设计模式之路（4）装饰者模式\ndate: 2017-07-19 10:20:23\ntags: [设计模式]\nauthor: Neil Liu\n---\n\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","slug":"设计模式之路（4）装饰者模式","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8toe002yx3c05ljzqxx0","content":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n"},{"title":"设计模式之路（5）代理模式","date":"2017-07-24T07:06:52.000Z","_content":"\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","source":"_posts/设计模式之路（5）代理模式.md","raw":"---\ntitle: 设计模式之路（5）代理模式\ndate: 2017-07-24 15:06:52\ntags: [设计模式]\n---\n\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","slug":"设计模式之路（5）代理模式","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8tog0030x3c0rglb3prh","content":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n"},{"title":"设计模式之路（6）依赖倒转原则","date":"2017-09-10T14:55:38.000Z","_content":"\n\n### 依赖倒置原则\n\n--\n#### 概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n\n--\n\n* 要针对接口编程，不要针对实现编程。\n\n\t* 针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n\t* 不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n### 一、依赖倒置原则：\n\n#### A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\n\n#### B.抽象不应该依赖细节。细节应该依赖抽象。\n\n\n### 二、为什么要依赖倒置\n\n传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。\n\n### 三、总结\n\n一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。\n\n\n\n","source":"_posts/设计模式之路（6）依赖倒转原则.md","raw":"---\ntitle: 设计模式之路（6）依赖倒转原则\ndate: 2017-09-10 22:55:38\ntags: [设计模式]\n---\n\n\n### 依赖倒置原则\n\n--\n#### 概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n\n--\n\n* 要针对接口编程，不要针对实现编程。\n\n\t* 针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n\t* 不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n### 一、依赖倒置原则：\n\n#### A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\n\n#### B.抽象不应该依赖细节。细节应该依赖抽象。\n\n\n### 二、为什么要依赖倒置\n\n传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。\n\n### 三、总结\n\n一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。\n\n\n\n","slug":"设计模式之路（6）依赖倒转原则","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8toi0033x3c0dygvo8pv","content":"<h3 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h3><p>–</p>\n<h4 id=\"概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"><a href=\"#概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\" class=\"headerlink\" title=\"概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"></a>概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</h4><p>–</p>\n<ul>\n<li><p>要针对接口编程，不要针对实现编程。</p>\n<ul>\n<li><p>针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n<li><p>不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、依赖倒置原则：\"><a href=\"#一、依赖倒置原则：\" class=\"headerlink\" title=\"一、依赖倒置原则：\"></a>一、依赖倒置原则：</h3><h4 id=\"A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\"><a href=\"#A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\" class=\"headerlink\" title=\"A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\"></a>A.高层模块不应该依赖低层模块。两个都应该依赖抽象。</h4><h4 id=\"B-抽象不应该依赖细节。细节应该依赖抽象。\"><a href=\"#B-抽象不应该依赖细节。细节应该依赖抽象。\" class=\"headerlink\" title=\"B.抽象不应该依赖细节。细节应该依赖抽象。\"></a>B.抽象不应该依赖细节。细节应该依赖抽象。</h4><h3 id=\"二、为什么要依赖倒置\"><a href=\"#二、为什么要依赖倒置\" class=\"headerlink\" title=\"二、为什么要依赖倒置\"></a>二、为什么要依赖倒置</h3><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h3><p>–</p>\n<h4 id=\"概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"><a href=\"#概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\" class=\"headerlink\" title=\"概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"></a>概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</h4><p>–</p>\n<ul>\n<li><p>要针对接口编程，不要针对实现编程。</p>\n<ul>\n<li><p>针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n<li><p>不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、依赖倒置原则：\"><a href=\"#一、依赖倒置原则：\" class=\"headerlink\" title=\"一、依赖倒置原则：\"></a>一、依赖倒置原则：</h3><h4 id=\"A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\"><a href=\"#A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\" class=\"headerlink\" title=\"A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\"></a>A.高层模块不应该依赖低层模块。两个都应该依赖抽象。</h4><h4 id=\"B-抽象不应该依赖细节。细节应该依赖抽象。\"><a href=\"#B-抽象不应该依赖细节。细节应该依赖抽象。\" class=\"headerlink\" title=\"B.抽象不应该依赖细节。细节应该依赖抽象。\"></a>B.抽象不应该依赖细节。细节应该依赖抽象。</h4><h3 id=\"二、为什么要依赖倒置\"><a href=\"#二、为什么要依赖倒置\" class=\"headerlink\" title=\"二、为什么要依赖倒置\"></a>二、为什么要依赖倒置</h3><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。</p>\n"},{"title":"设计模式之路（7）里氏替换原则","date":"2017-09-11T14:49:50.000Z","_content":"\n里氏替换原则（LSP）\n\n#### 一、基本概念：\n\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。\n\n#### 二、例证\n\n只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。\n\n举个例子：\n\n小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。\n\t\n\tAnimal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\t\n\tanimal.eat();\n\tanimal.drink();\n\t","source":"_posts/设计模式之路（7）里氏替换原则.md","raw":"---\ntitle: 设计模式之路（7）里氏替换原则\ndate: 2017-09-11 22:49:50\ntags: [设计模式]\n---\n\n里氏替换原则（LSP）\n\n#### 一、基本概念：\n\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。\n\n#### 二、例证\n\n只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。\n\n举个例子：\n\n小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。\n\t\n\tAnimal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\t\n\tanimal.eat();\n\tanimal.drink();\n\t","slug":"设计模式之路（7）里氏替换原则","published":1,"updated":"2018-12-04T09:15:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9m8toi0035x3c0g6mhhv38","content":"<p>里氏替换原则（LSP）</p>\n<h4 id=\"一、基本概念：\"><a href=\"#一、基本概念：\" class=\"headerlink\" title=\"一、基本概念：\"></a>一、基本概念：</h4><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。</p>\n<h4 id=\"二、例证\"><a href=\"#二、例证\" class=\"headerlink\" title=\"二、例证\"></a>二、例证</h4><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。</p>\n<p>举个例子：</p>\n<p>小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。</p>\n<pre><code>Animal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\nanimal.eat();\nanimal.drink();\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>里氏替换原则（LSP）</p>\n<h4 id=\"一、基本概念：\"><a href=\"#一、基本概念：\" class=\"headerlink\" title=\"一、基本概念：\"></a>一、基本概念：</h4><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。</p>\n<h4 id=\"二、例证\"><a href=\"#二、例证\" class=\"headerlink\" title=\"二、例证\"></a>二、例证</h4><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。</p>\n<p>举个例子：</p>\n<p>小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。</p>\n<pre><code>Animal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\nanimal.eat();\nanimal.drink();\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjp9m8tme0000x3c0no91o5xu","tag_id":"cjp9m8tms0004x3c0as2x9w6b","_id":"cjp9m8tn10009x3c0pehpmxi2"},{"post_id":"cjp9m8tmq0002x3c01ibrohxk","tag_id":"cjp9m8tn10008x3c048cs1s18","_id":"cjp9m8tn3000ex3c0ll45lgly"},{"post_id":"cjp9m8tn3000dx3c06m7x1lew","tag_id":"cjp9m8tn10008x3c048cs1s18","_id":"cjp9m8tn5000hx3c07sjlab6i"},{"post_id":"cjp9m8tmv0005x3c0xffhcbpb","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8tn6000jx3c0wgw9z9kf"},{"post_id":"cjp9m8tn4000fx3c0m3lbcarq","tag_id":"cjp9m8tn10008x3c048cs1s18","_id":"cjp9m8tn7000lx3c0ceetmumv"},{"post_id":"cjp9m8tn5000ix3c0si2atm9l","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8tn9000ox3c0csdu8an1"},{"post_id":"cjp9m8tmw0006x3c0oh44td37","tag_id":"cjp9m8tn4000gx3c0tnr0z06q","_id":"cjp9m8tna000qx3c0233j8fqw"},{"post_id":"cjp9m8tn6000kx3c023w0pe41","tag_id":"cjp9m8tn10008x3c048cs1s18","_id":"cjp9m8tnb000tx3c0gkc38vvw"},{"post_id":"cjp9m8tmy0007x3c0tfu0zgi8","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8tnc000vx3c0b43xwgs8"},{"post_id":"cjp9m8tna000px3c0nbfqo9nu","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8tnd000yx3c0nuq3us9s"},{"post_id":"cjp9m8tn1000ax3c0qxfksgk3","tag_id":"cjp9m8tna000rx3c0o4fuyd78","_id":"cjp9m8tne0010x3c0gwpjra7f"},{"post_id":"cjp9m8tn2000bx3c0gro81ovy","tag_id":"cjp9m8tnd000xx3c0zpgjns4n","_id":"cjp9m8tnf0014x3c045inovgf"},{"post_id":"cjp9m8tn8000nx3c070kxf5tp","tag_id":"cjp9m8tne0012x3c09wz9gwrb","_id":"cjp9m8tnh0018x3c0nunw67yu"},{"post_id":"cjp9m8tnb000sx3c0fh0v5rvf","tag_id":"cjp9m8tna000rx3c0o4fuyd78","_id":"cjp9m8tnj001cx3c0jvwlc7cx"},{"post_id":"cjp9m8tnc000ux3c0hdks7cue","tag_id":"cjp9m8tni001ax3c0v74lwvuh","_id":"cjp9m8tnl001gx3c0lxo8j1bi"},{"post_id":"cjp9m8tnk001fx3c0qro8rasp","tag_id":"cjp9m8tne0012x3c09wz9gwrb","_id":"cjp9m8tnm001ix3c0w90xhwfx"},{"post_id":"cjp9m8tnc000wx3c0gwp6llwb","tag_id":"cjp9m8tnk001ex3c0bcevo92t","_id":"cjp9m8tnp001lx3c03yvetk2o"},{"post_id":"cjp9m8tnc000wx3c0gwp6llwb","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8tnq001nx3c0gqdd3bgi"},{"post_id":"cjp9m8tnr001qx3c0xmxiqthj","tag_id":"cjp9m8tne0012x3c09wz9gwrb","_id":"cjp9m8tnv001tx3c0cuqh5zjy"},{"post_id":"cjp9m8tnd000zx3c02icxe0oe","tag_id":"cjp9m8tnp001kx3c0hol8cujo","_id":"cjp9m8tnv001vx3c0xx5bo378"},{"post_id":"cjp9m8tnd000zx3c02icxe0oe","tag_id":"cjp9m8tnr001px3c0i585udzn","_id":"cjp9m8tnw001xx3c0yx5f14b6"},{"post_id":"cjp9m8tnf0013x3c0jovsfpg3","tag_id":"cjp9m8tnu001sx3c0urrbbj9s","_id":"cjp9m8tnx0020x3c0uqnw3118"},{"post_id":"cjp9m8tng0015x3c0txd1o4dz","tag_id":"cjp9m8tnw001yx3c0la7c8ugh","_id":"cjp9m8to00024x3c0nxnbrcny"},{"post_id":"cjp9m8tnh0017x3c0rxt000xf","tag_id":"cjp9m8tnp001kx3c0hol8cujo","_id":"cjp9m8to2002bx3c0kk1tmefl"},{"post_id":"cjp9m8tnh0017x3c0rxt000xf","tag_id":"cjp9m8tnr001px3c0i585udzn","_id":"cjp9m8to3002dx3c0ubqaihgw"},{"post_id":"cjp9m8tnh0019x3c0uassp98w","tag_id":"cjp9m8to2002ax3c0ud0mx4n3","_id":"cjp9m8to5002hx3c07cxjju4m"},{"post_id":"cjp9m8to4002ex3c059pz2188","tag_id":"cjp9m8tn3000cx3c0hla0e23d","_id":"cjp9m8to6002jx3c0dvrqytj0"},{"post_id":"cjp9m8to6002ix3c0zjfv3427","tag_id":"cjp9m8tnw001yx3c0la7c8ugh","_id":"cjp9m8to9002mx3c0xpm4bxfg"},{"post_id":"cjp9m8to7002lx3c03d0tm5ru","tag_id":"cjp9m8tne0012x3c09wz9gwrb","_id":"cjp9m8toa002px3c06un2g3og"},{"post_id":"cjp9m8tnj001bx3c0wrrx8x48","tag_id":"cjp9m8tnp001kx3c0hol8cujo","_id":"cjp9m8tob002rx3c0a0vvewq3"},{"post_id":"cjp9m8tnj001bx3c0wrrx8x48","tag_id":"cjp9m8tnr001px3c0i585udzn","_id":"cjp9m8tod002ux3c038x90sd8"},{"post_id":"cjp9m8tnj001dx3c010uavvm3","tag_id":"cjp9m8tnp001kx3c0hol8cujo","_id":"cjp9m8tof002zx3c0ey1zv9aa"},{"post_id":"cjp9m8tnj001dx3c010uavvm3","tag_id":"cjp9m8tnr001px3c0i585udzn","_id":"cjp9m8toh0031x3c0wuh7l8od"},{"post_id":"cjp9m8tnl001hx3c0oowcyxtr","tag_id":"cjp9m8toe002xx3c0rw58qcim","_id":"cjp9m8toi0034x3c06glpae2f"},{"post_id":"cjp9m8tnm001jx3c0lwr0bu90","tag_id":"cjp9m8toh0032x3c0tcw08k3q","_id":"cjp9m8toj0037x3c0aojt9h5i"},{"post_id":"cjp9m8tnp001mx3c0gp464r5t","tag_id":"cjp9m8toe002xx3c0rw58qcim","_id":"cjp9m8tok0039x3c0tcp60eh6"},{"post_id":"cjp9m8tnq001ox3c0rotb5u6m","tag_id":"cjp9m8toe002xx3c0rw58qcim","_id":"cjp9m8tol003bx3c04y79oegr"},{"post_id":"cjp9m8tnu001rx3c0307d2m5i","tag_id":"cjp9m8tok003ax3c0ixc4w9dy","_id":"cjp9m8tom003dx3c095fba1lu"},{"post_id":"cjp9m8tnv001ux3c0vqobqpqs","tag_id":"cjp9m8tok003ax3c0ixc4w9dy","_id":"cjp9m8ton003fx3c0e8n8ekpr"},{"post_id":"cjp9m8tnv001wx3c069f3y7cv","tag_id":"cjp9m8tok003ax3c0ixc4w9dy","_id":"cjp9m8ton003hx3c0lh9ctsrm"},{"post_id":"cjp9m8tnx001zx3c0gr9g5uky","tag_id":"cjp9m8tok003ax3c0ixc4w9dy","_id":"cjp9m8too003jx3c0bo8fpehf"},{"post_id":"cjp9m8tny0021x3c013edpurf","tag_id":"cjp9m8too003ix3c06l1nso6j","_id":"cjp9m8too003lx3c05rxmxq2m"},{"post_id":"cjp9m8tnz0022x3c0absfr45w","tag_id":"cjp9m8too003kx3c0botnz4y8","_id":"cjp9m8top003nx3c0izozco66"},{"post_id":"cjp9m8to00025x3c0tyfibqr5","tag_id":"cjp9m8too003kx3c0botnz4y8","_id":"cjp9m8toq003px3c0a4vv959x"},{"post_id":"cjp9m8to00026x3c04pn2vdja","tag_id":"cjp9m8too003kx3c0botnz4y8","_id":"cjp9m8tor003rx3c0w5ezk6f6"},{"post_id":"cjp9m8to10028x3c0f1yyu45m","tag_id":"cjp9m8too003kx3c0botnz4y8","_id":"cjp9m8tor003tx3c028w45lx7"},{"post_id":"cjp9m8to4002gx3c0ebx8fbmj","tag_id":"cjp9m8tor003sx3c0xmdgwdoo","_id":"cjp9m8tos003vx3c0uf6so1hg"},{"post_id":"cjp9m8to9002nx3c0uwicuv34","tag_id":"cjp9m8tor003ux3c0x94omka9","_id":"cjp9m8tos003xx3c0hog6btdm"},{"post_id":"cjp9m8toa002qx3c0aapaltmg","tag_id":"cjp9m8tor003ux3c0x94omka9","_id":"cjp9m8tot003zx3c0i51rv4ch"},{"post_id":"cjp9m8tob002sx3c0aloxrv2k","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8tot0041x3c0v2a0le88"},{"post_id":"cjp9m8tod002vx3c0ikr914cp","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8tou0043x3c0ojmiqu13"},{"post_id":"cjp9m8toe002wx3c0t8r1nsgp","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8tou0045x3c0jtd65rxs"},{"post_id":"cjp9m8toe002yx3c05ljzqxx0","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8tox0047x3c0q4t3xh3b"},{"post_id":"cjp9m8tog0030x3c0rglb3prh","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8tox0049x3c087pj80sm"},{"post_id":"cjp9m8toi0033x3c0dygvo8pv","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8toz004bx3c0j1ts8zxt"},{"post_id":"cjp9m8toi0035x3c0g6mhhv38","tag_id":"cjp9m8tos003yx3c0me64pgxd","_id":"cjp9m8toz004cx3c0losy1zh0"}],"Tag":[{"name":"ADB","_id":"cjp9m8tms0004x3c0as2x9w6b"},{"name":"Android四大组件","_id":"cjp9m8tn10008x3c048cs1s18"},{"name":"Android","_id":"cjp9m8tn3000cx3c0hla0e23d"},{"name":"Gradle","_id":"cjp9m8tn4000gx3c0tnr0z06q"},{"name":"Android性能优化","_id":"cjp9m8tna000rx3c0o4fuyd78"},{"name":"View事件分发机制","_id":"cjp9m8tnd000xx3c0zpgjns4n"},{"name":"Android进阶","_id":"cjp9m8tne0012x3c09wz9gwrb"},{"name":"内存优化","_id":"cjp9m8tni001ax3c0v74lwvuh"},{"name":"Bugsnag","_id":"cjp9m8tnk001ex3c0bcevo92t"},{"name":"hexo","_id":"cjp9m8tnp001kx3c0hol8cujo"},{"name":"github","_id":"cjp9m8tnr001px3c0i585udzn"},{"name":"Glide","_id":"cjp9m8tnu001sx3c0urrbbj9s"},{"name":"HTTP","_id":"cjp9m8tnw001yx3c0la7c8ugh"},{"name":"数据结构","_id":"cjp9m8to2002ax3c0ud0mx4n3"},{"name":"Java","_id":"cjp9m8toe002xx3c0rw58qcim"},{"name":"MarkDown","_id":"cjp9m8toh0032x3c0tcw08k3q"},{"name":"OkHttp3","_id":"cjp9m8tok003ax3c0ixc4w9dy"},{"name":"PackageManager","_id":"cjp9m8too003ix3c06l1nso6j"},{"name":"RxJava","_id":"cjp9m8too003kx3c0botnz4y8"},{"name":"Book推荐","_id":"cjp9m8tor003sx3c0xmdgwdoo"},{"name":"自定义View","_id":"cjp9m8tor003ux3c0x94omka9"},{"name":"设计模式","_id":"cjp9m8tos003yx3c0me64pgxd"}]}}