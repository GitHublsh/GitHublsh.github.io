{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/request.png","path":"images/request.png","modified":0,"renderable":0},{"_id":"source/images/httpmessage.jpg","path":"images/httpmessage.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG5.jpeg","path":"images/WechatIMG5.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG3.jpeg","path":"images/WechatIMG3.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/images/WechatIMG7.jpeg","path":"images/WechatIMG7.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/bugsnag.png","path":"images/bugsnag.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b04448c12a71abafb0cb96d551376cfac03d2892","modified":1514961008000},{"_id":"themes/next/.DS_Store","hash":"fd0d4a903c5ea0c77685fae84256369ae804792c","modified":1517996943000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1503932465000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1503932465000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1503932465000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1503932465000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1503932465000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1503932465000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1503932465000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1503932465000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1503932465000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1503932465000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1503932465000},{"_id":"themes/next/_config.yml","hash":"6a29125a3fdd8848253f7cb8743eac8eb54bf3c4","modified":1517997163000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1503932465000},{"_id":"themes/next/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1503932465000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1503932465000},{"_id":"themes/next/package.json","hash":"6b5bfec48776ddf9c03811b1ff2cb2b615eccc88","modified":1503932465000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1511868744000},{"_id":"source/_posts/ADB常用命令备忘录.md","hash":"c6c42f9585184882a940ffa50546780157e7e7ed","modified":1505396631000},{"_id":"source/_posts/Android-Gradle构建入门(一).md","hash":"387ac62cb2f930daa956bab817fc05a0fd666bd4","modified":1514964674000},{"_id":"source/_posts/Android-MVPB.md","hash":"c84144c36338c8c4c87d234df24754a666191750","modified":1503932465000},{"_id":"source/_posts/Android-View事件分发机制.md","hash":"b4a26f15a36698b364a322ce353686da342ef77b","modified":1514614780000},{"_id":"source/_posts/Android屏幕适配解决方案(1).md","hash":"47c1ed23619177e44209c0a0117e0e1c77a17cb2","modified":1503932465000},{"_id":"source/_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","hash":"a24524f56b574c616cafdf934e42deadc5d36aa4","modified":1503932465000},{"_id":"source/_posts/Github-hexo搭建个人博客（3）.md","hash":"a3c4302a7e59ab2518203eb800fc487c4e795f02","modified":1503932465000},{"_id":"source/_posts/Glide4.x源码解析(1)-基本使用.md","hash":"45daa5ad609114c4f228badd84980b1bfed30334","modified":1513000741000},{"_id":"source/_posts/Git提交index.lock问题解决.md","hash":"0e01f071afcfcc2b4d87480e1d6e8dd3cfd210a2","modified":1503932465000},{"_id":"source/_posts/HTTP需要知道的知识点-补充.md","hash":"4275825346833c3bc845ab6221fbea4f5f4745d3","modified":1503932465000},{"_id":"source/_posts/Hexo+Github搭建个人博客（1）.md","hash":"431bf6b793cd93cf67bde8ae52ce1765d8d40e76","modified":1503932465000},{"_id":"source/_posts/Hexo-Github搭建个人博客（2）.md","hash":"52952333d46f03f11a6f6407a251c1c65c8cdafc","modified":1503932465000},{"_id":"source/_posts/Hexo-Github搭建个人博客（4）.md","hash":"b7aa7ecf8f3679099815a7ab36a1a8f8dc4422a0","modified":1503932465000},{"_id":"source/_posts/MarkDown语法.md","hash":"c2253c907f5cecbdadfcf8a4fc8858db590beb8e","modified":1505143429000},{"_id":"source/_posts/Java并发编程：volatile关键字解析.md","hash":"91bca02e3c571360e4a35e7dc1df7251c572655c","modified":1514440661000},{"_id":"source/_posts/OkHttp3源码学习（1）.md","hash":"a99973feb23bcd833e57602f671a7218ddba2bd4","modified":1503932465000},{"_id":"source/_posts/OkHttp3源码学习（2）.md","hash":"9d68f5c576c8e8626f6e3aede9c8ab48947925ed","modified":1503932465000},{"_id":"source/_posts/OkHttp3源码学习（3）.md","hash":"c5515e3b433ec37ecaac9a2e97c163dd789b56e6","modified":1513754542000},{"_id":"source/_posts/OkHttp3源码学习（4）-Dispatcher.md","hash":"139e81b00d2be5b0d8aca421c280414df190d9ab","modified":1509069721000},{"_id":"source/_posts/PackageManager使用姿势.md","hash":"4ccb891b075d09dbb9b6a5e93ae3b5335a2a5b60","modified":1514615394000},{"_id":"source/_posts/RxJava2-0-一.md","hash":"1261abf6419332f16ab043c04fa420ac5a9c5463","modified":1503932465000},{"_id":"source/_posts/RxJava2-0-三-变换操作.md","hash":"028f39c304237fbc03e3942b07c0d071b489b355","modified":1504187471000},{"_id":"source/_posts/RxJava2-0-二.md","hash":"848ea20cc140d276e97eacf4d691c790b3ee0b59","modified":1503932465000},{"_id":"source/_posts/Set集合使用注意tips.md","hash":"f85007dfe3208a04cef2362399f26ad80a549c2a","modified":1503932465000},{"_id":"source/_posts/RxJava2-0-四-Backpressure.md","hash":"2ae659bc7d27523ca069bae37fd07ca7c703286c","modified":1505145469000},{"_id":"source/_posts/hello-world.md","hash":"d0a3314df13f207ed6b91e6d3f32510d7840992c","modified":1503932465000},{"_id":"source/_posts/书读的不多，却想的太多.md","hash":"06030ee1c8cdbfa82d82c2eaa1b77360c2bfb2ab","modified":1504421848000},{"_id":"source/_posts/关于HTTP需要理解的知识点.md","hash":"cb482ddc907156d5596697ad6a14e4561ac31430","modified":1503932465000},{"_id":"source/_posts/多的是，你不知道的事.md","hash":"7377d8f8a368944f197775236a7702533b9ef434","modified":1505662261000},{"_id":"source/_posts/自定义View-2-Canvas简介.md","hash":"c0fa541950b1a9b8e86214a5e265ba871fbfe8cb","modified":1506350239000},{"_id":"source/_posts/自定义View-一.md","hash":"cfe065b228e69dc97715a9dd3bbec26a442a097b","modified":1505964322000},{"_id":"source/_posts/设计模式之路（1）-简单工厂模式.md","hash":"1c9eb0cc17b5dbfca4570406d82c0a9299f16eb1","modified":1503932465000},{"_id":"source/_posts/设计模式之路（2）单一职责原则.md","hash":"312fc33429c2ffdaea870f9d00ba24c497ff89ff","modified":1503932465000},{"_id":"source/_posts/设计模式之路（3）开放-封闭原则.md","hash":"b7355daec1434bf194f0d67c7a3ebcdebda52a63","modified":1503932465000},{"_id":"source/_posts/设计模式之路（4）装饰者模式.md","hash":"9e0583420972cd6a812f84e1ab48978a4f51518e","modified":1503932465000},{"_id":"source/_posts/设计模式之路（5）代理模式.md","hash":"01ee4aca73286c9994c95f4bcd6bc7f1fec04735","modified":1503932465000},{"_id":"source/_posts/设计模式之路（6）依赖倒转原则.md","hash":"6dda0cdc33abc4c88965c6afa051d5a89beed69e","modified":1505056818000},{"_id":"source/_posts/设计模式之路（7）里氏替换原则.md","hash":"49023cb4ed09af1f68103a4a13299ed6186dab9b","modified":1505143108000},{"_id":"source/about/index.md","hash":"3ecb0736ba06879cb06182acc40828a982b52711","modified":1514615817000},{"_id":"source/tags/index.md","hash":"7249889c39305c0af25b6e598a525bb4268390eb","modified":1503932465000},{"_id":"source/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1503932465000},{"_id":"source/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1503932465000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1503932465000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"fdd63b77472612337309eb93ec415a059b90756b","modified":1503932465000},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1503932465000},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1503932465000},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1503932465000},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1503932465000},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1503932465000},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1503932465000},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1503932465000},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1503932465000},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1503932465000},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1503932465000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1503932465000},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1503932465000},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1503932465000},{"_id":"themes/next/layout/.DS_Store","hash":"8a16db4dab7e881fffe2b6a3742412839494c729","modified":1517996937000},{"_id":"themes/next/layout/_layout.swig","hash":"a44305f8fa7fe9c80eb50c0696a704424b589750","modified":1503932465000},{"_id":"themes/next/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1503932465000},{"_id":"themes/next/layout/category.swig","hash":"82e7bc278559b4335ad974659104eaaf04863032","modified":1503932465000},{"_id":"themes/next/layout/page.swig","hash":"baa667bc801349d5c4984c0f172973d3780400df","modified":1503932465000},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1503932465000},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1503932465000},{"_id":"themes/next/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1503932465000},{"_id":"themes/next/layout/tag.swig","hash":"2e73ee478e981092ea9a5d10dd472a9461db395b","modified":1503932465000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1503932465000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1503932465000},{"_id":"themes/next/source/.DS_Store","hash":"7687ea0a4fafd9ab973aaf5694626dedcf841d58","modified":1511852728000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1503932465000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1503932465000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1503932465000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1503932465000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1503932465000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1503932465000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1503932465000},{"_id":"themes/next/layout/_macro/post.swig","hash":"d6fe43765bc01017ca3f9a384eeddaf28b6382c8","modified":1503932465000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1503932465000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"a2b213c1a7c37cd6e4749f2018371f4c1f4f0d23","modified":1503932465000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1503932465000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"3aea41127cbd5917a2643bd1e6a325c9c9a1af7d","modified":1511852696000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1503932465000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1503932465000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6a7eb93d8aa7d4baa472890bd666b921f449d8af","modified":1503932465000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1503932465000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1503932465000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1503932465000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1503932465000},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"56f82c5f5b42e7f1ce61963f002d5a6007dd0cb8","modified":1511852702000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1503932465000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1503932465000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1503932465000},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"b3b3c630fc702c343479a5a82c697dc816a0c275","modified":1517996903000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1503932465000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1503932465000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1503932465000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1503932465000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1503932465000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1503932465000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1503932465000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1503932465000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1503932465000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1503932465000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1503932465000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1503932465000},{"_id":"themes/next/scripts/tags/note.js","hash":"21b102db8a01c7b15ae2c0ea3ef3d4cf807ec6ed","modified":1503932465000},{"_id":"themes/next/source/css/.DS_Store","hash":"d279ffec25bddbb5af043a1d0c721670be39bb3e","modified":1511852734000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1503932465000},{"_id":"themes/next/source/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1503932465000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1503932465000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1503932465000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1503932465000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1503932465000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1503932465000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1503932465000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1503932465000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1503932465000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1503932465000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1503932465000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1503932465000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1503932465000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1503932465000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1503932465000},{"_id":"themes/next/source/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1503932465000},{"_id":"themes/next/source/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1503932465000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1503932465000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"8733db07de32d1c24710110afa04ff036ade7b4e","modified":1503932465000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1503932465000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1503932465000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1503932465000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1503932465000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1503932465000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1503932465000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1503932465000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1503932465000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1503932465000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1503932465000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1503932465000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1503932465000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1503932465000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1503932465000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1503932465000},{"_id":"themes/next/source/css/_common/.DS_Store","hash":"12c8e79ae301d06ac728cd93363f86cc50c212e0","modified":1511852734000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1503932465000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1503932465000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1503932465000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1503932465000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1503932465000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1503932465000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1503932465000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1503932465000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1503932465000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1503932465000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1503932465000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1503932465000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1503932465000},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1503932465000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1503932465000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1503932465000},{"_id":"themes/next/source/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1503932465000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1503932465000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1503932465000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1503932465000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1503932465000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1503932465000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1503932465000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1503932465000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1503932465000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1503932465000},{"_id":"themes/next/source/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1503932465000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1503932465000},{"_id":"source/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1503932465000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1503932465000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/.DS_Store","hash":"472a356fef49b98d2b0d1be1360de617096be055","modified":1511852784000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1503932465000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1503932465000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1503932465000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1503932465000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1503932465000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1503932465000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1503932465000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1503932465000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1503932465000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1503932465000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1503932465000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"468bc734f47209096588ef1a8e55e60a3b12aa63","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"dfc86d37f5b580977d82af6ef835082d09a0c499","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1503932465000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1503932465000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1503932465000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1503932465000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1503932465000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1503932465000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1503932465000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1503932465000},{"_id":"public/about/index.html","hash":"c87732b7d91d1a83e24d4a7236c95d5af3a53e2b","modified":1517999232683},{"_id":"public/tags/index.html","hash":"e4e467df89735cfed203705c1b5f63cdadbfbffd","modified":1517999232683},{"_id":"public/2017/09/03/书读的不多，却想的太多/index.html","hash":"5f5f80640afe51b54cbf57ab04a9e602af935f5a","modified":1517999232683},{"_id":"public/2016/09/04/MarkDown语法/index.html","hash":"512738c4547a3b9d5e39a8e8fa61306ff5dee7ef","modified":1517999232683},{"_id":"public/archives/2016/09/index.html","hash":"310f257dd90683b0f283384722815a1944175818","modified":1517999232683},{"_id":"public/archives/2016/11/index.html","hash":"64fb99ceacbbdad94ea4711563ded972fa1a24bf","modified":1517999232683},{"_id":"public/archives/2017/02/index.html","hash":"40424f01653971b5409bc2c831795350e030b8a7","modified":1517999232683},{"_id":"public/archives/2017/08/index.html","hash":"f63a64dbb244a73778dd3b9080ab64d85e11ec78","modified":1517999232683},{"_id":"public/archives/2017/09/index.html","hash":"57d0d01780f975b9554cc14aeeb50df3cdbd2e1e","modified":1517999232683},{"_id":"public/archives/2017/10/index.html","hash":"80344637aa5fc89461cc21538f692e2ad478f4b6","modified":1517999232683},{"_id":"public/archives/2017/12/index.html","hash":"fceef3419dbcc40830b407fc771b2af6f7de002e","modified":1517999232683},{"_id":"public/tags/ADB/index.html","hash":"b61a43dd110f5eaf3d38f8a5818ee5c8ed6b3f42","modified":1517999232683},{"_id":"public/tags/Gradle/index.html","hash":"391f73fe64feb8d4437714b4c4c763cc711d82be","modified":1517999232683},{"_id":"public/tags/Android/index.html","hash":"d35eb98fe19f3e50a803a0d66dfc73e154e3be63","modified":1517999232683},{"_id":"public/tags/View事件分发机制/index.html","hash":"a1ee86971c90cb330d28ea59104d58c081282d01","modified":1517999232683},{"_id":"public/tags/Bugsnag/index.html","hash":"8508326643987f40fae31e30ece10150b2baef78","modified":1517999232683},{"_id":"public/tags/hexo/index.html","hash":"d4c17cf0355f6519ffaee0733fec64a3f76babd5","modified":1517999232683},{"_id":"public/tags/github/index.html","hash":"28762a0a89b0dcaafb36331a7ef984a27ca6b123","modified":1517999232683},{"_id":"public/tags/Glide/index.html","hash":"4c5780e0680ff3e52693a07717544881ec939b7a","modified":1517999232684},{"_id":"public/tags/HTTP/index.html","hash":"5603a97b5adcb5d4d7069df287072683012a711e","modified":1517999232684},{"_id":"public/tags/MarkDown/index.html","hash":"cfc70002e9f3692986661b6612f1899b22671937","modified":1517999232684},{"_id":"public/tags/Java/index.html","hash":"3adab5e5d4dc98ddcdaf89fdeaaef9998ad75340","modified":1517999232684},{"_id":"public/tags/OkHttp3/index.html","hash":"12c3c55d6808fafb4497edc33d9388987954122c","modified":1517999232684},{"_id":"public/tags/PackageManager/index.html","hash":"db5497095693fb0511eacd101954decbba4039d0","modified":1517999232684},{"_id":"public/tags/RxJava/index.html","hash":"8445df5cb5f7c1789d1cdd1c208293e4afdfe332","modified":1517999232684},{"_id":"public/tags/Book推荐/index.html","hash":"541bdc6d2a74b2a18c0c6075c9347a241f0cc973","modified":1517999232684},{"_id":"public/tags/Android进阶/index.html","hash":"13b054ef0ffe086319446937c0823655d2c64a6a","modified":1517999232684},{"_id":"public/tags/自定义View/index.html","hash":"6047e6a898330c27e9996292f479f1275420ed5b","modified":1517999232684},{"_id":"public/tags/设计模式/index.html","hash":"d50a65a125d856ea87f9632c9604478b362029fa","modified":1517999232684},{"_id":"public/tags/设计模式/page/2/index.html","hash":"8db7b2252d1f3cb9ae97f84752a1601f049d414f","modified":1517999232684},{"_id":"public/2017/12/30/Android-Gradle构建入门(一)/index.html","hash":"11422bda444d0fa19bb20db78bcf86e241325fc3","modified":1517999232684},{"_id":"public/2017/12/11/Glide4.x源码解析(1)-基本使用/index.html","hash":"ead74863b5ec7eaf20d69eef04a2903df12ac492","modified":1517999232684},{"_id":"public/2017/12/08/Java并发编程：volatile关键字解析/index.html","hash":"5f5d83691c4eaceefa03dfd88af5a0c5f5df6d69","modified":1517999232684},{"_id":"public/2017/10/25/PackageManager使用姿势/index.html","hash":"4fb7ed7b342eb3f4f9d22207ff65e2c40df4e6cb","modified":1517999232684},{"_id":"public/2017/10/11/Android-View事件分发机制/index.html","hash":"51f51f2ba232b97d863a5511d085f7a80d869d14","modified":1517999232684},{"_id":"public/2017/09/21/自定义View-2-Canvas简介/index.html","hash":"6728a465d7f43c3633dd126ec42937cdc8d0dbd5","modified":1517999232684},{"_id":"public/2017/09/11/设计模式之路（7）里氏替换原则/index.html","hash":"ce6ae4d1f94ded502718dd8654eb54a5860f526e","modified":1517999232684},{"_id":"public/2017/09/10/设计模式之路（6）依赖倒转原则/index.html","hash":"2ceb5c25f1c9f74e497f5523f205b17a9602570f","modified":1517999232684},{"_id":"public/2017/09/04/RxJava2-0-四-Backpressure/index.html","hash":"20cd9ca9d707c98bac4b196125e0a899b3cbf876","modified":1517999232684},{"_id":"public/2017/09/03/多的是，你不知道的事/index.html","hash":"2531053ac076801603be20b885fa25da1aed3e4d","modified":1517999232684},{"_id":"public/2017/08/26/自定义View-一/index.html","hash":"a002fa2a9ad34502a5384054ff5ac768d3a23112","modified":1517999232684},{"_id":"public/2017/08/12/RxJava2-0-三-变换操作/index.html","hash":"d6b4c4a897a045497e1013b05131550bd4c3cc2a","modified":1517999232684},{"_id":"public/2017/08/11/RxJava2-0-二/index.html","hash":"3161d783132dcc61fc46d46b8189473712104334","modified":1517999232684},{"_id":"public/2017/08/10/RxJava2-0-一/index.html","hash":"b2281c68e93dd758b44c7c236b5774d50eb08079","modified":1517999232684},{"_id":"public/2017/07/28/OkHttp3源码学习（4）-Dispatcher/index.html","hash":"2ace8689b41ce0f652f12ef56069c30b2ff1169a","modified":1517999232685},{"_id":"public/2017/07/27/OkHttp3源码学习（3）/index.html","hash":"e094e61cf29914c1b14a7a96b82e1c464d1950cd","modified":1517999232685},{"_id":"public/2017/07/26/OkHttp3源码学习（2）/index.html","hash":"db3bacea2f345c080e9bf1a199be17df91705124","modified":1517999232685},{"_id":"public/2017/07/25/OkHttp3源码学习（1）/index.html","hash":"c29710ee827196fe4dcecae61f315bd48d1f88ff","modified":1517999232685},{"_id":"public/2017/07/24/设计模式之路（5）代理模式/index.html","hash":"95ff93ee45d01068c3bd9a83acbec6249d36ba09","modified":1517999232685},{"_id":"public/2017/07/20/Android屏幕适配解决方案(1)/index.html","hash":"1ad83f120626889679470c50d46d661d215fe4da","modified":1517999232685},{"_id":"public/2017/07/19/设计模式之路（4）装饰者模式/index.html","hash":"ca032931d08b9bffdb2da18fad07fa31f23867db","modified":1517999232685},{"_id":"public/2017/07/18/设计模式之路（3）开放-封闭原则/index.html","hash":"13cdd4ee57da02b3129050fbc13af1459ac1e640","modified":1517999232685},{"_id":"public/2017/07/17/设计模式之路（1）-简单工厂模式/index.html","hash":"bcc8e26595d66ba45173fe770c7530d729ba2046","modified":1517999232685},{"_id":"public/2017/07/18/设计模式之路（2）单一职责原则/index.html","hash":"a37b82ac3d1229985b00811660848b754966bea1","modified":1517999232685},{"_id":"public/2017/07/14/Bugsnag-监控应用程序错误，以改善客户体验和代码质量/index.html","hash":"94abc1124bf2c16aa86b23696365b0b35e8ebfaf","modified":1517999232685},{"_id":"public/2017/07/12/Android-MVPB/index.html","hash":"cb8144c90aafcb3707f3f928ffeb3aebdd6b047c","modified":1517999232685},{"_id":"public/2017/02/22/Set集合使用注意tips/index.html","hash":"898f8b3f79f25782336eeda82316e5856dfe769d","modified":1517999232685},{"_id":"public/2016/11/19/HTTP需要知道的知识点-补充/index.html","hash":"80147585de1c67df186a0ec71b702d9d41b2afd7","modified":1517999232685},{"_id":"public/2016/11/13/关于HTTP需要理解的知识点/index.html","hash":"2f37d95aacb2ff431ef75fba7b836471b44d69e5","modified":1517999232685},{"_id":"public/2016/09/24/Hexo-Github搭建个人博客（4）/index.html","hash":"eb0a375e107b05b20641e26979e4a5e4c9dedfc0","modified":1517999232685},{"_id":"public/2016/09/15/Github-hexo搭建个人博客（3）/index.html","hash":"053351df1541abe9cf0f776c985c848855ac8e58","modified":1517999232685},{"_id":"public/2016/09/14/Hexo-Github搭建个人博客（2）/index.html","hash":"cf06401e6b1ab92256596d42b8111b6aeb8bbc06","modified":1517999232685},{"_id":"public/2016/09/12/Git提交index.lock问题解决/index.html","hash":"ec861fed672ac9309c742f280b03f74436ebda86","modified":1517999232685},{"_id":"public/2016/09/10/Hexo+Github搭建个人博客（1）/index.html","hash":"1f935532b40a6cc8ffd35ac94ef919d4976a3371","modified":1517999232685},{"_id":"public/2016/09/02/ADB常用命令备忘录/index.html","hash":"3a33780a2b54207d830369a32aa332b1fe434009","modified":1517999232685},{"_id":"public/2016/09/01/hello-world/index.html","hash":"2b937f54e2a198448acc6493b01474309d3b5115","modified":1517999232685},{"_id":"public/archives/index.html","hash":"ed967fa0a2681fdfdffe2b634c2c238bb473c923","modified":1517999232685},{"_id":"public/archives/2016/index.html","hash":"7a9336d62aaf59ef88d2b45b3945deafbde4b501","modified":1517999232685},{"_id":"public/archives/2017/index.html","hash":"66b8a0d6a3cb287cb267f81fde7a008d9797a534","modified":1517999232685},{"_id":"public/archives/2017/07/index.html","hash":"73c46b8697c1b90adc2b2c0dfecbfa1d2479c940","modified":1517999232685},{"_id":"public/index.html","hash":"42af9de6695ac36d0a345ea2b4ed3aef5b6e4879","modified":1517999232685},{"_id":"public/page/2/index.html","hash":"dff1287576f6d3e5e1035b098bd2229cc5ad7215","modified":1517999232686},{"_id":"public/page/3/index.html","hash":"828340243af11a17a7c30da075aaf1d2f469d04a","modified":1517999232686},{"_id":"public/page/4/index.html","hash":"6371d5b8b2d0d0f7b74b88a91670ddee062d1c21","modified":1517999232686},{"_id":"public/page/5/index.html","hash":"470ce5fb66640c4caae9b4b77f34b02e20a61a06","modified":1517999232686},{"_id":"public/page/6/index.html","hash":"0e48e0f12762e096e5c0927710f565f20b7bfa5c","modified":1517999232686},{"_id":"public/page/7/index.html","hash":"d1f32911f808674c90e2d25aaa43344cd56fba47","modified":1517999232686},{"_id":"public/page/8/index.html","hash":"b4ae3c29ca852fc754c35004d7b7202e4095ce65","modified":1517999232686},{"_id":"public/images/request.png","hash":"b85df2dc3dc9264bf6c66168c2a9d67196bd5c65","modified":1517999232697},{"_id":"public/images/httpmessage.jpg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1517999232697},{"_id":"public/images/WechatIMG5.jpeg","hash":"5bc98778d27a39d99fbfd22ea9aa273d42452530","modified":1517999232697},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1517999232697},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1517999232697},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1517999232697},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1517999232697},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1517999232697},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1517999232697},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1517999232697},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1517999232697},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517999232697},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1517999232697},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1517999232697},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1517999232697},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1517999232697},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1517999232697},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1517999232697},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1517999232697},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1517999232697},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1517999232697},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1517999232697},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1517999232697},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1517999232697},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1517999232697},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1517999232698},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1517999232698},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1517999232698},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1517999232698},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1517999232698},{"_id":"public/images/WechatIMG3.jpeg","hash":"4337731e6cb8425a262b58eb520331a94562bb9e","modified":1517999233179},{"_id":"public/images/WechatIMG7.jpeg","hash":"83c8b5baa65b4ac6150b6e38e743d8f0c9e724ad","modified":1517999233181},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1517999233202},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1517999233202},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1517999233209},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1517999233209},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1517999233209},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1517999233209},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1517999233209},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1517999233209},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1517999233209},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1517999233209},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1517999233209},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1517999233209},{"_id":"public/js/src/utils.js","hash":"0fcb80ec11e6df05ed1a07b9338bef2669f93a70","modified":1517999233209},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1517999233209},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1517999233209},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1517999233210},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1517999233210},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1517999233210},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1517999233210},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1517999233210},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1517999233210},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1517999233210},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1517999233211},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1517999233212},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1517999233212},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1517999233212},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1517999233212},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1517999233212},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1517999233212},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1517999233212},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1517999233212},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1517999233212},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1517999233212},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1517999233212},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1517999233212},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1517999233212},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1517999233212},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1517999233212},{"_id":"public/css/main.css","hash":"1f764d2ee855c79eed355494e247fd38c40acbd8","modified":1517999233212},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1517999233212},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1517999233212},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1517999233212},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1517999233212},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1517999233213},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1517999233213},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1517999233213},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1517999233213},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1517999233213},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1517999233213},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1517999233213},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1517999233213},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1517999233213},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1517999233213},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1517999233213},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1517999233213},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1517999233213},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1517999233213},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1517999233213},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1517999233214},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1517999233214},{"_id":"public/images/avatar.gif","hash":"8093dde4173bafe4997bb5a4ae7e63f8418f9044","modified":1517999233218},{"_id":"public/images/bugsnag.png","hash":"20376560019c2dfa21a8a67c718b4e1bd131d4fa","modified":1517999233237},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1517999233237}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-07-10T08:42:29.000Z","_content":"## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-07-10 16:42:29\n---\n## 关于我\n\n希望能成为一个有趣和有钱的人，实在不行，光有钱就行。\n\n\nName: Neil Liu\n\nWechat: lsh-323\n\nEmail: codeneil@163.com\n\nGithub: https://github.com/GitHublsh\n","updated":"2017-12-30T06:36:57.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjdcxjpmn0037v7c0iw9lszmd","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>希望能成为一个有趣和有钱的人，实在不行，光有钱就行。</p>\n<p>Name: Neil Liu</p>\n<p>Wechat: lsh-323</p>\n<p>Email: codeneil@163.com</p>\n<p>Github: <a href=\"https://github.com/GitHublsh\" target=\"_blank\" rel=\"external\">https://github.com/GitHublsh</a></p>\n"},{"title":"tags","date":"2017-07-10T08:24:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-07-10 16:24:17\ntype: \"tags\"\n---\n","updated":"2017-08-28T15:01:05.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjdcxjpmo0038v7c0h4imcbvt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ADB常用命令备忘录","date":"2016-09-02T15:27:48.000Z","_content":"\n* adb start-server\t启动服务\n\n* adb kill-server\t关闭服务\n\n* adb devices\t显示当前连接的所有设备（如果服务没有开启会自动开启）\n\n* adb install xxx.apk\t将应用安装进设备中\n\n* adb uninstall <包名>\t卸载应用\n\n* adb -s <设备名> <命令>\t如果有多个设备，指定某一个设备进行操作\n\n* adb pull <手机文件> <电脑文件>\t将手机内文件导入到电脑上(文件名均为全称)\n\n* adb push <电脑文件> <手机文件>\t将电脑中文件推送到手机上(文件名均为全称)\n\n* adb shell\t进入手机命令行终端\n\n* adb logcat  打印 Android 的系统日志\n\n* adb logcat | grep MyApp 匹配字符串过滤\n* adb logcat | grep -i myapp 忽略大小写通过字符串过滤\n\n* adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误\n\n* adb bugreport > d:\\bugreport.log  输出比较多，建议重定向到一个文件中\n\n* adb shell pm list package\t不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）\n\n* adb shell pm list package -3\t列出第三方应用\t-s：列出系统应用\t命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用\n\n\n* logcat | grep ActivityManager :查看当前运行的Activity\n* adb shell dumpsys activity activities | grep \"Run\":查看当前运行的Activity ","source":"_posts/ADB常用命令备忘录.md","raw":"---\ntitle: ADB常用命令备忘录\ndate: 2016-09-02 23:27:48\ntags: [ADB]\n---\n\n* adb start-server\t启动服务\n\n* adb kill-server\t关闭服务\n\n* adb devices\t显示当前连接的所有设备（如果服务没有开启会自动开启）\n\n* adb install xxx.apk\t将应用安装进设备中\n\n* adb uninstall <包名>\t卸载应用\n\n* adb -s <设备名> <命令>\t如果有多个设备，指定某一个设备进行操作\n\n* adb pull <手机文件> <电脑文件>\t将手机内文件导入到电脑上(文件名均为全称)\n\n* adb push <电脑文件> <手机文件>\t将电脑中文件推送到手机上(文件名均为全称)\n\n* adb shell\t进入手机命令行终端\n\n* adb logcat  打印 Android 的系统日志\n\n* adb logcat | grep MyApp 匹配字符串过滤\n* adb logcat | grep -i myapp 忽略大小写通过字符串过滤\n\n* adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误\n\n* adb bugreport > d:\\bugreport.log  输出比较多，建议重定向到一个文件中\n\n* adb shell pm list package\t不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）\n\n* adb shell pm list package -3\t列出第三方应用\t-s：列出系统应用\t命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用\n\n\n* logcat | grep ActivityManager :查看当前运行的Activity\n* adb shell dumpsys activity activities | grep \"Run\":查看当前运行的Activity ","slug":"ADB常用命令备忘录","published":1,"updated":"2017-09-14T13:43:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgj0000v7c0x05fm00v","content":"<ul>\n<li><p>adb start-server    启动服务</p>\n</li>\n<li><p>adb kill-server    关闭服务</p>\n</li>\n<li><p>adb devices    显示当前连接的所有设备（如果服务没有开启会自动开启）</p>\n</li>\n<li><p>adb install xxx.apk    将应用安装进设备中</p>\n</li>\n<li><p>adb uninstall &lt;包名&gt;    卸载应用</p>\n</li>\n<li><p>adb -s &lt;设备名&gt; &lt;命令&gt;    如果有多个设备，指定某一个设备进行操作</p>\n</li>\n<li><p>adb pull &lt;手机文件&gt; &lt;电脑文件&gt;    将手机内文件导入到电脑上(文件名均为全称)</p>\n</li>\n<li><p>adb push &lt;电脑文件&gt; &lt;手机文件&gt;    将电脑中文件推送到手机上(文件名均为全称)</p>\n</li>\n<li><p>adb shell    进入手机命令行终端</p>\n</li>\n<li><p>adb logcat  打印 Android 的系统日志</p>\n</li>\n<li><p>adb logcat | grep MyApp 匹配字符串过滤</p>\n</li>\n<li><p>adb logcat | grep -i myapp 忽略大小写通过字符串过滤</p>\n</li>\n<li><p>adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误</p>\n</li>\n<li><p>adb bugreport &gt; d:\\bugreport.log  输出比较多，建议重定向到一个文件中</p>\n</li>\n<li><p>adb shell pm list package    不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）</p>\n</li>\n<li><p>adb shell pm list package -3    列出第三方应用    -s：列出系统应用    命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用</p>\n</li>\n</ul>\n<ul>\n<li>logcat | grep ActivityManager :查看当前运行的Activity</li>\n<li>adb shell dumpsys activity activities | grep “Run”:查看当前运行的Activity </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>adb start-server    启动服务</p>\n</li>\n<li><p>adb kill-server    关闭服务</p>\n</li>\n<li><p>adb devices    显示当前连接的所有设备（如果服务没有开启会自动开启）</p>\n</li>\n<li><p>adb install xxx.apk    将应用安装进设备中</p>\n</li>\n<li><p>adb uninstall &lt;包名&gt;    卸载应用</p>\n</li>\n<li><p>adb -s &lt;设备名&gt; &lt;命令&gt;    如果有多个设备，指定某一个设备进行操作</p>\n</li>\n<li><p>adb pull &lt;手机文件&gt; &lt;电脑文件&gt;    将手机内文件导入到电脑上(文件名均为全称)</p>\n</li>\n<li><p>adb push &lt;电脑文件&gt; &lt;手机文件&gt;    将电脑中文件推送到手机上(文件名均为全称)</p>\n</li>\n<li><p>adb shell    进入手机命令行终端</p>\n</li>\n<li><p>adb logcat  打印 Android 的系统日志</p>\n</li>\n<li><p>adb logcat | grep MyApp 匹配字符串过滤</p>\n</li>\n<li><p>adb logcat | grep -i myapp 忽略大小写通过字符串过滤</p>\n</li>\n<li><p>adb bugreport , 打印dumpsys、dumpstate、logcat的输出，也是用于分析错误</p>\n</li>\n<li><p>adb bugreport &gt; d:\\bugreport.log  输出比较多，建议重定向到一个文件中</p>\n</li>\n<li><p>adb shell pm list package    不带任何选项：列出所有的应用的包名（不知道怎么找应用的包名的同学看这里）</p>\n</li>\n<li><p>adb shell pm list package -3    列出第三方应用    -s：列出系统应用    命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用</p>\n</li>\n</ul>\n<ul>\n<li>logcat | grep ActivityManager :查看当前运行的Activity</li>\n<li>adb shell dumpsys activity activities | grep “Run”:查看当前运行的Activity </li>\n</ul>\n"},{"title":"Android Gradle构建入门 (一)","date":"2017-12-30T09:35:50.000Z","_content":"\n### Android Gradle入门\n\n##### 本文内容来自官方文档整理\n\n\n#### 一、查看生成的Gradle文件列表\n\n默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：\n\n![“asmodel”](http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png)\n\n\n\nAndroid项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。\n\n\n在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。\n\n* settings.gradle\n\n\nGradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：\n\n\tinclude ':app'\n\t\n这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。\n\n* gradle-wrapper.properties\n\n\ngradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：\n\n\tdistributionBase=GRADLE_USER_HOME\n\tdistributionPath=wrapper/dists\n\tzipStoreBase=GRADLE_USER_HOME\n\tzipStorePath=wrapper/dists\n\tdistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n\t\n前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。\n\n最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）\n\n\n#### 二、查看整个项目的build.gradle\n\nproject的build.geadle文件：\n\n\t// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\t\n\tbuildscript {\n\t    \n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t    dependencies {\n\t        classpath 'com.android.tools.build:gradle:3.0.0'\n\t        \n\t\n\t        // NOTE: Do not place your application dependencies here; they belong\n\t        // in the individual module build.gradle files\n\t    }\n\t}\n\t\n\tallprojects {\n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t}\n\t\n\ttask clean(type: Delete) {\n\t    delete rootProject.buildDir\n\t}\n\n\n各个代码块具体作用：\n\n1. buildscript - 下载插件\n2. dependencies - 标识Android插件\n3. allproject - \ttop-level and module projects的配置\n4. task clean - 特设任务\n\nGradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。\n\n当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。\n\nallprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从https://jcenter.bintray.com上的公共Bintray Artifactory存储库的google或jcenter下载。\n\n最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。\n\n#### 三、查看app module的build.gradle\n\n看一下 build.gradle\n\n\tapply plugin: 'com.android.application'\n\t\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n第一行：\n\n\tapply plugin: 'com.android.application'\n\t\n应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。\n\n\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n对这些属性进行简单的介绍：\n\n* compileSdkVersion：Android SDK版本\n* defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。\n\t* applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。\n\n\t\n\t* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\t\n\t* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n\t* versionName:版本名称值用于自己的内部版本跟踪。\n\n\t* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n\n\n\n在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。\n\n\t  buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\n\n继续往下面看，就是这个应用程序所依赖的库\n\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。\n\ntestImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。\n\nandroidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。\n\n\n\tfileTree(dir: 'libs', include: ['*.jar'])\n\t\n是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中\n\n\tcom.android.support:appcompat-v7:26.1.0\n\t\n将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。\n\n\tcom.android.support.constraint:constraint-layout:1.0.2\n\t\n将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。\n\n\n#### 四、运行标准的Gradle任务\n\nAndroid Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建\n\n\t$ ./gradlew build\n\t\n构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.\n\n* 可以在命令行中显示在项目中使用的support-annotations模块的版本。\n\n执行命令，可以看到结果：\n\n\t$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n\t:app:dependencies\n\t\n\t------------------------------------------------------------\n\tProject :app\n\t------------------------------------------------------------\n\t\n\treleaseCompileClasspath - Resolved configuration for compilation for variant: release\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    +--- com.android.support:support-annotations:26.1.0\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    +--- com.android.support:support-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n\t|    |    |         +--- android.arch.lifecycle:common:1.0.0\n\t|    |    |         \\--- android.arch.core:common:1.0.0\n\t|    |    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-ui:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0\n\t|    |         +--- com.android.support:support-compat:26.1.0 (*)\n\t|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n\t|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\t\\--- com.android.support.constraint:constraint-layout:1.0.2\n\t     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\n\n\n从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库\n\n\n* 另一种方式查看所需的版本\n\n执行命令及结果：\n\n\t$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n\t:app:dependencyInsight\n\tcom.android.support:support-annotations:26.1.0\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    \\--- releaseCompileClasspath\n\t+--- com.android.support:support-compat:26.1.0\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-fragment:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    +--- com.android.support:support-v4:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n\t|    \\--- com.android.support:support-core-ui:26.1.0\n\t|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n\t|         +--- com.android.support:support-v4:26.1.0 (*)\n\t|         \\--- com.android.support:support-fragment:26.1.0 (*)\n\t+--- com.android.support:support-core-ui:26.1.0 (*)\n\t+--- com.android.support:support-core-utils:26.1.0 (*)\n\t+--- com.android.support:support-media-compat:26.1.0 (*)\n\t\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\t\n\n这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。\n\n#### 五、查看Gradle窗口可执行的命令\n\n![\"gradle window\"](http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png)\n\n可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：\n\n\tExecuting tasks: [signingReport]\n\t\n\tConfiguration on demand is an incubating feature.\n\t:app:signingReport\n\tVariant: release\n\tConfig: none\n\t----------\n\tVariant: releaseUnitTest\n\tConfig: none\n\t----------\n\tVariant: debug\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugAndroidTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugUnitTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\t\n\tBUILD SUCCESSFUL in 14s\n\t1 actionable task: 1 executed\n\t\n\t\n从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）\n\n\n下面的install，可以通过installDebug来安装应用\n\n也可用命令行来执行：\n\n\t$ ./gradlew installDebug\n\t\n\n\n\n","source":"_posts/Android-Gradle构建入门(一).md","raw":"---\ntitle: Android Gradle构建入门 (一)\ndate: 2017-12-30 17:35:50\ntags: [Gradle]\n---\n\n### Android Gradle入门\n\n##### 本文内容来自官方文档整理\n\n\n#### 一、查看生成的Gradle文件列表\n\n默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：\n\n![“asmodel”](http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png)\n\n\n\nAndroid项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。\n\n\n在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。\n\n* settings.gradle\n\n\nGradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：\n\n\tinclude ':app'\n\t\n这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。\n\n* gradle-wrapper.properties\n\n\ngradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：\n\n\tdistributionBase=GRADLE_USER_HOME\n\tdistributionPath=wrapper/dists\n\tzipStoreBase=GRADLE_USER_HOME\n\tzipStorePath=wrapper/dists\n\tdistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n\t\n前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。\n\n最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）\n\n\n#### 二、查看整个项目的build.gradle\n\nproject的build.geadle文件：\n\n\t// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\t\n\tbuildscript {\n\t    \n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t    dependencies {\n\t        classpath 'com.android.tools.build:gradle:3.0.0'\n\t        \n\t\n\t        // NOTE: Do not place your application dependencies here; they belong\n\t        // in the individual module build.gradle files\n\t    }\n\t}\n\t\n\tallprojects {\n\t    repositories {\n\t        google()\n\t        jcenter()\n\t    }\n\t}\n\t\n\ttask clean(type: Delete) {\n\t    delete rootProject.buildDir\n\t}\n\n\n各个代码块具体作用：\n\n1. buildscript - 下载插件\n2. dependencies - 标识Android插件\n3. allproject - \ttop-level and module projects的配置\n4. task clean - 特设任务\n\nGradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。\n\n当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。\n\nallprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从https://jcenter.bintray.com上的公共Bintray Artifactory存储库的google或jcenter下载。\n\n最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。\n\n#### 三、查看app module的build.gradle\n\n看一下 build.gradle\n\n\tapply plugin: 'com.android.application'\n\t\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n第一行：\n\n\tapply plugin: 'com.android.application'\n\t\n应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。\n\n\n\tandroid {\n\t    compileSdkVersion 26\n\t    defaultConfig {\n\t        applicationId \"com.example.liushihan.gradletest\"\n\t        minSdkVersion 21\n\t        targetSdkVersion 26\n\t        versionCode 1\n\t        versionName \"1.0\"\n\t        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n\t    }\n\t    buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\t}\n\t\n对这些属性进行简单的介绍：\n\n* compileSdkVersion：Android SDK版本\n* defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。\n\t* applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。\n\n\t\n\t* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\t\n\t* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n\t* versionName:版本名称值用于自己的内部版本跟踪。\n\n\t* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n\n\n\n在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。\n\n\t  buildTypes {\n\t        release {\n\t            minifyEnabled false\n\t            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\t        }\n\t    }\n\n\n继续往下面看，就是这个应用程序所依赖的库\n\n\tdependencies {\n\t    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\t    implementation 'com.android.support:appcompat-v7:26.1.0'\n\t    implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n\t    testImplementation 'junit:junit:4.12'\n\t    androidTestImplementation 'com.android.support.test:runner:1.0.1'\n\t    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n\t}\n\n\n配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。\n\ntestImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。\n\nandroidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。\n\n\n\tfileTree(dir: 'libs', include: ['*.jar'])\n\t\n是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中\n\n\tcom.android.support:appcompat-v7:26.1.0\n\t\n将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。\n\n\tcom.android.support.constraint:constraint-layout:1.0.2\n\t\n将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。\n\n\n#### 四、运行标准的Gradle任务\n\nAndroid Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建\n\n\t$ ./gradlew build\n\t\n构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.\n\n* 可以在命令行中显示在项目中使用的support-annotations模块的版本。\n\n执行命令，可以看到结果：\n\n\t$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n\t:app:dependencies\n\t\n\t------------------------------------------------------------\n\tProject :app\n\t------------------------------------------------------------\n\t\n\treleaseCompileClasspath - Resolved configuration for compilation for variant: release\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    +--- com.android.support:support-annotations:26.1.0\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    +--- com.android.support:support-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n\t|    |    |         +--- android.arch.lifecycle:common:1.0.0\n\t|    |    |         \\--- android.arch.core:common:1.0.0\n\t|    |    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    +--- com.android.support:support-core-ui:26.1.0\n\t|    |    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0\n\t|    |         +--- com.android.support:support-compat:26.1.0 (*)\n\t|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n\t|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:support-annotations:26.1.0\n\t|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n\t|    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\t\\--- com.android.support.constraint:constraint-layout:1.0.2\n\t     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\n\n\n从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库\n\n\n* 另一种方式查看所需的版本\n\n执行命令及结果：\n\n\t$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n\t:app:dependencyInsight\n\tcom.android.support:support-annotations:26.1.0\n\t+--- com.android.support:appcompat-v7:26.1.0\n\t|    \\--- releaseCompileClasspath\n\t+--- com.android.support:support-compat:26.1.0\n\t|    +--- com.android.support:support-vector-drawable:26.1.0\n\t|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n\t|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-v4:26.1.0\n\t|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n\t|    +--- com.android.support:support-media-compat:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-fragment:26.1.0\n\t|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n\t|    +--- com.android.support:support-core-utils:26.1.0\n\t|    |    +--- com.android.support:support-v4:26.1.0 (*)\n\t|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n\t|    \\--- com.android.support:support-core-ui:26.1.0\n\t|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n\t|         +--- com.android.support:support-v4:26.1.0 (*)\n\t|         \\--- com.android.support:support-fragment:26.1.0 (*)\n\t+--- com.android.support:support-core-ui:26.1.0 (*)\n\t+--- com.android.support:support-core-utils:26.1.0 (*)\n\t+--- com.android.support:support-media-compat:26.1.0 (*)\n\t\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\t\n\t(*) - dependencies omitted (listed previously)\n\t\n\t\n\tBUILD SUCCESSFUL\n\t\n\n这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。\n\n#### 五、查看Gradle窗口可执行的命令\n\n![\"gradle window\"](http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png)\n\n可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：\n\n\tExecuting tasks: [signingReport]\n\t\n\tConfiguration on demand is an incubating feature.\n\t:app:signingReport\n\tVariant: release\n\tConfig: none\n\t----------\n\tVariant: releaseUnitTest\n\tConfig: none\n\t----------\n\tVariant: debug\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugAndroidTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\tVariant: debugUnitTest\n\tConfig: debug\n\tStore: /Users/liushihan/.android/debug.keystore\n\tAlias: AndroidDebugKey\n\tMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\n\tSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\n\tValid until: 2047年5月1日 星期三\n\t----------\n\t\n\tBUILD SUCCESSFUL in 14s\n\t1 actionable task: 1 executed\n\t\n\t\n从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）\n\n\n下面的install，可以通过installDebug来安装应用\n\n也可用命令行来执行：\n\n\t$ ./gradlew installDebug\n\t\n\n\n\n","slug":"Android-Gradle构建入门(一)","published":1,"updated":"2018-01-03T07:31:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgn0001v7c0ugo0yxsh","content":"<h3 id=\"Android-Gradle入门\"><a href=\"#Android-Gradle入门\" class=\"headerlink\" title=\"Android Gradle入门\"></a>Android Gradle入门</h3><h5 id=\"本文内容来自官方文档整理\"><a href=\"#本文内容来自官方文档整理\" class=\"headerlink\" title=\"本文内容来自官方文档整理\"></a>本文内容来自官方文档整理</h5><h4 id=\"一、查看生成的Gradle文件列表\"><a href=\"#一、查看生成的Gradle文件列表\" class=\"headerlink\" title=\"一、查看生成的Gradle文件列表\"></a>一、查看生成的Gradle文件列表</h4><p>默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png\" alt=\"“asmodel”\"></p>\n<p>Android项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。</p>\n<p>在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。</p>\n<ul>\n<li>settings.gradle</li>\n</ul>\n<p>Gradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：</p>\n<pre><code>include &apos;:app&apos;\n</code></pre><p>这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。</p>\n<ul>\n<li>gradle-wrapper.properties</li>\n</ul>\n<p>gradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n</code></pre><p>前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。</p>\n<p>最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）</p>\n<h4 id=\"二、查看整个项目的build-gradle\"><a href=\"#二、查看整个项目的build-gradle\" class=\"headerlink\" title=\"二、查看整个项目的build.gradle\"></a>二、查看整个项目的build.gradle</h4><p>project的build.geadle文件：</p>\n<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;\n\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>各个代码块具体作用：</p>\n<ol>\n<li>buildscript - 下载插件</li>\n<li>dependencies - 标识Android插件</li>\n<li>allproject -     top-level and module projects的配置</li>\n<li>task clean - 特设任务</li>\n</ol>\n<p>Gradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。</p>\n<p>当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。</p>\n<p>allprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从<a href=\"https://jcenter.bintray.com上的公共Bintray\" target=\"_blank\" rel=\"external\">https://jcenter.bintray.com上的公共Bintray</a> Artifactory存储库的google或jcenter下载。</p>\n<p>最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。</p>\n<h4 id=\"三、查看app-module的build-gradle\"><a href=\"#三、查看app-module的build-gradle\" class=\"headerlink\" title=\"三、查看app module的build.gradle\"></a>三、查看app module的build.gradle</h4><p>看一下 build.gradle</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>第一行：</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n</code></pre><p>应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。</p>\n<pre><code>android {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n</code></pre><p>对这些属性进行简单的介绍：</p>\n<ul>\n<li>compileSdkVersion：Android SDK版本</li>\n<li>defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。<ul>\n<li>applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。</li>\n</ul>\n</li>\n</ul>\n<pre><code>* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\n* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n* versionName:版本名称值用于自己的内部版本跟踪。\n\n* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n</code></pre><p>在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。</p>\n<pre><code>buildTypes {\n      release {\n          minifyEnabled false\n          proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n      }\n  }\n</code></pre><p>继续往下面看，就是这个应用程序所依赖的库</p>\n<pre><code>dependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。</p>\n<p>testImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。</p>\n<p>androidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。</p>\n<pre><code>fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n</code></pre><p>是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中</p>\n<pre><code>com.android.support:appcompat-v7:26.1.0\n</code></pre><p>将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。</p>\n<pre><code>com.android.support.constraint:constraint-layout:1.0.2\n</code></pre><p>将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。</p>\n<h4 id=\"四、运行标准的Gradle任务\"><a href=\"#四、运行标准的Gradle任务\" class=\"headerlink\" title=\"四、运行标准的Gradle任务\"></a>四、运行标准的Gradle任务</h4><p>Android Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建</p>\n<pre><code>$ ./gradlew build\n</code></pre><p>构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.</p>\n<ul>\n<li>可以在命令行中显示在项目中使用的support-annotations模块的版本。</li>\n</ul>\n<p>执行命令，可以看到结果：</p>\n<pre><code>$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n:app:dependencies\n\n------------------------------------------------------------\nProject :app\n------------------------------------------------------------\n\nreleaseCompileClasspath - Resolved configuration for compilation for variant: release\n+--- com.android.support:appcompat-v7:26.1.0\n|    +--- com.android.support:support-annotations:26.1.0\n|    +--- com.android.support:support-v4:26.1.0\n|    |    +--- com.android.support:support-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n|    |    |         +--- android.arch.lifecycle:common:1.0.0\n|    |    |         \\--- android.arch.core:common:1.0.0\n|    |    +--- com.android.support:support-media-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-utils:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-ui:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0\n|    |         +--- com.android.support:support-compat:26.1.0 (*)\n|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:support-annotations:26.1.0\n|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    \\--- com.android.support:animated-vector-drawable:26.1.0\n|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\\--- com.android.support.constraint:constraint-layout:1.0.2\n     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库</p>\n<ul>\n<li>另一种方式查看所需的版本</li>\n</ul>\n<p>执行命令及结果：</p>\n<pre><code>$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n:app:dependencyInsight\ncom.android.support:support-annotations:26.1.0\n+--- com.android.support:appcompat-v7:26.1.0\n|    \\--- releaseCompileClasspath\n+--- com.android.support:support-compat:26.1.0\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-v4:26.1.0\n|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-media-compat:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-fragment:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-core-utils:26.1.0\n|    |    +--- com.android.support:support-v4:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n|    \\--- com.android.support:support-core-ui:26.1.0\n|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n|         +--- com.android.support:support-v4:26.1.0 (*)\n|         \\--- com.android.support:support-fragment:26.1.0 (*)\n+--- com.android.support:support-core-ui:26.1.0 (*)\n+--- com.android.support:support-core-utils:26.1.0 (*)\n+--- com.android.support:support-media-compat:26.1.0 (*)\n\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。</p>\n<h4 id=\"五、查看Gradle窗口可执行的命令\"><a href=\"#五、查看Gradle窗口可执行的命令\" class=\"headerlink\" title=\"五、查看Gradle窗口可执行的命令\"></a>五、查看Gradle窗口可执行的命令</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png\" alt=\"&quot;gradle window&quot;\"></p>\n<p>可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：</p>\n<pre><code>Executing tasks: [signingReport]\n\nConfiguration on demand is an incubating feature.\n:app:signingReport\nVariant: release\nConfig: none\n----------\nVariant: releaseUnitTest\nConfig: none\n----------\nVariant: debug\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugAndroidTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugUnitTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\n\nBUILD SUCCESSFUL in 14s\n1 actionable task: 1 executed\n</code></pre><p>从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）</p>\n<p>下面的install，可以通过installDebug来安装应用</p>\n<p>也可用命令行来执行：</p>\n<pre><code>$ ./gradlew installDebug\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android-Gradle入门\"><a href=\"#Android-Gradle入门\" class=\"headerlink\" title=\"Android Gradle入门\"></a>Android Gradle入门</h3><h5 id=\"本文内容来自官方文档整理\"><a href=\"#本文内容来自官方文档整理\" class=\"headerlink\" title=\"本文内容来自官方文档整理\"></a>本文内容来自官方文档整理</h5><h4 id=\"一、查看生成的Gradle文件列表\"><a href=\"#一、查看生成的Gradle文件列表\" class=\"headerlink\" title=\"一、查看生成的Gradle文件列表\"></a>一、查看生成的Gradle文件列表</h4><p>默认情况下，Android Studio将以“Android”模式下的“项目视图”开始，如下图所示：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/asandroidmodel.png\" alt=\"“asmodel”\"></p>\n<p>Android项目是Gradle多项目构建，具有顶级build.gradle文件和名为app的子目录，并具有自己的build.gradle文件。 顶层构建文件在图中标记为（Project：HelloWorldGradle），并且应用程序构建文件（Module：app）附加到其中。</p>\n<p>在项目中，可能有两个名为gradle.properties的文件。 一个是本地项目。 另一个只有在主目录的.gradle子目录中具有全局gradle.properties文件的同名文件才存在。</p>\n<ul>\n<li>settings.gradle</li>\n</ul>\n<p>Gradle使用文件settings.gradle来配置多项目构建。 它应该由一行代码组成：</p>\n<pre><code>include &apos;:app&apos;\n</code></pre><p>这就是告诉Gradle，app也是一个Gradle project,当项目中还会依赖别的library，那么还需要在后面添加相应的信息。</p>\n<ul>\n<li>gradle-wrapper.properties</li>\n</ul>\n<p>gradle-wrapper.properties，它配置了所谓的Gradle Wrapper。 这使您可以构建Android项目，而无需首先安装Gradle。 该文件的内容应该类似于：</p>\n<pre><code>distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-4.1-all.zip\n</code></pre><p>前四行表示当包装首次运行时，它将下载Gradle发行版并将其存储在您的主目录中的.gradle / wrapper / dists目录中。</p>\n<p>最后一行显示了distributionUrl的值，这是Gradle将下载指定分配的地址。（具体版本号可能与此处（4.1）中显示的版本号不同，并且URL可能引用二进制版本（-bin），而不是此示例中显示的完整版本（-all）。）</p>\n<h4 id=\"二、查看整个项目的build-gradle\"><a href=\"#二、查看整个项目的build-gradle\" class=\"headerlink\" title=\"二、查看整个项目的build.gradle\"></a>二、查看整个项目的build.gradle</h4><p>project的build.geadle文件：</p>\n<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;\n\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n</code></pre><p>各个代码块具体作用：</p>\n<ol>\n<li>buildscript - 下载插件</li>\n<li>dependencies - 标识Android插件</li>\n<li>allproject -     top-level and module projects的配置</li>\n<li>task clean - 特设任务</li>\n</ol>\n<p>Gradle定义了一种基于Groovy的DSL语言来构建，buildscript标签是DSL的一部分。 它告诉Gradle构建需要一个可能不是基线Gradle分布的一部分的插件，并告诉Gradle在哪里找到它。 在这种情况下，使用坐标语法“group：name：version”指定所需的插件，其中组为com.android.tools.build，名称为gradle，版本为3.0.1。</p>\n<p>当Gradle第一次构建这个项目时，插件将被下载并缓存，所以这个任务只执行一次。</p>\n<p>allprojects标签保存适用于顶层项目及其包含的任何子项目的配置细节。 在这种情况下，该块指定任何所需的依赖项应该从<a href=\"https://jcenter.bintray.com上的公共Bintray\" target=\"_blank\" rel=\"external\">https://jcenter.bintray.com上的公共Bintray</a> Artifactory存储库的google或jcenter下载。</p>\n<p>最后，构建文件包含一个名为clean的自定义（或临时）任务。 它使用内置的任务类型Delete并对其进行配置，以便干净的任务将删除rootProject中的buildDir。 两者都是项目属性，其值默认为该应用程序驻留的项目中的构建目录。</p>\n<h4 id=\"三、查看app-module的build-gradle\"><a href=\"#三、查看app-module的build-gradle\" class=\"headerlink\" title=\"三、查看app module的build.gradle\"></a>三、查看app module的build.gradle</h4><p>看一下 build.gradle</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n\nandroid {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>第一行：</p>\n<pre><code>apply plugin: &apos;com.android.application&apos;\n</code></pre><p>应用Android插件（在项目构建文件的构建脚本部分中引用）到当前项目。Gradle中的插件可以将自定义任务，新配置，依赖关系和其他功能添加到Gradle项目中。 在这种情况下，应用Android插件会添加各种各样的任务，这些任务由接下来显示的android块配置。</p>\n<pre><code>android {\n    compileSdkVersion 26\n    defaultConfig {\n        applicationId &quot;com.example.liushihan.gradletest&quot;\n        minSdkVersion 21\n        targetSdkVersion 26\n        versionCode 1\n        versionName &quot;1.0&quot;\n        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n        }\n    }\n}\n</code></pre><p>对这些属性进行简单的介绍：</p>\n<ul>\n<li>compileSdkVersion：Android SDK版本</li>\n<li>defaultConfig:defaultConfig部分包含应用程序的所有变体（构建类型和产品风格的组合）共享的属性。<ul>\n<li>applicationId:applicationId基于创建应用程序时指定的域名和项目名称，并且在Google Play商店中必须是唯一的。</li>\n</ul>\n</li>\n</ul>\n<pre><code>* minSdkVersion:minSdkVersion是你愿意支持这个应用程序的最低Android API，targetSdkVersion应该是最新的Android版本。\n\n\n* versionCode:versionCode的值应该是在将新版本的应用上传到Google Play商店之前递增的整数。 这个值和applicationId一起告诉Google，这是一个现有应用程序的新版本，而不是一个新的应用程序。\n\n* versionName:版本名称值用于自己的内部版本跟踪。\n\n* testInstrumentationRunner：testInstrumentationRunner属性配置为使用为Android应用程序配置的JUnit 4测试运行器。\n</code></pre><p>在这个代码块下面，就是buildTypes.默认情况下，Android应用程序支持两种构建类型，debug和release.这里没有显示debug配置部分，即使用所有调试的默认设置。</p>\n<pre><code>buildTypes {\n      release {\n          minifyEnabled false\n          proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;\n      }\n  }\n</code></pre><p>继续往下面看，就是这个应用程序所依赖的库</p>\n<pre><code>dependencies {\n    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;\n    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;\n    testImplementation &apos;junit:junit:4.12&apos;\n    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;\n    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;\n}\n</code></pre><p>配置依赖关系是构建Gradle应用程序的基础部分。 在这种情况下，依赖项部分显示了Implementation，testImplementation和androidTestImplementation配置的值。</p>\n<p>testImplementation依赖只包含最新的稳定的JUnit 4发行版。 JUnit类和测试注释将在编译时在src / test / java层次结构中可用。</p>\n<p>androidTestImplementation依赖项是指Espresso测试库，用于Android应用程序的集成测试。 在这种情况下，Espresso在没有通常包含的support-annotations库的情况下被请求，因为已经通过其他依赖项包含了不同的版本。 在后面的步骤中，您将看到如何找出该库的版本以及原因。</p>\n<pre><code>fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])\n</code></pre><p>是一个fileTree依赖项，它将libs文件夹中的所有jar文件添加到编译类路径中</p>\n<pre><code>com.android.support:appcompat-v7:26.1.0\n</code></pre><p>将Android兼容性库添加到项目中。 这使您可以在SDK版本7以前的任何Android应用程序中使用材质设计主题和其他功能。</p>\n<pre><code>com.android.support.constraint:constraint-layout:1.0.2\n</code></pre><p>将Android约束布局添加到项目中。 这允许您在任何像SDK版本9一样早的Android应用程序中使用ConstraintLayout布局类。</p>\n<h4 id=\"四、运行标准的Gradle任务\"><a href=\"#四、运行标准的Gradle任务\" class=\"headerlink\" title=\"四、运行标准的Gradle任务\"></a>四、运行标准的Gradle任务</h4><p>Android Studio通过IDE可以轻松构建和部署应用程序的调试版本，但最终Gradle还是参与其中。可以在Android Studio中命令行使用gradle命令构建</p>\n<pre><code>$ ./gradlew build\n</code></pre><p>构建完成，Build Successful，可以在app/build/outputs/apk目录查看生成的apk,包括debug和release版本的apk.</p>\n<ul>\n<li>可以在命令行中显示在项目中使用的support-annotations模块的版本。</li>\n</ul>\n<p>执行命令，可以看到结果：</p>\n<pre><code>$ ./gradlew :app:dependencies --configuration releaseCompileClasspath\n:app:dependencies\n\n------------------------------------------------------------\nProject :app\n------------------------------------------------------------\n\nreleaseCompileClasspath - Resolved configuration for compilation for variant: release\n+--- com.android.support:appcompat-v7:26.1.0\n|    +--- com.android.support:support-annotations:26.1.0\n|    +--- com.android.support:support-v4:26.1.0\n|    |    +--- com.android.support:support-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- android.arch.lifecycle:runtime:1.0.0\n|    |    |         +--- android.arch.lifecycle:common:1.0.0\n|    |    |         \\--- android.arch.core:common:1.0.0\n|    |    +--- com.android.support:support-media-compat:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-utils:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    +--- com.android.support:support-core-ui:26.1.0\n|    |    |    +--- com.android.support:support-annotations:26.1.0\n|    |    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0\n|    |         +--- com.android.support:support-compat:26.1.0 (*)\n|    |         +--- com.android.support:support-core-ui:26.1.0 (*)\n|    |         \\--- com.android.support:support-core-utils:26.1.0 (*)\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:support-annotations:26.1.0\n|    |    \\--- com.android.support:support-compat:26.1.0 (*)\n|    \\--- com.android.support:animated-vector-drawable:26.1.0\n|         +--- com.android.support:support-vector-drawable:26.1.0 (*)\n|         \\--- com.android.support:support-core-ui:26.1.0 (*)\n\\--- com.android.support.constraint:constraint-layout:1.0.2\n     \\--- com.android.support.constraint:constraint-layout-solver:1.0.2\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>从命令行打印的信息可以看到support-annotations module,version 26.1.0,是appcompat-v7所依赖的一个库</p>\n<ul>\n<li>另一种方式查看所需的版本</li>\n</ul>\n<p>执行命令及结果：</p>\n<pre><code>$ ./gradlew :app:dependencyInsight --dependency support-annotations --configuration releaseCompileClasspath\n:app:dependencyInsight\ncom.android.support:support-annotations:26.1.0\n+--- com.android.support:appcompat-v7:26.1.0\n|    \\--- releaseCompileClasspath\n+--- com.android.support:support-compat:26.1.0\n|    +--- com.android.support:support-vector-drawable:26.1.0\n|    |    +--- com.android.support:appcompat-v7:26.1.0 (*)\n|    |    \\--- com.android.support:animated-vector-drawable:26.1.0\n|    |         \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-v4:26.1.0\n|    |    \\--- com.android.support:appcompat-v7:26.1.0 (*)\n|    +--- com.android.support:support-media-compat:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-fragment:26.1.0\n|    |    \\--- com.android.support:support-v4:26.1.0 (*)\n|    +--- com.android.support:support-core-utils:26.1.0\n|    |    +--- com.android.support:support-v4:26.1.0 (*)\n|    |    \\--- com.android.support:support-fragment:26.1.0 (*)\n|    \\--- com.android.support:support-core-ui:26.1.0\n|         +--- com.android.support:animated-vector-drawable:26.1.0 (*)\n|         +--- com.android.support:support-v4:26.1.0 (*)\n|         \\--- com.android.support:support-fragment:26.1.0 (*)\n+--- com.android.support:support-core-ui:26.1.0 (*)\n+--- com.android.support:support-core-utils:26.1.0 (*)\n+--- com.android.support:support-media-compat:26.1.0 (*)\n\\--- com.android.support:support-vector-drawable:26.1.0 (*)\n\n(*) - dependencies omitted (listed previously)\n\n\nBUILD SUCCESSFUL\n</code></pre><p>这两种方式都可以帮助追踪和解决与library版本冲突的任何问题。</p>\n<h4 id=\"五、查看Gradle窗口可执行的命令\"><a href=\"#五、查看Gradle窗口可执行的命令\" class=\"headerlink\" title=\"五、查看Gradle窗口可执行的命令\"></a>五、查看Gradle窗口可执行的命令</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com//blog/gradlewindow.png\" alt=\"&quot;gradle window&quot;\"></p>\n<p>可以看一下，android-signingReport查看签名报告任务，签名报告任务不需要任何参数，可以双击执行，结果如下：</p>\n<pre><code>Executing tasks: [signingReport]\n\nConfiguration on demand is an incubating feature.\n:app:signingReport\nVariant: release\nConfig: none\n----------\nVariant: releaseUnitTest\nConfig: none\n----------\nVariant: debug\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugAndroidTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\nVariant: debugUnitTest\nConfig: debug\nStore: /Users/liushihan/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 8C:43:C9:2D:61:38:E1:AC:18:7B:93:4B:43:4B:CE:3B\nSHA1: 2A:29:82:41:7F:BA:AE:50:00:B8:DA:94:35:86:10:32:30:9C:A8:87\nValid until: 2047年5月1日 星期三\n----------\n\nBUILD SUCCESSFUL in 14s\n1 actionable task: 1 executed\n</code></pre><p>从打印的结果可以看到，公钥存储路径（这里是用户根目录下的debug.keystore文件）</p>\n<p>下面的install，可以通过installDebug来安装应用</p>\n<p>也可用命令行来执行：</p>\n<pre><code>$ ./gradlew installDebug\n</code></pre>"},{"title":"阿里百川Hotfix 1.4.0 Android接入","date":"2017-07-12T09:33:45.000Z","_content":"\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","source":"_posts/Android-MVPB.md","raw":"---\ntitle: 阿里百川Hotfix 1.4.0 Android接入\ndate: 2017-07-12 17:33:45\ntags: [Android]\n---\n\n\n\n\n### 一.Android Studio签名打包\n自行百度。\n\n### 二.基本配置依赖\nmaven仓库地址：\n\n\trepositories {\n\t   maven {\n\t       url \"http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories\"\n\t   }\n\t}\ngradle坐标版本依赖：\n\n\tdependencies {\n\t    compile 'com.taobao.android:alisdk-hotfix:1.4.0'\n\t}\n\n### 三.配置权限\nHotFix SDK使用到以下权限\n\n\t<! -- 网络权限 -->\n\t<uses-permission android:name=\"android.permission.INTERNET\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\t<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n\t<! -- 外部存储读权限 -->\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n\n### 四.配置AndroidManifest文件\n\n在AndroidManifest.xml中间的application节点下添加如下配置：\n\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.APPSECRET\"\n\tandroid:value=\"your-app-secret\" />\n\t<meta-data\n\tandroid:name=\"com.taobao.android.hotfix.RSASECRET\"\n\tandroid:value=\"your-rsa-secret\" />\napp-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥\n\n### 五.接入SDK\n 接入范例\n\ninitialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.\n\n\tHotFixManager.getInstance().setContext(this)\n\t                .setAppVersion(appVersion)\n\t                .setAppId(appId)\n\t                .setAesKey(null)\n\t                .setSupportHotpatch(true)\n\t                .setEnableDebug(true)\n\t                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n\t                    @Override\n\t                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n\t                        // 补丁加载回调通知\n\t                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n\t                            // TODO: 10/24/16 表明补丁加载成功\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n\t                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n\t                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n\t                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n\t                            //HotFixManager.getInstance().cleanPatches(false);\n\t                        } else {\n\t                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n\t                        }\n\t                    }\n\t                }).initialize();\ninitialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法\n\n\n\n说明： initialize方法\n\n该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:\n\n\tsetContext(this): Application上下文context 必选\n\t\n\tsetAppVersion(appVersion): 应用的版本号 必选\n\t\n\tsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\t\n\tsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\t\n\tsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\t\n\tsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\t\n\tsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n\n* initialize(): sdk初始化方法 必选\n\n* PatchLoadStatusListener接口\n\n\t* 该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:\n\nmode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式\ncode: 补丁加载状态码, 详情查看PatchStatusCode类说明\ninfo: 补丁加载详细说明, 详情查看PatchStatusCode类说明\nhandlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁\n\n这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明\n\n* code: 1 补丁加载成功\n\n* code: 6 服务端没有最新可用的补丁\n* code: 11 RSASECRET错误，官网中的密钥是否正确请检查\n* code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁\n* code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志\n* code: 16 APPSECRET错误，官网中的密钥是否正确请检查\n* code: 18 一键清除补丁\n* code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测\n\n#### queryNewHotPatch方法\n\n该方法主要用于查询服务器是否有新的可用补丁.\n\n* 首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. \n\n* 同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载\n应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁\n补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.\n\n* 只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号>5才会重新下载.\n\n* 同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号\n\n\n\n#### cleanPatches(boolean force)方法\n\n* 参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 \n\n* 当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.\n\n\n\n\n\n \n\n\n \n","slug":"Android-MVPB","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgq0003v7c0bnyqhsa3","content":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一-Android-Studio签名打包\"><a href=\"#一-Android-Studio签名打包\" class=\"headerlink\" title=\"一.Android Studio签名打包\"></a>一.Android Studio签名打包</h3><p>自行百度。</p>\n<h3 id=\"二-基本配置依赖\"><a href=\"#二-基本配置依赖\" class=\"headerlink\" title=\"二.基本配置依赖\"></a>二.基本配置依赖</h3><p>maven仓库地址：</p>\n<pre><code>repositories {\n   maven {\n       url &quot;http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories&quot;\n   }\n}\n</code></pre><p>gradle坐标版本依赖：</p>\n<pre><code>dependencies {\n    compile &apos;com.taobao.android:alisdk-hotfix:1.4.0&apos;\n}\n</code></pre><h3 id=\"三-配置权限\"><a href=\"#三-配置权限\" class=\"headerlink\" title=\"三.配置权限\"></a>三.配置权限</h3><p>HotFix SDK使用到以下权限</p>\n<pre><code>&lt;! -- 网络权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;\n&lt;! -- 外部存储读权限 --&gt;\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;\n</code></pre><h3 id=\"四-配置AndroidManifest文件\"><a href=\"#四-配置AndroidManifest文件\" class=\"headerlink\" title=\"四.配置AndroidManifest文件\"></a>四.配置AndroidManifest文件</h3><p>在AndroidManifest.xml中间的application节点下添加如下配置：</p>\n<pre><code>&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.APPSECRET&quot;\nandroid:value=&quot;your-app-secret&quot; /&gt;\n&lt;meta-data\nandroid:name=&quot;com.taobao.android.hotfix.RSASECRET&quot;\nandroid:value=&quot;your-rsa-secret&quot; /&gt;\n</code></pre><p>app-secret为阿里百川开发者申请百川平台HotFix服务申请得到的App Secret和RSA密钥</p>\n<h3 id=\"五-接入SDK\"><a href=\"#五-接入SDK\" class=\"headerlink\" title=\"五.接入SDK\"></a>五.接入SDK</h3><p> 接入范例</p>\n<p>initialize的调用应该尽可能的早. 强烈推荐在Application.onCreate()中进行SDk初始化以及查询服务器是否有可用补丁的操作.</p>\n<pre><code>HotFixManager.getInstance().setContext(this)\n                .setAppVersion(appVersion)\n                .setAppId(appId)\n                .setAesKey(null)\n                .setSupportHotpatch(true)\n                .setEnableDebug(true)\n                .setPatchLoadStatusStub(new PatchLoadStatusListener() {\n                    @Override\n                    public void onload(final int mode, final int code, final String info, final int handlePatchVersion) {\n                        // 补丁加载回调通知\n                        if (code == PatchStatusCode.CODE_SUCCESS_LOAD) {\n                            // TODO: 10/24/16 表明补丁加载成功\n                        } else if (code == PatchStatusCode.CODE_ERROR_NEEDRESTART) {\n                            // TODO: 10/24/16 表明新补丁生效需要重启. 业务方可自行实现逻辑, 提示用户或者强制重启, 建议: 用户可以监听进入后台事件, 然后应用自杀\n                        } else if (code == PatchStatusCode.CODE_ERROR_INNERENGINEFAIL) {\n                            // 内部引擎加载异常, 推荐此时清空本地补丁, 但是不清空本地版本号, 防止失败补丁重复加载\n                            //HotFixManager.getInstance().cleanPatches(false);\n                        } else {\n                            // TODO: 10/25/16 其它错误信息, 查看PatchStatusCode类说明\n                        }\n                    }\n                }).initialize();\n</code></pre><p>initialize()方法内部会强制调用queryNewHotPatch()方法, 所以此处不需要额外再调用queryNewHotPatch()方法</p>\n<p>说明： initialize方法</p>\n<p>该方法主要做些必要的初始化工作以及如果本地有补丁的话会加载补丁, 所以需要尽可能的早, 推荐在Application的onCreate方法中调用, 由于initialize方法参数越来越多变的原来越臃肿, 所以1.4.0版本修改了调用方式, initialize()方法调用之前你需要先调用如下几个方法, 方法调用说明如下:</p>\n<pre><code>setContext(this): Application上下文context 必选\n\nsetAppVersion(appVersion): 应用的版本号 必选\n\nsetAppId(appId): 百川上应用的唯一标识, 如何获取请查询获取SDK配置信息 必选\n\nsetAesKey(必须16位): 用户自定义aes秘钥, 此时平台无感知这个秘钥, 所以不用担心百川平台会利用你们的补丁做一些非法的事情. 这个参数值必须配合补丁工具的-y参数一起使用, 具体使用参见?Part2 生成patch补丁?的说明, 两者的值需要保持一致, 补丁才能正确被解密进而加载. 可选\n\nsetSupportHotpatch(true/false): 目前的版本热修复方案采用类似andfix本地hook方法方法所以热部署有一定的风险(方法正在被运行然后被patch了可能会导致native层的crash). 用户如果有实时生效的需求以及被patch的方法没有被高频调用那么这个参数可以设置为true. 第一个补丁将会即时生效 可选\n\nsetEnableDebug(true/false): 是否调试模式, 调试模式下会输出日志以及不进行补丁签名校验. 线下调试此参数可以设置为true, 查看日志过滤TAG:BCHotfix, 同时强制不对补丁进行签名校验, 所有就算补丁未签名或者签名失败也发现可以加载成功. 但是正式发布该参数必须设置为false, 需要对补丁签名校验, 否则就可能存在安全漏洞风险 可选\n\nsetPatchLoadStatusStub(new PatchLoadStatusListener()): 设置patch加载状态监听器, 该方法参数需要实现PatchLoadStatusListener接口, 接口说明见1.3.2.2说明 可选 \n</code></pre><ul>\n<li><p>initialize(): sdk初始化方法 必选</p>\n</li>\n<li><p>PatchLoadStatusListener接口</p>\n<ul>\n<li>该接口需要自行实现并传入initialize方法中, 补丁加载状态会回调给该接口, 参数说明如下:</li>\n</ul>\n</li>\n</ul>\n<p>mode: 补丁模式, 0:正常请求模式 1:扫码模式 2:本地补丁模式<br>code: 补丁加载状态码, 详情查看PatchStatusCode类说明<br>info: 补丁加载详细说明, 详情查看PatchStatusCode类说明<br>handlePatchVersion: 当前处理的补丁版本号, 0:无 -1:本地补丁 其它:后台补丁</p>\n<p>这里列举几个常见的code码说明, 详情查看SDK中PatchStatusCode类说明</p>\n<ul>\n<li><p>code: 1 补丁加载成功</p>\n</li>\n<li><p>code: 6 服务端没有最新可用的补丁</p>\n</li>\n<li>code: 11 RSASECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 12 当前应用已经存在一个旧补丁, 应用重启尝试加载新补丁</li>\n<li>code: 13 补丁加载失败, 导致的原因很多种, 比如UnsatisfiedLinkError等异常, 此时应该严格检查logcat异常日志</li>\n<li>code: 16 APPSECRET错误，官网中的密钥是否正确请检查</li>\n<li>code: 18 一键清除补丁</li>\n<li>code: 403 签名不匹配,可能是APPID APPSECRET填错，请检测</li>\n</ul>\n<h4 id=\"queryNewHotPatch方法\"><a href=\"#queryNewHotPatch方法\" class=\"headerlink\" title=\"queryNewHotPatch方法\"></a>queryNewHotPatch方法</h4><p>该方法主要用于查询服务器是否有新的可用补丁.</p>\n<ul>\n<li><p>首先initialize()方法内部会强制调用queryNewHotPatch()方法, 所以initialize()方法调用之后不需要再调用这个方法, 但是你可以在其它你需要的地方调用. </p>\n</li>\n<li><p>同时SDK内部限制连续两次queryNewHotPatch()方法调用不能短于3s, 否则的话就会报code:19的错误码. 如果查询到可用的话, 首先下载补丁到本地, 然后应用原本没有补丁, 那么第一个补丁会立刻加载<br>应用已经存在一个补丁, 首先会把之前的补丁文件删除, 然后不立刻加载, 而是等待下次应用重启再加载该补丁<br>补丁在后台发布之后, 并不会主动下行推送到客户端, 需要手动调用queryNewHotPatch方法查询后台补丁是否可用.</p>\n</li>\n<li><p>只会下载补丁版本号比当前应用存在的补丁版本号高的补丁, 比如当前应用已经下载了版本号为5的补丁, 那么只有后台发布的补丁版本号&gt;5才会重新下载.</p>\n</li>\n<li><p>同时1.4.0版本服务后台上线了“一键清除”补丁的功能, 所以如果后台点击了“一键清除”那么这个方法将会返回code:18的状态码. 此时本地补丁将会被强制清除, 同时不清除本地补丁版本号</p>\n</li>\n</ul>\n<h4 id=\"cleanPatches-boolean-force-方法\"><a href=\"#cleanPatches-boolean-force-方法\" class=\"headerlink\" title=\"cleanPatches(boolean force)方法\"></a>cleanPatches(boolean force)方法</h4><ul>\n<li><p>参数force表示是否强制清空本地补丁版本号, 比如当前本地补丁版本号是10, 那么下次再次调用queryNewHotPatch方法时, 如果该参数为false: 不清除本地补丁版本号那么后台最新的补丁1就不会重新下载 </p>\n</li>\n<li><p>当然如果存在比10大的补丁版本仍然是可以下载下来的. 如果该参数为true: 清除本地补丁版本号, 本地补丁版本号将会被设置为0, 所以后台只要有任何发布的补丁都能够下载下来.</p>\n</li>\n</ul>\n"},{"title":"Android View事件分发机制","date":"2017-10-11T09:27:08.000Z","_content":"\n### 一、点击事件的传递规则\n\n   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。\n   \n   1. MotionEvent\n   \n      常见的动作：\n      \n      常见的动作常量：\n      \n      * public static final int ACTION_DOWN = 0;单点触摸动作\n    \n      * public static final int ACTION_UP = 1;单点触摸离开动作\n      * public static final int ACTION_MOVE = 2;触摸点移动动作\n      * public static final int ACTION_CANCEL = 3;触摸动作取消\n      * public static final int ACTION_OUTSIDE = 4;触摸动作超出边界\n      * public static final int ACTION_POINTER_DOWN = 5;多点触摸动作\n      * public static final int ACTION_POINTER_UP       = 6;多点离开动作\n\n\n\t\t主要就是：\n\t\t\n\t\t* ACTION_DOWN--手指刚接触屏幕\n\t\t* ACTION_MOVE--手指在屏幕上滑动\n\t\t* ACTION_UP--手指离开屏幕\n\n\t\t\n2. 点击事件的分发中最重要的三个方法\n\n\t* dispatchTouchEvent(MotionEvent event)--事件分发\n\n\t\t* 用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。\n\t\t\n\t* onInterceptTouchEvent(MotionEvent event)--事件拦截\n\n\t\t* 用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。\n\t\t\n\t* onTouchEvent(MotionEvent event)--事件消费\n\n\t\t* 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件\n\n3. 伪代码\n\n\t\tpublic boolean dispatchTouchEvent(MotionEvent ev){\n\t\t\tboolean touch = false;\n\t\t\tif(onInterceptTouchEvent(ev)){\n\t\t\t\ttouch = onTouchEvent(ev);\n\t\t\t}else{\n\t\t\t\ttouch = child.dispatchTouchEvent(ev);\n\t\t\t}\n\t\t\treturn touch;\n\t\t}\n     \n   \n  * 点击事件的传递规则：\n  \t\n  \t\t* 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用\t \n   ","source":"_posts/Android-View事件分发机制.md","raw":"---\ntitle: Android View事件分发机制\ndate: 2017-10-11 17:27:08\ntags: [View事件分发机制]\n---\n\n### 一、点击事件的传递规则\n\n   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。\n   \n   1. MotionEvent\n   \n      常见的动作：\n      \n      常见的动作常量：\n      \n      * public static final int ACTION_DOWN = 0;单点触摸动作\n    \n      * public static final int ACTION_UP = 1;单点触摸离开动作\n      * public static final int ACTION_MOVE = 2;触摸点移动动作\n      * public static final int ACTION_CANCEL = 3;触摸动作取消\n      * public static final int ACTION_OUTSIDE = 4;触摸动作超出边界\n      * public static final int ACTION_POINTER_DOWN = 5;多点触摸动作\n      * public static final int ACTION_POINTER_UP       = 6;多点离开动作\n\n\n\t\t主要就是：\n\t\t\n\t\t* ACTION_DOWN--手指刚接触屏幕\n\t\t* ACTION_MOVE--手指在屏幕上滑动\n\t\t* ACTION_UP--手指离开屏幕\n\n\t\t\n2. 点击事件的分发中最重要的三个方法\n\n\t* dispatchTouchEvent(MotionEvent event)--事件分发\n\n\t\t* 用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。\n\t\t\n\t* onInterceptTouchEvent(MotionEvent event)--事件拦截\n\n\t\t* 用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。\n\t\t\n\t* onTouchEvent(MotionEvent event)--事件消费\n\n\t\t* 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件\n\n3. 伪代码\n\n\t\tpublic boolean dispatchTouchEvent(MotionEvent ev){\n\t\t\tboolean touch = false;\n\t\t\tif(onInterceptTouchEvent(ev)){\n\t\t\t\ttouch = onTouchEvent(ev);\n\t\t\t}else{\n\t\t\t\ttouch = child.dispatchTouchEvent(ev);\n\t\t\t}\n\t\t\treturn touch;\n\t\t}\n     \n   \n  * 点击事件的传递规则：\n  \t\n  \t\t* 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用\t \n   ","slug":"Android-View事件分发机制","published":1,"updated":"2017-12-30T06:19:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgr0004v7c0fho4w1q0","content":"<h3 id=\"一、点击事件的传递规则\"><a href=\"#一、点击事件的传递规则\" class=\"headerlink\" title=\"一、点击事件的传递规则\"></a>一、点击事件的传递规则</h3><p>   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。</p>\n<ol>\n<li><p>MotionEvent</p>\n<p>常见的动作：</p>\n<p>常见的动作常量：</p>\n<ul>\n<li><p>public static final int ACTION_DOWN = 0;单点触摸动作</p>\n</li>\n<li><p>public static final int ACTION_UP = 1;单点触摸离开动作</p>\n</li>\n<li>public static final int ACTION_MOVE = 2;触摸点移动动作</li>\n<li>public static final int ACTION_CANCEL = 3;触摸动作取消</li>\n<li>public static final int ACTION_OUTSIDE = 4;触摸动作超出边界</li>\n<li>public static final int ACTION_POINTER_DOWN = 5;多点触摸动作</li>\n<li>public static final int ACTION_POINTER_UP       = 6;多点离开动作</li>\n</ul>\n</li>\n</ol>\n<pre><code>主要就是：\n\n* ACTION_DOWN--手指刚接触屏幕\n* ACTION_MOVE--手指在屏幕上滑动\n* ACTION_UP--手指离开屏幕\n</code></pre><ol>\n<li><p>点击事件的分发中最重要的三个方法</p>\n<ul>\n<li><p>dispatchTouchEvent(MotionEvent event)–事件分发</p>\n<ul>\n<li>用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。</li>\n</ul>\n</li>\n<li><p>onInterceptTouchEvent(MotionEvent event)–事件拦截</p>\n<ul>\n<li>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。</li>\n</ul>\n</li>\n<li><p>onTouchEvent(MotionEvent event)–事件消费</p>\n<ul>\n<li>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>伪代码</p>\n<pre><code>public boolean dispatchTouchEvent(MotionEvent ev){\n    boolean touch = false;\n    if(onInterceptTouchEvent(ev)){\n        touch = onTouchEvent(ev);\n    }else{\n        touch = child.dispatchTouchEvent(ev);\n    }\n    return touch;\n}\n</code></pre></li>\n</ol>\n<ul>\n<li><p>点击事件的传递规则：</p>\n<pre><code>* 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用     \n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、点击事件的传递规则\"><a href=\"#一、点击事件的传递规则\" class=\"headerlink\" title=\"一、点击事件的传递规则\"></a>一、点击事件的传递规则</h3><p>   首先，要明白点击事件的分发就是MotionEvent事件的分发过程。</p>\n<ol>\n<li><p>MotionEvent</p>\n<p>常见的动作：</p>\n<p>常见的动作常量：</p>\n<ul>\n<li><p>public static final int ACTION_DOWN = 0;单点触摸动作</p>\n</li>\n<li><p>public static final int ACTION_UP = 1;单点触摸离开动作</p>\n</li>\n<li>public static final int ACTION_MOVE = 2;触摸点移动动作</li>\n<li>public static final int ACTION_CANCEL = 3;触摸动作取消</li>\n<li>public static final int ACTION_OUTSIDE = 4;触摸动作超出边界</li>\n<li>public static final int ACTION_POINTER_DOWN = 5;多点触摸动作</li>\n<li>public static final int ACTION_POINTER_UP       = 6;多点离开动作</li>\n</ul>\n</li>\n</ol>\n<pre><code>主要就是：\n\n* ACTION_DOWN--手指刚接触屏幕\n* ACTION_MOVE--手指在屏幕上滑动\n* ACTION_UP--手指离开屏幕\n</code></pre><ol>\n<li><p>点击事件的分发中最重要的三个方法</p>\n<ul>\n<li><p>dispatchTouchEvent(MotionEvent event)–事件分发</p>\n<ul>\n<li>用来进行事件分发，如果事件能够传递给当前View,那么这个方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗了当前事件。</li>\n</ul>\n</li>\n<li><p>onInterceptTouchEvent(MotionEvent event)–事件拦截</p>\n<ul>\n<li>用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会再次调用，返回结果表示是否拦截当前事件。</li>\n</ul>\n</li>\n<li><p>onTouchEvent(MotionEvent event)–事件消费</p>\n<ul>\n<li>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>伪代码</p>\n<pre><code>public boolean dispatchTouchEvent(MotionEvent ev){\n    boolean touch = false;\n    if(onInterceptTouchEvent(ev)){\n        touch = onTouchEvent(ev);\n    }else{\n        touch = child.dispatchTouchEvent(ev);\n    }\n    return touch;\n}\n</code></pre></li>\n</ol>\n<ul>\n<li><p>点击事件的传递规则：</p>\n<pre><code>* 对于根ViewGroup来说，点击事件产生后，首先传递给它，这个时候它的dispatchTouchEvent就会被调用     \n</code></pre></li>\n</ul>\n"},{"title":"Android屏幕适配解决方案(1)","date":"2017-07-20T03:23:22.000Z","_content":"\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","source":"_posts/Android屏幕适配解决方案(1).md","raw":"---\ntitle: Android屏幕适配解决方案(1)\ndate: 2017-07-20 11:23:22\ntags: [Android]\n---\n\n\n#### 首先科普一下涉及到的概念\n\n##### 屏幕尺寸定义：\n\n屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。\n\n屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。\n\n\n##### 屏幕分辨率\n\n屏幕分辨率是指屏幕显示的分辨率。\n\n* 屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。\n\n* 显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。\n\n* 单位：px（pixel），1px=1像素点\n\n* Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920\n\n##### 像素密度\n\n* 像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。\n　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸\n　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　\n* 单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi\n\n* 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：\n\n密度类型|代表的分辨率（px)|屏幕像素密度（dpi）\n----|----|----\n低密度（ldpi）|\t240x320\t|120\n中密度（mdpi）|\t320x480|\t160\n高密度（hdpi）|\t480x800|\t240\n超高密度（xhdpi）|\t720x1280|\t320\n超超高密度（xxhdpi）|\t1080x1920\t|480\n\n\n##### 密度无关像素\n\n指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。\n\n一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。\n\n \n\n dip到pixel转化\nResources r = getResources();\nfloat px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());\n\n这样再绘图时候在不同分辨率下，pixel的值是不同的。\n\n##### dp与px的转换\n\n密度类型|代表的分辨率（px）|\t屏幕密度（dpi）|\t换算（px/dp）|\t比例\n----|----|----|----|----\n低密度（ldpi）|240x320|120|1dp=0.75px|3\n中密度（mdpi）|320x480|160|1dp=1px\t|4\n高密度（hdpi）|480x800|240|1dp=1.5px|6\n超高密度（xhdpi）|720x1280|320|1dp=2px\t|8\n超超高密度（xxhdpi)|1080x1920|480|1dp=3px\t|12\n\n\n使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；\n根据屏幕的配置来加载相应的UI布局、用户界面流程\n\n\n\n\n","slug":"Android屏幕适配解决方案(1)","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgt0005v7c05zraynvn","content":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"首先科普一下涉及到的概念\"><a href=\"#首先科普一下涉及到的概念\" class=\"headerlink\" title=\"首先科普一下涉及到的概念\"></a>首先科普一下涉及到的概念</h4><h5 id=\"屏幕尺寸定义：\"><a href=\"#屏幕尺寸定义：\" class=\"headerlink\" title=\"屏幕尺寸定义：\"></a>屏幕尺寸定义：</h5><p>屏幕对角线的尺寸，单位是英寸（1英寸=2.54cm）。</p>\n<p>屏幕尺寸分为物理尺寸和显示分辨率两个部分。物理尺寸是指屏幕的实际大小；屏幕分辨率即把LCD格数（单位是点[dot] ）除以屏幕面积得到的就是屏幕分辨率，这个指标是决定画面好坏的最大因素。</p>\n<h5 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h5><p>屏幕分辨率是指屏幕显示的分辨率。</p>\n<ul>\n<li><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量。屏幕分辨率低时（例如 640 x 480），在屏幕上显示的像素少，但尺寸比较大。屏幕分辨率高时（例如 1600 x 1200），在屏幕上显示的像素多，但尺寸比较小。</p>\n</li>\n<li><p>显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。</p>\n</li>\n<li><p>单位：px（pixel），1px=1像素点</p>\n</li>\n<li><p>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920</p>\n</li>\n</ul>\n<h5 id=\"像素密度\"><a href=\"#像素密度\" class=\"headerlink\" title=\"像素密度\"></a>像素密度</h5><ul>\n<li>像素密度，即每英寸屏幕所拥有的像素数，像素密度越大，显示画面细节就越丰富。<br>　　像素密度=√{（长度像素数^2+宽度像素数^2）}/ 屏幕尺寸<br>　　注：屏幕尺寸单位为英寸 例：分辨率为1280*720 屏幕宽度为6英寸 计算所得像素密度约等于245\n　　</li>\n<li><p>单位：dpi（dots per ich），假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>\n</li>\n<li><p>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px)</th>\n<th>屏幕像素密度（dpi）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080x1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h5><p>指一个抽象意义上的像素，程序用它来定义界面元素。它作为一个与实际密度无关的单位，帮助程序员构建一个布局方案（界面元素的宽度，高度，位置）。</p>\n<p>一个与密度无关的像素，在逻辑尺寸上，与一个位于像素密度为160DPI的屏幕上的像素是一致的，这也是Android平台所假定的默认显示设备。在运行的时候，平台会以目标屏幕的密度作为基准，“透明地”处理所有需要的DIP缩放操作。要把密度无关像素转换为屏幕像素，可以用这样一个简单的公式：pixels = dips * (density / 160)。举个例子，在DPI为240的屏幕上，1个DIP等于1.5个物理像素。我们强烈推荐你用DIP来定义你程序的界面布局，因为这样可以保证你的 UI在各种分辨率的屏幕上都可以正常显示。</p>\n<p> dip到pixel转化<br>Resources r = getResources();<br>float px = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 12, r.getDisplayMetrics());</p>\n<p>这样再绘图时候在不同分辨率下，pixel的值是不同的。</p>\n<h5 id=\"dp与px的转换\"><a href=\"#dp与px的转换\" class=\"headerlink\" title=\"dp与px的转换\"></a>dp与px的转换</h5><table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率（px）</th>\n<th>屏幕密度（dpi）</th>\n<th>换算（px/dp）</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240x320</td>\n<td>120</td>\n<td>1dp=0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320x480</td>\n<td>160</td>\n<td>1dp=1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480x800</td>\n<td>240</td>\n<td>1dp=1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720x1280</td>\n<td>320</td>\n<td>1dp=2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi)</td>\n<td>1080x1920</td>\n<td>480</td>\n<td>1dp=3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果;使得布局、布局组件自适应屏幕尺寸；<br>根据屏幕的配置来加载相应的UI布局、用户界面流程</p>\n"},{"title":"Bugsnag:监控应用程序错误，以改善客户体验和代码质量","date":"2017-07-14T02:48:23.000Z","_content":"\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","source":"_posts/Bugsnag-监控应用程序错误，以改善客户体验和代码质量.md","raw":"---\ntitle: 'Bugsnag:监控应用程序错误，以改善客户体验和代码质量'\ndate: 2017-07-14 10:48:23\ntags: [Bugsnag,Android]\n---\n\n## Bugsnag exception reporter for Android\n\n![“getstart”](http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png) \n\nBugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。\n\n### 主要特性\n\n* 自动报告未处理的异常和崩溃\n* 报告处理异常\n* 记录附加到崩溃报告的日志和添加对用户操作的洞察\n* 附上用户信息来确定多少人受到崩溃的影响\n\n### 使用\n\n1. 创建Bugsnag账号\n2. 完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常\n3. 使用 Bugsnag.notify 来报告已处理的异常\n4. 使用 configuration options 来自定义集成\n\n### 支持\n\n* 阅读集成指南或者配置文件选项\n* 查询已开启或已关闭的类似问题\n* 报告错误或请求功能\n\nGithub : <a>https://github.com/bugsnag/bugsnag-android#features</a>\n\nBugsnag官网：<a>https://app.bugsnag.com/accounts/sf-1/welcome</a>\n\n\n","slug":"Bugsnag-监控应用程序错误，以改善客户体验和代码质量","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgv0008v7c0fqyv3yri","content":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Bugsnag-exception-reporter-for-Android\"><a href=\"#Bugsnag-exception-reporter-for-Android\" class=\"headerlink\" title=\"Bugsnag exception reporter for Android\"></a>Bugsnag exception reporter for Android</h2><p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/bugsnag.png\" alt=\"“getstart”\"> </p>\n<p>Bugsnag的Android崩溃报告库会自动检测Android应用程序中的崩溃，收集诊断信息，并立即通知您的开发团队，帮助您尽快了解和解决问题。</p>\n<h3 id=\"主要特性\"><a href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"></a>主要特性</h3><ul>\n<li>自动报告未处理的异常和崩溃</li>\n<li>报告处理异常</li>\n<li>记录附加到崩溃报告的日志和添加对用户操作的洞察</li>\n<li>附上用户信息来确定多少人受到崩溃的影响</li>\n</ul>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>创建Bugsnag账号</li>\n<li>完成集成指南的说明来报告从你的应用程序中抛出的未处理的异常</li>\n<li>使用 Bugsnag.notify 来报告已处理的异常</li>\n<li>使用 configuration options 来自定义集成</li>\n</ol>\n<h3 id=\"支持\"><a href=\"#支持\" class=\"headerlink\" title=\"支持\"></a>支持</h3><ul>\n<li>阅读集成指南或者配置文件选项</li>\n<li>查询已开启或已关闭的类似问题</li>\n<li>报告错误或请求功能</li>\n</ul>\n<p>Github : <a><a href=\"https://github.com/bugsnag/bugsnag-android#features\" target=\"_blank\" rel=\"external\">https://github.com/bugsnag/bugsnag-android#features</a></a></p>\n<p>Bugsnag官网：<a><a href=\"https://app.bugsnag.com/accounts/sf-1/welcome\" target=\"_blank\" rel=\"external\">https://app.bugsnag.com/accounts/sf-1/welcome</a></a></p>\n"},{"title":"Hexo+Github搭建个人博客（3）","date":"2016-09-15T09:03:56.000Z","_content":"\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","source":"_posts/Github-hexo搭建个人博客（3）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（3）\ndate: 2016-09-15 17:03:56\ntags: [hexo,github]\n---\n\n### 博客中添加图片\n\nhexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~\n\n### 尝试一：\n\n本人写博客采用的macdown,首先尝试了本地图片。\n\n在引用图片位置添加：\n\n\t![“图片名称”](../images/imagename.jpg) \n在日志文件的上级目录，新建文件夹images，用来存放图片。\n\n然后，\n\nhexo g \n\nhexo s\n\n本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。\n\n### 尝试二：\n\n#### 采用七牛云来做图床，亲测可行\n\n步骤：\n\n1. 七牛云账号注册\n2. 创建对象存储\n3. 创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名\n4. 创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]`(http://ot29getcp.bkt.clouddn.com\n/images/request.png)` ）\n\n5.添加后本地运行测试，blog 首页展示和分类展示可行\n\n\n\n\n\n","slug":"Github-hexo搭建个人博客（3）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpgx0009v7c0d0eqekdk","content":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"博客中添加图片\"><a href=\"#博客中添加图片\" class=\"headerlink\" title=\"博客中添加图片\"></a>博客中添加图片</h3><p>hexo+github搭建完，开始开开心心的写博客。但是，到了插入图片的时候，好像不是很友好~</p>\n<h3 id=\"尝试一：\"><a href=\"#尝试一：\" class=\"headerlink\" title=\"尝试一：\"></a>尝试一：</h3><p>本人写博客采用的macdown,首先尝试了本地图片。</p>\n<p>在引用图片位置添加：</p>\n<pre><code>![“图片名称”](../images/imagename.jpg) \n</code></pre><p>在日志文件的上级目录，新建文件夹images，用来存放图片。</p>\n<p>然后，</p>\n<p>hexo g </p>\n<p>hexo s</p>\n<p>本地查看效果，首页显示正常，进入分类目录，打开后，图片无法显示。</p>\n<h3 id=\"尝试二：\"><a href=\"#尝试二：\" class=\"headerlink\" title=\"尝试二：\"></a>尝试二：</h3><h4 id=\"采用七牛云来做图床，亲测可行\"><a href=\"#采用七牛云来做图床，亲测可行\" class=\"headerlink\" title=\"采用七牛云来做图床，亲测可行\"></a>采用七牛云来做图床，亲测可行</h4><p>步骤：</p>\n<ol>\n<li>七牛云账号注册</li>\n<li>创建对象存储</li>\n<li>创建之后，进行内容管理，上传图片，这个时候会生成外链默认域名</li>\n<li>创建成功，在macdown中添加图片的外链域名（例如：![“请求报文”]<code>(http://ot29getcp.bkt.clouddn.com\n/images/request.png)</code> ）</li>\n</ol>\n<p>5.添加后本地运行测试，blog 首页展示和分类展示可行</p>\n"},{"title":"Glide4.x源码解析(1)-基本使用","date":"2017-12-11T08:41:28.000Z","_content":"\n### 一、关于Glide\n\n* 官方定义：\n\n\t* Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。\n\n   * Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。\n\n\t* 虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。\n\n\t\n* 性能\n\n\t两个关键点：\n\t* 图片的解码速度\n\t\n\t* 解码图片带来的资源压力也就是内存消耗\n\n\tGlide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：\n\t\n\t* 自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；\n\t* 积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；\n\t* 深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。\n\t\n\n### 二、使用配置\n\n#### 1.依赖\n\n##### Gradle\n使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖\n\n\trepositories {\n\t  mavenCentral()\n\t  maven { url 'https://maven.google.com' }\n\t}\n\t\n\tdependencies {\n\t    compile 'com.github.bumptech.glide:glide:4.4.0'\n\t    annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'\n\t}\n\n##### Maven\n\n使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖\n\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>glide</artifactId>\n\t  <version>4.4.0</version>\n\t  <type>aar</type>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.google.android</groupId>\n\t  <artifactId>support-v4</artifactId>\n\t  <version>r7</version>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>compiler</artifactId>\n\t  <version>4.4.0</version>\n\t  <optional>true</optional>\n\t</dependency>\n\n#### 2.相关设置\n\n##### 权限\n\n* 网络\n\n当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。\n\n\t<uses-permission android:name=\"android.permission.INTERNET\"/>\n\n* 连接状态\n\n如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。\n\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n\t\n* 本地存储\n\n要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。\n\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\t\n### 三、基本使用\n\nGlide的基本使用很简单：\n\t\n\tGlide.with(fragment)\n\t    .load(myUrl)\n\t    .into(imageView);\n\t    \n一行就可以搞定从网络加载图片，丝柔顺滑。\n\n具体实现：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t\n\t    Button mBtn;\n\t    ImageView imageView;\n\t    String myUrl = \"http://ot29getcp.bkt.clouddn.com/map.png\";\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        mBtn = (Button)findViewById(R.id.downloadimage);\n\t        imageView = (ImageView) findViewById(R.id.image);\n\t        mBtn.setOnClickListener(new View.OnClickListener() {\n\t            @Override\n\t            public void onClick(View v) {\n\t                Glide.with(getApplicationContext())\n\t                        .load(myUrl)\n\t                        .into(imageView);\n\t            }\n\t        });\n\t\n\t    }\n\t}\n\t\n核心代码：\n\n就这一行。\n\n\tGlide.with(getApplicationContext())\n\t\t                        .load(myUrl)\n\t\t                        .into(imageView);\n\n\n\n","source":"_posts/Glide4.x源码解析(1)-基本使用.md","raw":"---\ntitle: Glide4.x源码解析(1)-基本使用\ndate: 2017-12-11 16:41:28\ntags: [Glide]\n---\n\n### 一、关于Glide\n\n* 官方定义：\n\n\t* Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。\n\n   * Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。\n\n\t* 虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。\n\n\t\n* 性能\n\n\t两个关键点：\n\t* 图片的解码速度\n\t\n\t* 解码图片带来的资源压力也就是内存消耗\n\n\tGlide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：\n\t\n\t* 自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；\n\t* 积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；\n\t* 深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。\n\t\n\n### 二、使用配置\n\n#### 1.依赖\n\n##### Gradle\n使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖\n\n\trepositories {\n\t  mavenCentral()\n\t  maven { url 'https://maven.google.com' }\n\t}\n\t\n\tdependencies {\n\t    compile 'com.github.bumptech.glide:glide:4.4.0'\n\t    annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'\n\t}\n\n##### Maven\n\n使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖\n\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>glide</artifactId>\n\t  <version>4.4.0</version>\n\t  <type>aar</type>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.google.android</groupId>\n\t  <artifactId>support-v4</artifactId>\n\t  <version>r7</version>\n\t</dependency>\n\t<dependency>\n\t  <groupId>com.github.bumptech.glide</groupId>\n\t  <artifactId>compiler</artifactId>\n\t  <version>4.4.0</version>\n\t  <optional>true</optional>\n\t</dependency>\n\n#### 2.相关设置\n\n##### 权限\n\n* 网络\n\n当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。\n\n\t<uses-permission android:name=\"android.permission.INTERNET\"/>\n\n* 连接状态\n\n如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。\n\n\t<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n\t\n* 本地存储\n\n要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。\n\n\t<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\t\n### 三、基本使用\n\nGlide的基本使用很简单：\n\t\n\tGlide.with(fragment)\n\t    .load(myUrl)\n\t    .into(imageView);\n\t    \n一行就可以搞定从网络加载图片，丝柔顺滑。\n\n具体实现：\n\n\tpublic class MainActivity extends AppCompatActivity {\n\t\n\t    Button mBtn;\n\t    ImageView imageView;\n\t    String myUrl = \"http://ot29getcp.bkt.clouddn.com/map.png\";\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        mBtn = (Button)findViewById(R.id.downloadimage);\n\t        imageView = (ImageView) findViewById(R.id.image);\n\t        mBtn.setOnClickListener(new View.OnClickListener() {\n\t            @Override\n\t            public void onClick(View v) {\n\t                Glide.with(getApplicationContext())\n\t                        .load(myUrl)\n\t                        .into(imageView);\n\t            }\n\t        });\n\t\n\t    }\n\t}\n\t\n核心代码：\n\n就这一行。\n\n\tGlide.with(getApplicationContext())\n\t\t                        .load(myUrl)\n\t\t                        .into(imageView);\n\n\n\n","slug":"Glide4.x源码解析(1)-基本使用","published":1,"updated":"2017-12-11T13:59:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph0000bv7c01tlxy0f8","content":"<h3 id=\"一、关于Glide\"><a href=\"#一、关于Glide\" class=\"headerlink\" title=\"一、关于Glide\"></a>一、关于Glide</h3><ul>\n<li><p>官方定义：</p>\n<ul>\n<li><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>\n<ul>\n<li>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</li>\n</ul>\n</li>\n<li><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>性能</p>\n<p>  两个关键点：</p>\n<ul>\n<li><p>图片的解码速度</p>\n</li>\n<li><p>解码图片带来的资源压力也就是内存消耗</p>\n<p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>\n</li>\n<li><p>自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；</p>\n</li>\n<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>\n<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、使用配置\"><a href=\"#二、使用配置\" class=\"headerlink\" title=\"二、使用配置\"></a>二、使用配置</h3><h4 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h4><h5 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h5><p>使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖</p>\n<pre><code>repositories {\n  mavenCentral()\n  maven { url &apos;https://maven.google.com&apos; }\n}\n\ndependencies {\n    compile &apos;com.github.bumptech.glide:glide:4.4.0&apos;\n    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.4.0&apos;\n}\n</code></pre><h5 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h5><p>使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;glide&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;type&gt;aar&lt;/type&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.google.android&lt;/groupId&gt;\n  &lt;artifactId&gt;support-v4&lt;/artifactId&gt;\n  &lt;version&gt;r7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;compiler&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"2-相关设置\"><a href=\"#2-相关设置\" class=\"headerlink\" title=\"2.相关设置\"></a>2.相关设置</h4><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h5><ul>\n<li>网络</li>\n</ul>\n<p>当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n</code></pre><ul>\n<li>连接状态</li>\n</ul>\n<p>如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n</code></pre><ul>\n<li>本地存储</li>\n</ul>\n<p>要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n</code></pre><h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>Glide的基本使用很简单：</p>\n<pre><code>Glide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n</code></pre><p>一行就可以搞定从网络加载图片，丝柔顺滑。</p>\n<p>具体实现：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    Button mBtn;\n    ImageView imageView;\n    String myUrl = &quot;http://ot29getcp.bkt.clouddn.com/map.png&quot;;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button)findViewById(R.id.downloadimage);\n        imageView = (ImageView) findViewById(R.id.image);\n        mBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Glide.with(getApplicationContext())\n                        .load(myUrl)\n                        .into(imageView);\n            }\n        });\n\n    }\n}\n</code></pre><p>核心代码：</p>\n<p>就这一行。</p>\n<pre><code>Glide.with(getApplicationContext())\n                            .load(myUrl)\n                            .into(imageView);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、关于Glide\"><a href=\"#一、关于Glide\" class=\"headerlink\" title=\"一、关于Glide\"></a>一、关于Glide</h3><ul>\n<li><p>官方定义：</p>\n<ul>\n<li><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>\n<ul>\n<li>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</li>\n</ul>\n</li>\n<li><p>虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>性能</p>\n<p>  两个关键点：</p>\n<ul>\n<li><p>图片的解码速度</p>\n</li>\n<li><p>解码图片带来的资源压力也就是内存消耗</p>\n<p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>\n</li>\n<li><p>自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；</p>\n</li>\n<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>\n<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、使用配置\"><a href=\"#二、使用配置\" class=\"headerlink\" title=\"二、使用配置\"></a>二、使用配置</h3><h4 id=\"1-依赖\"><a href=\"#1-依赖\" class=\"headerlink\" title=\"1.依赖\"></a>1.依赖</h4><h5 id=\"Gradle\"><a href=\"#Gradle\" class=\"headerlink\" title=\"Gradle\"></a>Gradle</h5><p>使用 Gradle，可从 Maven Central 或 JCenter 中添加对 Glide 的依赖。还需要添加 Android 支持库的依赖</p>\n<pre><code>repositories {\n  mavenCentral()\n  maven { url &apos;https://maven.google.com&apos; }\n}\n\ndependencies {\n    compile &apos;com.github.bumptech.glide:glide:4.4.0&apos;\n    annotationProcessor &apos;com.github.bumptech.glide:compiler:4.4.0&apos;\n}\n</code></pre><h5 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h5><p>使用 Maven，同样可以添加对 Glide 的依赖。同样需要添加Android支持库的依赖</p>\n<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;glide&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;type&gt;aar&lt;/type&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.google.android&lt;/groupId&gt;\n  &lt;artifactId&gt;support-v4&lt;/artifactId&gt;\n  &lt;version&gt;r7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;\n  &lt;artifactId&gt;compiler&lt;/artifactId&gt;\n  &lt;version&gt;4.4.0&lt;/version&gt;\n  &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"2-相关设置\"><a href=\"#2-相关设置\" class=\"headerlink\" title=\"2.相关设置\"></a>2.相关设置</h4><h5 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h5><ul>\n<li>网络</li>\n</ul>\n<p>当需要的图片是需要网络的情况，需在AndroidManifest添加网络权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;\n</code></pre><ul>\n<li>连接状态</li>\n</ul>\n<p>如果你正在从 URL 加载图片，Glide 可以自动帮助你处理片状网络连接：它可以监听用户的连接状态并在用户重新连接到网络时重启之前失败的请求。如果 Glide 检测到你的应用拥有 ACCESS_NETWORK_STATUS 权限，Glide 将自动监听连接状态而不需要额外的改动。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;\n</code></pre><ul>\n<li>本地存储</li>\n</ul>\n<p>要从本地文件夹或 DCIM 或图库中加载图片，你将需要添加 READ_EXTERNAL_STORAGE 权限。</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;\n</code></pre><h3 id=\"三、基本使用\"><a href=\"#三、基本使用\" class=\"headerlink\" title=\"三、基本使用\"></a>三、基本使用</h3><p>Glide的基本使用很简单：</p>\n<pre><code>Glide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n</code></pre><p>一行就可以搞定从网络加载图片，丝柔顺滑。</p>\n<p>具体实现：</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    Button mBtn;\n    ImageView imageView;\n    String myUrl = &quot;http://ot29getcp.bkt.clouddn.com/map.png&quot;;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button)findViewById(R.id.downloadimage);\n        imageView = (ImageView) findViewById(R.id.image);\n        mBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Glide.with(getApplicationContext())\n                        .load(myUrl)\n                        .into(imageView);\n            }\n        });\n\n    }\n}\n</code></pre><p>核心代码：</p>\n<p>就这一行。</p>\n<pre><code>Glide.with(getApplicationContext())\n                            .load(myUrl)\n                            .into(imageView);\n</code></pre>"},{"title":"Git提交index.lock问题解决","date":"2016-09-12T11:07:26.000Z","_content":"\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","source":"_posts/Git提交index.lock问题解决.md","raw":"---\ntitle: Git提交index.lock问题解决\ndate: 2016-09-12 19:07:26\ntags:\n---\n\n\n## Git提交或者添加时，提示index.lock文件存在，无法提交或者添加 \n### 解决办法一：\n1. On linux/unix/gitbash/cygwin, try：\n\n\trm -f .git/index.lock\n\n2. On Windows Command Prompt, try:\n\n\tde >del .git\\index.lock\tde>\n\n\t\n\n### 解决办法二：\n\nde >de>\n\nGo to: Tools > Options > Source Control\nSelect Current source control plug-in as: None\n\n### 解决办法三：\n\ncheck if the git still running (ps -ef | grep git)\nif not, remove the locked file\nif yes, kill the git process at first.\n","slug":"Git提交index.lock问题解决","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph1000dv7c0o6mt1kvh","content":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\"><a href=\"#Git提交或者添加时，提示index-lock文件存在，无法提交或者添加\" class=\"headerlink\" title=\"Git提交或者添加时，提示index.lock文件存在，无法提交或者添加\"></a>Git提交或者添加时，提示index.lock文件存在，无法提交或者添加</h2><h3 id=\"解决办法一：\"><a href=\"#解决办法一：\" class=\"headerlink\" title=\"解决办法一：\"></a>解决办法一：</h3><ol>\n<li><p>On linux/unix/gitbash/cygwin, try：</p>\n<p> rm -f .git/index.lock</p>\n</li>\n<li><p>On Windows Command Prompt, try:</p>\n<p> de &gt;del .git\\index.lock    de&gt;</p>\n</li>\n</ol>\n<h3 id=\"解决办法二：\"><a href=\"#解决办法二：\" class=\"headerlink\" title=\"解决办法二：\"></a>解决办法二：</h3><p>de &gt;de&gt;</p>\n<p>Go to: Tools &gt; Options &gt; Source Control<br>Select Current source control plug-in as: None</p>\n<h3 id=\"解决办法三：\"><a href=\"#解决办法三：\" class=\"headerlink\" title=\"解决办法三：\"></a>解决办法三：</h3><p>check if the git still running (ps -ef | grep git)<br>if not, remove the locked file<br>if yes, kill the git process at first.</p>\n"},{"title":"HTTP需要知道的知识点-补充","date":"2016-11-19T11:33:52.000Z","_content":"\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","source":"_posts/HTTP需要知道的知识点-补充.md","raw":"---\ntitle: HTTP需要知道的知识点-补充\ndate: 2016-11-19 19:33:52\ntags: [HTTP]\n---\n\n* 一、HTTP协议\n\t* 1.1协议的作用及版本\n\t\t* 1.1.1HTTP是Hyper Text Transfer Protocol（超文本--html传输协议）。\n\t\t* 1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。\n\t\t* 1.1.3：Http协议的版本：\n\t\t\t* 1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。\n\t\t\t* 1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。\n\t\t\t\t\t\n\t* 1.2协议的组成\n\t\t* 1.2.1请求部分：\n\t\t\n\t\t\t\tGET /App1/1.html HTTP/1.1\n\t\t\t\tAccept: */*\n\t\t\t\tAccept-Language: zh-cn\n\t\t\t\tAccept-Encoding: gzip, deflate\n\t\t\t\tUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\t\t\t\tHost: localhost:8080\n\t\t\t\tConnection: Keep-Alive\n\t\t\t\t\n\t\t\t\tusername=admin&password=123\n\t\t\t\t\n\t\t请求部分由三部分组成的：\n\t\t\t请求行：位于第一行\n\t\t\t请求消息头：从第二行开始至第一个空行结束\n\t\t\t请求正文：从第一个空行之后的都是正文\n\t\t\t\n\t\t* 1.2.2响应部分：\n\t\t\n\t\t\t\tHTTP/1.1 200 OK\n\t\t\t\tServer: Apache-Coyote/1.1\n\t\t\t\tAccept-Ranges: bytes\n\t\t\t\tETag: W/\"65-1366335797484\"\n\t\t\t\tLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\n\t\t\t\tContent-Type: text/html\n\t\t\t\tContent-Length: 65\n\t\t\t\tDate: Fri, 19 Apr 2013 02:06:23 GMT\n\t\t\t\tWarnning：w1\n\t\t\t\tWarnning: w2\n\n\n\t\t\t响应部分由三部分组成的：\n\t\t\t\n\t\t\t响应行：位于第一行\n\t\t\t\n\t\t\t响应消息头：从第二行开始至第一个空行结束\n\t\t\t\n\t\t\t响应正文：从第一个空行之后的都是正文\n\t\t\t\n\t* 1.3协议详细讲解\n\t\n\t\t请求行：\n\t\tGET /App1/1.html HTTP/1.1\n\t\tGET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n\t\tGET的特点：默认的请求方式。\n\t\t\n\t\t\t/App1/c.html?username=sdsfds&password=234324\n\t把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&password=234324\n\t这样不好:暴露数据；请求行长度有限。\n\t\n\t\tPOST的特点(经常使用的)：借助HTML中的form表单。<form action=\"c.html\" method=\"post\">\n\t请求参数出现在正文部分。长度木有限制。相对安全。\n\t\n### 二、HTTP/1.1：客户端使用的协议的版本\n\n* 响应行：HTTP/1.1 200 OK\n\n\tHTTP/1.1：服务器用的协议版本\n* 响应码：代表服务器处理的结果的一种表示\n\n\t\t200：正常\n\t\t302/307：重定向\n\t\t304:服务器的资源没有被修改\n\t\t404：请求的资源不存在\n\t\t500：服务器报错了\n* OK：响应码描述\n\n* 请求消息头：向服务器传递附加信息\n\t* Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）\n\t* MIME类型名称：大类型/小类型\n\t* Accept-Charset:通知服务器，浏览器支持的字符集\n\t* Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip\n\t* Accept-language:通知服务器，所希望的语言\n\t* Host：请求的主机和端口\n\t* Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链\n\t* Content-Type:通知服务器，请求正文的MIME类型。\n\t* 取值：application/x-www-form-urlencoded默认值\n\t对应的是form表单的enctype属性\n\t* If-Modified-Since:通知服务器，缓存的文件的最后修改时间。\n\t* User-Agent:通知服务器，浏览器类型.\n\t* Content-Length:表示请求消息正文的长度 \n\t* Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 \n\t* Cookie:这是最重要的请求头信息之一（会话有关）\n响应消息头：\n\t* Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）\nServer:通知客户端，服务器的类型\n\t* Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。\n\t* Content-Length：通知客户端响应正文的数据大小\n\t* Content-Type:通知客户端响应正文的MIME类型\n\t* Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）\n\t* Refresh:3\n\t* Refresh:3;URL=其他资源的URI\n\t* Content-Disposition：通知客户端，以下载的方式打开资源。\n\t* Content-Disposition：attachment;filename=1.jpg\n\t* Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）\n\n\t* Expires: -1             网页的有效时间。单位是毫秒\n\t* Cache-Control: no-cache (1.1)  \n\t* Pragma: no-cache   (1.0)                               通知客户端不要缓存\n\n","slug":"HTTP需要知道的知识点-补充","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph3000fv7c0obcpq65h","content":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>一、HTTP协议</p>\n<ul>\n<li><p>1.1协议的作用及版本</p>\n<ul>\n<li>1.1.1HTTP是Hyper Text Transfer Protocol（超文本–html传输协议）。</li>\n<li>1.1.2HTTP协议的作用用户描述客户端与服务器间的数据传递的。</li>\n<li>1.1.3：Http协议的版本：<ul>\n<li>1.0：特点：每次请求服务器上的资源都要建立新的连接，响应完毕后都会关闭连接。是无状态的协议。</li>\n<li>1.1:特点：在一次TCP/IP连接的基础上可以发出多次请求和得到多次的响应。比1.0多了一些请求和响应头。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1.2协议的组成</p>\n<ul>\n<li><p>1.2.1请求部分：</p>\n<pre><code>GET /App1/1.html HTTP/1.1\nAccept: */*\nAccept-Language: zh-cn\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\nHost: localhost:8080\nConnection: Keep-Alive\n\nusername=admin&amp;password=123\n</code></pre><p>请求部分由三部分组成的：<br>  请求行：位于第一行<br>  请求消息头：从第二行开始至第一个空行结束<br>  请求正文：从第一个空行之后的都是正文</p>\n</li>\n<li><p>1.2.2响应部分：</p>\n<pre><code>HTTP/1.1 200 OK\nServer: Apache-Coyote/1.1\nAccept-Ranges: bytes\nETag: W/&quot;65-1366335797484&quot;\nLast-Modified: Fri, 19 Apr 2013 01:43:17 GMT\nContent-Type: text/html\nContent-Length: 65\nDate: Fri, 19 Apr 2013 02:06:23 GMT\nWarnning：w1\nWarnning: w2\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>        响应部分由三部分组成的：\n\n        响应行：位于第一行\n\n        响应消息头：从第二行开始至第一个空行结束\n\n        响应正文：从第一个空行之后的都是正文\n\n* 1.3协议详细讲解\n\n    请求行：\n    GET /App1/1.html HTTP/1.1\n    GET：请求方式。默认的请求方式。其他常用的请求方式还有POST。\n    GET的特点：默认的请求方式。\n\n        /App1/c.html?username=sdsfds&amp;password=234324\n把表单的请求的数据放在了请求的URI的后面。?username=sdsfds&amp;password=234324\n这样不好:暴露数据；请求行长度有限。\n\n    POST的特点(经常使用的)：借助HTML中的form表单。&lt;form action=&quot;c.html&quot; method=&quot;post&quot;&gt;\n请求参数出现在正文部分。长度木有限制。相对安全。\n</code></pre><h3 id=\"二、HTTP-1-1：客户端使用的协议的版本\"><a href=\"#二、HTTP-1-1：客户端使用的协议的版本\" class=\"headerlink\" title=\"二、HTTP/1.1：客户端使用的协议的版本\"></a>二、HTTP/1.1：客户端使用的协议的版本</h3><ul>\n<li><p>响应行：HTTP/1.1 200 OK</p>\n<p>  HTTP/1.1：服务器用的协议版本</p>\n</li>\n<li><p>响应码：代表服务器处理的结果的一种表示</p>\n<pre><code>200：正常\n302/307：重定向\n304:服务器的资源没有被修改\n404：请求的资源不存在\n500：服务器报错了\n</code></pre></li>\n<li><p>OK：响应码描述</p>\n</li>\n<li><p>请求消息头：向服务器传递附加信息</p>\n<ul>\n<li>Accept:通知服务器，浏览器可以接受的MIME类型。（文件系统中用文件扩展名区分数据的类型。网络上用MIME类型来区分数据类型。Tomcat\\conf\\web.mxl）</li>\n<li>MIME类型名称：大类型/小类型</li>\n<li>Accept-Charset:通知服务器，浏览器支持的字符集</li>\n<li>Accept-Encoding:通知服务器，浏览器能够解码的数据压缩方式。比如：gzip</li>\n<li>Accept-language:通知服务器，所希望的语言</li>\n<li>Host：请求的主机和端口</li>\n<li>Referer：是一个URL地址。取值是当前页面之前的那个页面地址的。防盗链</li>\n<li>Content-Type:通知服务器，请求正文的MIME类型。</li>\n<li>取值：application/x-www-form-urlencoded默认值<br>对应的是form表单的enctype属性</li>\n<li>If-Modified-Since:通知服务器，缓存的文件的最后修改时间。</li>\n<li>User-Agent:通知服务器，浏览器类型.</li>\n<li>Content-Length:表示请求消息正文的长度 </li>\n<li>Connection:表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接 </li>\n<li>Cookie:这是最重要的请求头信息之一（会话有关）<br>响应消息头：</li>\n<li>Location:通知客户端，指示新的资源的位置（结合302/307来用。请求重定向）<br>Server:通知客户端，服务器的类型</li>\n<li>Content-Encoding:通知客户端，响应正文的压缩编码方式。常用的是gzip。</li>\n<li>Content-Length：通知客户端响应正文的数据大小</li>\n<li>Content-Type:通知客户端响应正文的MIME类型</li>\n<li>Refresh：让浏览器自动刷新。取值为整数（刷新的时间间隔，单位是秒）</li>\n<li>Refresh:3</li>\n<li>Refresh:3;URL=其他资源的URI</li>\n<li>Content-Disposition：通知客户端，以下载的方式打开资源。</li>\n<li>Content-Disposition：attachment;filename=1.jpg</li>\n<li><p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search服务器端发送的Cookie（会话有关）</p>\n</li>\n<li><p>Expires: -1             网页的有效时间。单位是毫秒</p>\n</li>\n<li>Cache-Control: no-cache (1.1)  </li>\n<li>Pragma: no-cache   (1.0)                               通知客户端不要缓存</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo+Github搭建个人博客(1)","date":"2016-09-10T13:02:08.000Z","_content":"\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","source":"_posts/Hexo+Github搭建个人博客（1）.md","raw":"---\ntitle: Hexo+Github搭建个人博客(1)\ndate: 2016-09-10 21:02:08\ntags: [hexo,github]\n---\n\n## Hexo+Github搭建个人博客(1)\n\n### 一、搭建环境\n\n* Git环境配置\n* node.js环境配置\n* GitHub账号配置\n\t* 首先，你得有一个Github账号。没有的话，手动再见~\n\t* 创建一个Repository\n\t\t* Repository name填写yourname.github.io,其他的地方看心情填写。\n\t\t* 创建之后，开启pages功能，setting-->Github Pages-->Automatic page generator。\n\t\t* ok\n\n* hexo环境搭建\n\t* npm install -g hexo\n\t* 安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）\n\t* 命令行进入文件目录，\n\t\t* hexo init,然后等新建完成\n\t\t* npm install,将在文件中安装node_modeules\n\t\t* 安装完成后，hexo g\n\t\t* hexo s,[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 就可以看到本地的blog了\n\n\t\t\n\t\t\n### 二、基本配置\n\n本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。\n\n---\n* 回到本地新建的Gitblog文件夹，配置_config.yml文件\n\n\t\t# Deployment\n\t\t## Docs: http://hexo.io/docs/deployment.html\n\t\tdeploy:\n\t\t  type:\n\t\t  \n\t修改后：\n\t\t\t\n\t\tdeploy:\n\t\t  type: git\n\t\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t\t  branch: master\n\t\t  \n\t\t  \n\trepository为Github新建的代码库的地址，如上。\n\t\n* 部署到Github上\n\t* hexo deploy(如果报GitHub权限的问题，配置下SSH即可)\n\t\t* ssh-keygen -t rsa -C \"your_email@example.com\"创建ssh\n\t\t* 添加SSH key到GitHub，将公钥拷贝到Github-->Setting-->SSH and GPG keys-->new SSH keys.\n\t* 部署成功后，打开(我的blog)https://githublsh.github.io/\n\n\t\t\n### 三、小结\n\n* 部署步骤\n\n\t1. hexo clean\n\t2. hexo g\n\t3. hexo d\n\n* 修改后，本地预览\n\n\t1. hexo g\n\t2. hexo s\n\t3. 查看页面效果http://localhost:4000","slug":"Hexo+Github搭建个人博客（1）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph4000hv7c05vmco8xz","content":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hexo-Github搭建个人博客-1\"><a href=\"#Hexo-Github搭建个人博客-1\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客(1)\"></a>Hexo+Github搭建个人博客(1)</h2><h3 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h3><ul>\n<li>Git环境配置</li>\n<li>node.js环境配置</li>\n<li><p>GitHub账号配置</p>\n<ul>\n<li>首先，你得有一个Github账号。没有的话，手动再见~</li>\n<li>创建一个Repository<ul>\n<li>Repository name填写yourname.github.io,其他的地方看心情填写。</li>\n<li>创建之后，开启pages功能，setting–&gt;Github Pages–&gt;Automatic page generator。</li>\n<li>ok</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>hexo环境搭建</p>\n<ul>\n<li>npm install -g hexo</li>\n<li>安装完成后，自己在本地文件夹新建一个本地blog文件夹（例如：\\GitBlog）</li>\n<li>命令行进入文件目录，<ul>\n<li>hexo init,然后等新建完成</li>\n<li>npm install,将在文件中安装node_modeules</li>\n<li>安装完成后，hexo g</li>\n<li>hexo s,[info] Hexo is running at <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a>. Press Ctrl+C to stop. 就可以看到本地的blog了</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、基本配置\"><a href=\"#二、基本配置\" class=\"headerlink\" title=\"二、基本配置\"></a>二、基本配置</h3><p>本地的blog已经可以看到了，接下来就是配置后部署到Github,然后大家都可以看到写的东西了。</p>\n<hr>\n<ul>\n<li><p>回到本地新建的Gitblog文件夹，配置_config.yml文件</p>\n<pre><code># Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type:\n</code></pre><p>  修改后：</p>\n<pre><code>deploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre></li>\n</ul>\n<pre><code>repository为Github新建的代码库的地址，如上。\n</code></pre><ul>\n<li>部署到Github上<ul>\n<li>hexo deploy(如果报GitHub权限的问题，配置下SSH即可)<ul>\n<li>ssh-keygen -t rsa -C “your_email@example.com”创建ssh</li>\n<li>添加SSH key到GitHub，将公钥拷贝到Github–&gt;Setting–&gt;SSH and GPG keys–&gt;new SSH keys.</li>\n</ul>\n</li>\n<li>部署成功后，打开(我的blog)<a href=\"https://githublsh.github.io/\" target=\"_blank\" rel=\"external\">https://githublsh.github.io/</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><ul>\n<li><p>部署步骤</p>\n<ol>\n<li>hexo clean</li>\n<li>hexo g</li>\n<li>hexo d</li>\n</ol>\n</li>\n<li><p>修改后，本地预览</p>\n<ol>\n<li>hexo g</li>\n<li>hexo s</li>\n<li>查看页面效果<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></li>\n</ol>\n</li>\n</ul>\n"},{"title":"Hexo+Github搭建个人博客（2）","date":"2016-09-14T06:01:42.000Z","_content":"\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","source":"_posts/Hexo-Github搭建个人博客（2）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（2）\ndate: 2016-09-14 14:01:42\ntags: [hexo,github]\n---\n\t\n### Hexo+Github搭建个人博客（2）\n#### 开始动手配置diy博客\n\t\n---\n\t\n##一、hexo站点配置文件\n\t\n打开存放整个博客文件下_config.yml：\n\t\n\t# Hexo Configuration\n\t## Docs: https://hexo.io/docs/configuration.html\n\t## Source: https://github.com/hexojs/hexo/\n\t\n\t# Site\n\ttitle: Neil's blog\t#网站标题\n\tsubtitle: Let's start from here  #网站副标题\n\tdescription: 优秀不够，你是否无可替代\n\tauthor: Neil Liu\t#博主的名字\n\temail: codeneil@163.com\t\t#博主的邮箱\n\tlanguage: zh-Hans\t#网站使用的语言\n\ttimezone:\t#网站时区\n\t\n\t# URL\n\t## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://yoursite.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\tpermalink_defaults:\n\t\n\t# Directory\t目录配置\n\tsource_dir: source\t#源文件夹，这个文件夹用来存放内容。\n\tpublic_dir: public\t#公共文件夹，这个文件夹用于存放生成的站点文件。\n\ttag_dir: tags\t#标签文件夹\n\tarchive_dir: archives\t#归档文件夹\n\tcategory_dir: categories\t#分类文件夹\n\tcode_dir: downloads/code\n\ti18n_dir: :lang\t#国际化（i18n）文件夹\n\tskip_render:\t#跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\t\n\t# Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\t# 默认布局\n\ttitlecase: false # Transform title into titlecase\n\texternal_link: true # Open external links in new tab\n\tfilename_case: 0\n\trender_drafts: false\n\tpost_asset_folder: false\t#启动 Asset 文件夹\n\trelative_link: false\n\tfuture: true\n\thighlight:\t#代码块的设置 \n\t  enable: true\n\t  line_number: true\n\t  auto_detect: true\n\t  tab_replace:\n\t\n\t# Category & Tag\t 分类和标签的设置\n\tdefault_category: uncategorized\t #默认分类\n\tcategory_map:\t#分类别名\n\ttag_map:#标签别名\n\t\n\t# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n\t## 2: Enable pagination\n\t## 1: Disable pagination\n\t## 0: Fully Disable\n\tarchive: 1\n\tcategory: 1\n\ttag: 1\n\t\n\t# Date / Time format\n\t## Hexo uses Moment.js to parse and display date\n\t## You can customize the date format as defined in\n\t## http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY-MM-DD\n\ttime_format: HH:mm:ss\n\t\n\t# Pagination\n\t## Set per_page to 0 to disable pagination\n\tper_page: 5\n\tpagination_dir: page\t#分页目录\n\t\n\t# Extensions\n\t## Plugins: https://hexo.io/plugins/\n\t## Themes: https://hexo.io/themes/\n\ttheme: next\t# hexo主题\n\t\n\t# Deployment\n\t## Docs: https://hexo.io/docs/deployment.html\n\tdeploy:\n\t  type: git\n\t  repository: git@github.com:Githublsh/Githublsh.github.io.git\n\t  branch: master\n\t  \n\t  \n\t  \n### 二、hexo主题配合文件\n\n打开themes\\next下的_config.yml文件\n\n1. 开启打赏功能\n\n\t\treward_comment: 让我感受一下知识的力量~\n\t\twechatpay: /images/WechatIMG3.jpeg\n\t\talipay: /images/WechatIMG5.jpeg\n\n2. 开启个人微信二维码\n\n\t\t# Wechat Subscriber\n\t\twechat_subscriber:\n\t\t  enabled: true\n\t\t  qcode: /images/WechatIMG7.jpeg\n\t\t  description: 个人微信，欢迎交流\n\t\t  \n\t\t  \n3. 开启侧边栏社交链接\n\n\t\tsocial:\n\t\t  GitHub: https://github.com/your-user-name\n\t\t  Twitter: https://twitter.com/your-user-name\n\t\t  微博: http://weibo.com/your-user-name\n\t\t  豆瓣: http://douban.com/people/your-user-name\n\t\t  知乎: http://www.zhihu.com/people/your-user-name\n\t\t  # so on\n\t\t  \n4. 选择 Scheme\n\n\t\t#scheme: Muse\n\t\tscheme: Mist\n\t\t#scheme: Pisces\n\t\t\n\t\t\n#### 更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\">NexT主题配置</a>\n\n \n\n","slug":"Hexo-Github搭建个人博客（2）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph6000jv7c07arxkyve","content":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客（2）\"><a href=\"#Hexo-Github搭建个人博客（2）\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客（2）\"></a>Hexo+Github搭建个人博客（2）</h3><h4 id=\"开始动手配置diy博客\"><a href=\"#开始动手配置diy博客\" class=\"headerlink\" title=\"开始动手配置diy博客\"></a>开始动手配置diy博客</h4><hr>\n<p>##一、hexo站点配置文件</p>\n<p>打开存放整个博客文件下_config.yml：</p>\n<pre><code># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Neil&apos;s blog    #网站标题\nsubtitle: Let&apos;s start from here  #网站副标题\ndescription: 优秀不够，你是否无可替代\nauthor: Neil Liu    #博主的名字\nemail: codeneil@163.com        #博主的邮箱\nlanguage: zh-Hans    #网站使用的语言\ntimezone:    #网站时区\n\n# URL\n## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory    目录配置\nsource_dir: source    #源文件夹，这个文件夹用来存放内容。\npublic_dir: public    #公共文件夹，这个文件夹用于存放生成的站点文件。\ntag_dir: tags    #标签文件夹\narchive_dir: archives    #归档文件夹\ncategory_dir: categories    #分类文件夹\ncode_dir: downloads/code\ni18n_dir: :lang    #国际化（i18n）文件夹\nskip_render:    #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post    # 默认布局\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false    #启动 Asset 文件夹\nrelative_link: false\nfuture: true\nhighlight:    #代码块的设置 \n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag     分类和标签的设置\ndefault_category: uncategorized     #默认分类\ncategory_map:    #分类别名\ntag_map:#标签别名\n\n# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page    #分页目录\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next    # hexo主题\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:Githublsh/Githublsh.github.io.git\n  branch: master\n</code></pre><h3 id=\"二、hexo主题配合文件\"><a href=\"#二、hexo主题配合文件\" class=\"headerlink\" title=\"二、hexo主题配合文件\"></a>二、hexo主题配合文件</h3><p>打开themes\\next下的_config.yml文件</p>\n<ol>\n<li><p>开启打赏功能</p>\n<pre><code>reward_comment: 让我感受一下知识的力量~\nwechatpay: /images/WechatIMG3.jpeg\nalipay: /images/WechatIMG5.jpeg\n</code></pre></li>\n<li><p>开启个人微信二维码</p>\n<pre><code># Wechat Subscriber\nwechat_subscriber:\n  enabled: true\n  qcode: /images/WechatIMG7.jpeg\n  description: 个人微信，欢迎交流\n</code></pre></li>\n</ol>\n<ol>\n<li><p>开启侧边栏社交链接</p>\n<pre><code>social:\n  GitHub: https://github.com/your-user-name\n  Twitter: https://twitter.com/your-user-name\n  微博: http://weibo.com/your-user-name\n  豆瓣: http://douban.com/people/your-user-name\n  知乎: http://www.zhihu.com/people/your-user-name\n  # so on\n</code></pre></li>\n<li><p>选择 Scheme</p>\n<pre><code>#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n</code></pre></li>\n</ol>\n<h4 id=\"更多自定义配置请参考NexT主题配置\"><a href=\"#更多自定义配置请参考NexT主题配置\" class=\"headerlink\" title=\"更多自定义配置请参考NexT主题配置\"></a>更多自定义配置请参考<a href=\"http://theme-next.iissnan.com/theme-settings.html\" target=\"_blank\" rel=\"external\">NexT主题配置</a></h4>"},{"title":"Hexo+Github搭建个人博客（4）","date":"2016-09-24T09:28:09.000Z","_content":"\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","source":"_posts/Hexo-Github搭建个人博客（4）.md","raw":"---\ntitle: Hexo+Github搭建个人博客（4）\ndate: 2016-09-24 17:28:09\ntags: [hexo,github]\n---\n\n### Hexo+Github搭建个人博客遇到的问题\n\n几日不更博，自己的blog就跳出来捣乱了\n\n很开心的写了一篇blog，好的，机械化操作：\nhexo g --> hexo d\n\n\n坐等部署，然后等着我的是\n\n\tPermission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n\n\n什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ \n\nCalm down!!!\n\n* 那我看看自己的ssh key\n\n   usr/lsh/.ssh\n\n   打开一看，都在啊（此处有坑）\n\n* 测测有没有问题\n\n  ssh -T git@github.com\n  \n  结果居然连不上了。之前一直这样更新博客的，突然连不上。\n  \n* 查看GitHub ssh配置状态\n\n\t也是配好的，和之前一样没动过。\n\t\n* 难道是hexo git node 版本要更新？\n\n 好吧，来吧，更新吧 少年~\n \n* 然并卵\n\n有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次\n\nssh-keygen -t rsa -C \"liu601545126@qq.com\"\n\n生成成功，会显示文件路径。\n\n* 换个姿势，再来一次hexo g->hexo d\n\nWTF!\n\n\t*** Please tell me who you are.\n\t\n\tRun\n\t\n\t  git config --global user.email \"you@example.com\"\n\t  git config --global user.name \"Your Name\"\n\t\n\tto set your account's default identity.\n\tOmit --global to set the identity only in this repository.\n\t\n\t\n我读书少，你别骗我，git我之前可是配置过的~\n算了，再配一次吧~\n\ngit config --global user.email \"youremail@example.com\"\n\ngit config --global user.name \"yourname\"\n\n* 万事具备，只需deploy\n\n然而，现实又给了我一个响亮的耳光\n\n\tFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\n\tError: Permission denied (publickey).\n\tfatal: Could not read from remote repository.\n\t\n\tPlease make sure you have the correct access rights\n\tand the repository exists.\n\t\n\t    at ChildProcess.<anonymous> (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n\t    at emitTwo (events.js:125:13)\n\t    at ChildProcess.emit (events.js:213:7)\n\t    at maybeClose (internal/child_process.js:897:16)\n\t    at Socket.stream.socket.on (internal/child_process.js:340:11)\n\t    at emitOne (events.js:115:13)\n\t    at Socket.emit (events.js:210:7)\n\t    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\t    \n\t    \n\tError: EACCES: permission denied, unlink '/Users/liushihan/GitHublsh/.deploy_git/about/index.html'\n\t\n\t\n我不信！！！说我没权限？\n\nshow me the code\n\n\tssh -T git@github.com\n\tHi GitHublsh! You've successfully authenticated, but GitHub does not provide shell access.\n\t\n明明就···明明就···有···\n\n* 看了下错误，冷静分析一下\n\n应该是这个博客本地库存在未知错误\n\n还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。\n\n\tTo github.com:Githublsh/Githublsh.github.io.git\n\t   0b24cdb..ccae3f1  HEAD -> master\n\tBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\n\tINFO  Deploy done: git\n\t\n终于成功了···\n\n### 小结\n1. 回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~\n\n2. 到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.\n\n3. 遇到没有头绪的问题，那就从头开始解决。\n\n\n\n\n","slug":"Hexo-Github搭建个人博客（4）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph8000lv7c0lum7fokq","content":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo-Github搭建个人博客遇到的问题\"><a href=\"#Hexo-Github搭建个人博客遇到的问题\" class=\"headerlink\" title=\"Hexo+Github搭建个人博客遇到的问题\"></a>Hexo+Github搭建个人博客遇到的问题</h3><p>几日不更博，自己的blog就跳出来捣乱了</p>\n<p>很开心的写了一篇blog，好的，机械化操作：<br>hexo g –&gt; hexo d</p>\n<p>坐等部署，然后等着我的是</p>\n<pre><code>Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:208:5)\n</code></pre><p>什么鬼，感觉受到了伤害，之前明明就是好的。现在hexo不能部署了，sourcetree也不能连接git服务器了，几天不更就坏了？SSH配置了没问题啊~ </p>\n<p>Calm down!!!</p>\n<ul>\n<li><p>那我看看自己的ssh key</p>\n<p> usr/lsh/.ssh</p>\n<p> 打开一看，都在啊（此处有坑）</p>\n</li>\n<li><p>测测有没有问题</p>\n<p>ssh -T git@github.com</p>\n<p>结果居然连不上了。之前一直这样更新博客的，突然连不上。</p>\n</li>\n<li><p>查看GitHub ssh配置状态</p>\n<p>  也是配好的，和之前一样没动过。</p>\n</li>\n<li><p>难道是hexo git node 版本要更新？</p>\n<p>好吧，来吧，更新吧 少年~</p>\n</li>\n<li><p>然并卵</p>\n</li>\n</ul>\n<p>有点生气了，简单粗暴点，删掉之前的ssh key ，重新生成一次</p>\n<p>ssh-keygen -t rsa -C “liu601545126@qq.com”</p>\n<p>生成成功，会显示文件路径。</p>\n<ul>\n<li>换个姿势，再来一次hexo g-&gt;hexo d</li>\n</ul>\n<p>WTF!</p>\n<pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email &quot;you@example.com&quot;\n  git config --global user.name &quot;Your Name&quot;\n\nto set your account&apos;s default identity.\nOmit --global to set the identity only in this repository.\n</code></pre><p>我读书少，你别骗我，git我之前可是配置过的~<br>算了，再配一次吧~</p>\n<p>git config –global user.email “youremail@example.com”</p>\n<p>git config –global user.name “yourname”</p>\n<ul>\n<li>万事具备，只需deploy</li>\n</ul>\n<p>然而，现实又给了我一个响亮的耳光</p>\n<pre><code>FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\n    at ChildProcess.&lt;anonymous&gt; (/Users/liushihan/GitHublsh/node_modules/hexo-util/lib/spawn.js:37:17)\n    at emitTwo (events.js:125:13)\n    at ChildProcess.emit (events.js:213:7)\n    at maybeClose (internal/child_process.js:897:16)\n    at Socket.stream.socket.on (internal/child_process.js:340:11)\n    at emitOne (events.js:115:13)\n    at Socket.emit (events.js:210:7)\n    at Pipe._handle.close [as _onclose] (net.js:549:12)\n\n\nError: EACCES: permission denied, unlink &apos;/Users/liushihan/GitHublsh/.deploy_git/about/index.html&apos;\n</code></pre><p>我不信！！！说我没权限？</p>\n<p>show me the code</p>\n<pre><code>ssh -T git@github.com\nHi GitHublsh! You&apos;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>明明就···明明就···有···</p>\n<ul>\n<li>看了下错误，冷静分析一下</li>\n</ul>\n<p>应该是这个博客本地库存在未知错误</p>\n<p>还是简单粗暴，删掉，重新把git上面的库clone下来，重新生成部署。</p>\n<pre><code>To github.com:Githublsh/Githublsh.github.io.git\n   0b24cdb..ccae3f1  HEAD -&gt; master\nBranch master set up to track remote branch master from git@github.com:Githublsh/Githublsh.github.io.git.\nINFO  Deploy done: git\n</code></pre><p>终于成功了···</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li><p>回头看看，从一开始的ssh key ,和后来的重新生成的ssh key有点不一样（废话，key是唯一的肯定不一样啊），我说的不是这个，我发现之前的key的文件名自己改了，打开看了一下，好像是SourceTree改的。好吧，当然是原谅它啊~</p>\n</li>\n<li><p>到最后发现，是自己的本地库也存在未知错误，果断删掉，重新clone.</p>\n</li>\n<li><p>遇到没有头绪的问题，那就从头开始解决。</p>\n</li>\n</ol>\n"},{"title":"MarkDown语法","date":"2016-09-04T15:30:15.000Z","_content":"\n\n1. 列表\n\n\t* 1.、2.···加空格\n\t* *、+、-加空格\n\n2. 标题\n\t\n\t* 以#数量相对应H1、H2···\n\n3. 行内代码\n\n\t* 可以通过 ``，插入行内代码（` 是 Tab 键上边、数字 1 键左侧的那个按键）\n\n4. 超链接\n\n\t* 普通链接\n\t\t* `[Google](http://www.google.com/)`\n\t\n\t* 指向本地文件的链接\n\t\t* `[icon.png](./images/icon.png)`\n\n5. 图片\n\t\n\t* `![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 \"GitHub,Social Coding\")`\n\n6. 表格\n\n\t* 单元格和表头：\n\t\t* 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\n\n\t\t\t`  name | age `\n\t\t\t\n\t\t\t`\t---- | ---`\n\t\t\t\n\t\t\t`\tLearnShare | 12`\n\t\t\t\n\t\t\t`\tMike |  32 `","source":"_posts/MarkDown语法.md","raw":"---\ntitle: MarkDown语法\ndate: 2016-09-04 23:30:15\ntags: [MarkDown]\n---\n\n\n1. 列表\n\n\t* 1.、2.···加空格\n\t* *、+、-加空格\n\n2. 标题\n\t\n\t* 以#数量相对应H1、H2···\n\n3. 行内代码\n\n\t* 可以通过 ``，插入行内代码（` 是 Tab 键上边、数字 1 键左侧的那个按键）\n\n4. 超链接\n\n\t* 普通链接\n\t\t* `[Google](http://www.google.com/)`\n\t\n\t* 指向本地文件的链接\n\t\t* `[icon.png](./images/icon.png)`\n\n5. 图片\n\t\n\t* `![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&s=100 \"GitHub,Social Coding\")`\n\n6. 表格\n\n\t* 单元格和表头：\n\t\t* 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\n\n\t\t\t`  name | age `\n\t\t\t\n\t\t\t`\t---- | ---`\n\t\t\t\n\t\t\t`\tLearnShare | 12`\n\t\t\t\n\t\t\t`\tMike |  32 `","slug":"MarkDown语法","published":1,"updated":"2017-09-11T15:23:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjph9000nv7c0gcr7oesv","content":"<ol>\n<li><p>列表</p>\n<ul>\n<li>1.、2.···加空格</li>\n<li>*、+、-加空格</li>\n</ul>\n</li>\n<li><p>标题</p>\n<ul>\n<li>以#数量相对应H1、H2···</li>\n</ul>\n</li>\n<li><p>行内代码</p>\n<ul>\n<li>可以通过 <code>`，插入行内代码（</code> 是 Tab 键上边、数字 1 键左侧的那个按键）</li>\n</ul>\n</li>\n<li><p>超链接</p>\n<ul>\n<li><p>普通链接</p>\n<ul>\n<li><code>[Google](http://www.google.com/)</code></li>\n</ul>\n</li>\n<li><p>指向本地文件的链接</p>\n<ul>\n<li><code>[icon.png](./images/icon.png)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>图片</p>\n<ul>\n<li><code>![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;)</code></li>\n</ul>\n</li>\n<li><p>表格</p>\n<ul>\n<li><p>单元格和表头：</p>\n<ul>\n<li><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p>\n<p>  <code>name | age</code></p>\n<p>  <code>---- | ---</code></p>\n<p>  <code>LearnShare | 12</code></p>\n<p>  <code>Mike |  32</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>列表</p>\n<ul>\n<li>1.、2.···加空格</li>\n<li>*、+、-加空格</li>\n</ul>\n</li>\n<li><p>标题</p>\n<ul>\n<li>以#数量相对应H1、H2···</li>\n</ul>\n</li>\n<li><p>行内代码</p>\n<ul>\n<li>可以通过 <code>`，插入行内代码（</code> 是 Tab 键上边、数字 1 键左侧的那个按键）</li>\n</ul>\n</li>\n<li><p>超链接</p>\n<ul>\n<li><p>普通链接</p>\n<ul>\n<li><code>[Google](http://www.google.com/)</code></li>\n</ul>\n</li>\n<li><p>指向本地文件的链接</p>\n<ul>\n<li><code>[icon.png](./images/icon.png)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>图片</p>\n<ul>\n<li><code>![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;)</code></li>\n</ul>\n</li>\n<li><p>表格</p>\n<ul>\n<li><p>单元格和表头：</p>\n<ul>\n<li><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p>\n<p>  <code>name | age</code></p>\n<p>  <code>---- | ---</code></p>\n<p>  <code>LearnShare | 12</code></p>\n<p>  <code>Mike |  32</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"Java并发编程：volatile关键字解析","date":"2017-12-08T02:28:29.000Z","_content":"\n原文出处：http://www.cnblogs.com/dolphin0520/p/3920373.html\n### 一.内存模型的相关概念\n\n计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\n\n\ti = i + 1;\n\t\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n\n这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n\n为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n\n 1. 通过在总线加LOCK#锁的方式\n\n 2. 通过缓存一致性协议\n\n这2种方式都是硬件层面上提供的方式。\n\n在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n### 二.并发编程中的三个概念\n\n在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：\n\n1. 原子性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n\ti = 9;\n\t\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n2. 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n举个简单的例子，看下面这段代码：\n\n\t//线程1执行的代码\n\tint i = 0;\n\ti = 10;\n\t \n\t//线程2执行的代码\n\tj = i;\n\t\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3. 有序性\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\n\tint i = 0;              \n\tboolean flag = false;\n\ti = 1;                //语句1  \n\tflag = true;          //语句2\n\t\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n\tint a = 10;    //语句1\n\tint r = 2;    //语句2\n\ta = a + 3;    //语句3\n\tr = a*a;     //语句4\n\t\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n语句2  语句1  语句3  语句4\n\n那么可不可能是这个执行顺序呢：\n\n 语句2   语句1    语句4   语句3\n \n 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n \n 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n \n\t //线程1:\n\tcontext = loadContext();   //语句1\n\tinited = true;             //语句2\n\t \n\t//线程2:\n\twhile(!inited ){\n\t  sleep()\n\t}\n\tdoSomethingwithconfig(context);\n\t\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n### 三.Java内存模型\n\n在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。\n\n在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n\ti  = 10;\n\t\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\n\n1. 原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n\tx = 10;         //语句1\n\ty = x;         //语句2\n\tx++;           //语句3\n\tx = x + 1;     //语句4\n\t\n咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n2. 可见性\n\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n\n* 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n\n\n* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n\n* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n\n* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n\n* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n\n* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条原则摘自《深入理解Java虚拟机》。\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n### 四.深入剖析volatile关键字\n\n在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。\n\n1. volatile关键字的两层语义\n\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n* 禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n\t//线程1\n\tboolean stop = false;\n\twhile(!stop){\n\t    doSomething();\n\t}\n\t \n\t//线程2\n\tstop = true;\n\t\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n* 第一，使用volatile关键字会强制将修改的值立即写入主存；\n\n* 第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n* 第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2. volatile保证原子性吗？\n\n从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n\n下面看一个例子：\n\n\tpublic class Test {\n\t    public volatile int inc = 0;\n\t \n\t    public void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n\t\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n采用synchronized：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t \n\t    public synchronized void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用Lock：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t    Lock lock = new ReentrantLock();\n\t \n\t    public  void increase() {\n\t        lock.lock();\n\t        try {\n\t            inc++;\n\t        } finally{\n\t            lock.unlock();\n\t        }\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用AtomicInteger：\n\n\tpublic class Test {\n\t    public  AtomicInteger inc = new AtomicInteger();\n\t \n\t    public  void increase() {\n\t        inc.getAndIncrement();\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3. volatile能保证有序性吗？\n\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n\t//x、y为非volatile变量\n\t//flag为volatile变量\n\t \n\tx = 2;        //语句1\n\ty = 0;        //语句2\n\tflag = true;  //语句3\n\tx = 4;         //语句4\n\ty = -1;       //语句5\n\t\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n4. volatile的原理和实现机制\n\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n下面这段话摘自《深入理解Java虚拟机》：\n\n“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n\n  1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n\n  2. 它会强制将对缓存的修改操作立即写入主存；\n\n  3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n  \n### 五.使用volatile关键字的场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n  * 对变量的写操作不依赖于当前值\n\n  * 该变量没有包含在具有其他变量的不变式中\n\n实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n\n事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n\n下面列举几个Java中使用volatile的几个场景。\n\n1. 状态标记量\n\n\t\tvolatile boolean flag = false;\n\t\t \n\t\twhile(!flag){\n\t\t    doSomething();\n\t\t}\n\t\t \n\t\tpublic void setFlag() {\n\t\t    flag = true;\n\t\t}\n\t\t\n\t\tvolatile boolean inited = false;\n\t\t//线程1:\n\t\tcontext = loadContext();  \n\t\tinited = true;            \n\t\t \n\t\t//线程2:\n\t\twhile(!inited ){\n\t\tsleep()\n\t\t}\n\t\tdoSomethingwithconfig(context);\n\t\t\n2. double check\n\n\t\tclass Singleton{\n\t\t    private volatile static Singleton instance = null;\n\t\t \n\t\t    private Singleton() {\n\t\t \n\t\t    }\n\t\t \n\t\t    public static Singleton getInstance() {\n\t\t        if(instance==null) {\n\t\t            synchronized (Singleton.class) {\n\t\t                if(instance==null)\n\t\t                    instance = new Singleton();\n\t\t            }\n\t\t        }\n\t\t        return instance;\n\t\t    }\n\t\t}\n\t\t\n\t\t\n\t\t\n参考资料：\n\n《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024\n\n和http://www.iteye.com/topic/652440\n\n\n《Java编程思想》\n\n《深入理解Java虚拟机》\n\nhttp://jiangzhengjun.iteye.com/blog/652532\n\nhttp://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\n\nhttp://ifeve.com/volatile/\n\nhttp://blog.csdn.net/ccit0519/article/details/11241403\n\nhttp://blog.csdn.net/ns_code/article/details/17101369\n\nhttp://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\n\nhttp://www.cppblog.com/elva/archive/2011/01/21/139019.html\n\nhttp://ifeve.com/volatile-array-visiblity/\n\nhttp://www.bdqn.cn/news/201312/12579.shtml\n\nhttp://exploer.blog.51cto.com/7123589/1193399\n\nhttp://www.cnblogs.com/Mainz/p/3556430.html","source":"_posts/Java并发编程：volatile关键字解析.md","raw":"---\ntitle: Java并发编程：volatile关键字解析\ndate: 2017-12-08 10:28:29\ntags: [Java]\n---\n\n原文出处：http://www.cnblogs.com/dolphin0520/p/3920373.html\n### 一.内存模型的相关概念\n\n计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：\n\n\ti = i + 1;\n\t\n当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。\n\n这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。\n\n比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？\n\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。\n\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。\n\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。\n\n为了解决缓存不一致性问题，通常来说有以下2种解决方法：\n\n 1. 通过在总线加LOCK#锁的方式\n\n 2. 通过缓存一致性协议\n\n这2种方式都是硬件层面上提供的方式。\n\n在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。\n\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。\n\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n### 二.并发编程中的三个概念\n\n在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：\n\n1. 原子性\n\n原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。\n\n一个很经典的例子就是银行账户转账问题：\n\n比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。\n\n试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。\n\n所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。\n\n同样地反映到并发编程中会出现什么结果呢？\n\n举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？\n\n\ti = 9;\n\t\n假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。\n\n那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。\n\n2. 可见性\n\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n举个简单的例子，看下面这段代码：\n\n\t//线程1执行的代码\n\tint i = 0;\n\ti = 10;\n\t \n\t//线程2执行的代码\n\tj = i;\n\t\n假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。\n\n此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.\n\n这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。\n\n3. 有序性\n\n有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：\n\n\tint i = 0;              \n\tboolean flag = false;\n\ti = 1;                //语句1  \n\tflag = true;          //语句2\n\t\n上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。\n\n下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。\n\n比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。\n\n但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：\n\n\tint a = 10;    //语句1\n\tint r = 2;    //语句2\n\ta = a + 3;    //语句3\n\tr = a*a;     //语句4\n\t\n这段代码有4个语句，那么可能的一个执行顺序是：\n\n语句2  语句1  语句3  语句4\n\n那么可不可能是这个执行顺序呢：\n\n 语句2   语句1    语句4   语句3\n \n 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。\n \n 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：\n \n\t //线程1:\n\tcontext = loadContext();   //语句1\n\tinited = true;             //语句2\n\t \n\t//线程2:\n\twhile(!inited ){\n\t  sleep()\n\t}\n\tdoSomethingwithconfig(context);\n\t\n上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。\n\n从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。\n\n也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。\n\n### 三.Java内存模型\n\n在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。\n\n在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n举个简单的例子：在java中，执行下面这个语句：\n\n\ti  = 10;\n\t\n执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。\n\n那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？\n\n1. 原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n\n上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：\n\n请分析以下哪些操作是原子性操作：\n\n\tx = 10;         //语句1\n\ty = x;         //语句2\n\tx++;           //语句3\n\tx = x + 1;     //语句4\n\t\n咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。\n\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n所以上面4个语句只有语句1的操作具备原子性。\n\n也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\n\n不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。\n\n从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n2. 可见性\n\n对于可见性，Java提供了volatile关键字来保证可见性。\n\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n\n\n* 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n\n\n* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n\n\n* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n\n* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n\n\n* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n\n\n* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n\n\n* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n这8条原则摘自《深入理解Java虚拟机》。\n\n这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。\n\n下面我们来解释一下前4条规则：\n\n对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。\n\n第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。\n\n第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。\n\n第四条规则实际上就是体现happens-before原则具备传递性。\n\n### 四.深入剖析volatile关键字\n\n在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。\n\n1. volatile关键字的两层语义\n\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n\n* 禁止进行指令重排序。\n\n先看一段代码，假如线程1先执行，线程2后执行：\n\n\t//线程1\n\tboolean stop = false;\n\twhile(!stop){\n\t    doSomething();\n\t}\n\t \n\t//线程2\n\tstop = true;\n\t\n这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n\n那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n\n但是用volatile修饰之后就变得不一样了：\n\n* 第一，使用volatile关键字会强制将修改的值立即写入主存；\n\n* 第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n* 第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n\n那么线程1读取到的就是最新的正确的值。\n\n2. volatile保证原子性吗？\n\n从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n\n下面看一个例子：\n\n\tpublic class Test {\n\t    public volatile int inc = 0;\n\t \n\t    public void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n\t\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n采用synchronized：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t \n\t    public synchronized void increase() {\n\t        inc++;\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用Lock：\n\n\tpublic class Test {\n\t    public  int inc = 0;\n\t    Lock lock = new ReentrantLock();\n\t \n\t    public  void increase() {\n\t        lock.lock();\n\t        try {\n\t            inc++;\n\t        } finally{\n\t            lock.unlock();\n\t        }\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n采用AtomicInteger：\n\n\tpublic class Test {\n\t    public  AtomicInteger inc = new AtomicInteger();\n\t \n\t    public  void increase() {\n\t        inc.getAndIncrement();\n\t    }\n\t \n\t    public static void main(String[] args) {\n\t        final Test test = new Test();\n\t        for(int i=0;i<10;i++){\n\t            new Thread(){\n\t                public void run() {\n\t                    for(int j=0;j<1000;j++)\n\t                        test.increase();\n\t                };\n\t            }.start();\n\t        }\n\t \n\t        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n\t            Thread.yield();\n\t        System.out.println(test.inc);\n\t    }\n\t}\n\t\n在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。\n\n3. volatile能保证有序性吗？\n\n在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\nvolatile关键字禁止指令重排序有两层意思：\n\n* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n\n* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n可能上面说的比较绕，举个简单的例子：\n\n\t//x、y为非volatile变量\n\t//flag为volatile变量\n\t \n\tx = 2;        //语句1\n\ty = 0;        //语句2\n\tflag = true;  //语句3\n\tx = 4;         //语句4\n\ty = -1;       //语句5\n\t\n前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n4. volatile的原理和实现机制\n\n前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n下面这段话摘自《深入理解Java虚拟机》：\n\n“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”\n\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n\n  1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n\n  2. 它会强制将对缓存的修改操作立即写入主存；\n\n  3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n  \n### 五.使用volatile关键字的场景\n\nsynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：\n\n  * 对变量的写操作不依赖于当前值\n\n  * 该变量没有包含在具有其他变量的不变式中\n\n实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。\n\n事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。\n\n下面列举几个Java中使用volatile的几个场景。\n\n1. 状态标记量\n\n\t\tvolatile boolean flag = false;\n\t\t \n\t\twhile(!flag){\n\t\t    doSomething();\n\t\t}\n\t\t \n\t\tpublic void setFlag() {\n\t\t    flag = true;\n\t\t}\n\t\t\n\t\tvolatile boolean inited = false;\n\t\t//线程1:\n\t\tcontext = loadContext();  \n\t\tinited = true;            \n\t\t \n\t\t//线程2:\n\t\twhile(!inited ){\n\t\tsleep()\n\t\t}\n\t\tdoSomethingwithconfig(context);\n\t\t\n2. double check\n\n\t\tclass Singleton{\n\t\t    private volatile static Singleton instance = null;\n\t\t \n\t\t    private Singleton() {\n\t\t \n\t\t    }\n\t\t \n\t\t    public static Singleton getInstance() {\n\t\t        if(instance==null) {\n\t\t            synchronized (Singleton.class) {\n\t\t                if(instance==null)\n\t\t                    instance = new Singleton();\n\t\t            }\n\t\t        }\n\t\t        return instance;\n\t\t    }\n\t\t}\n\t\t\n\t\t\n\t\t\n参考资料：\n\n《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024\n\n和http://www.iteye.com/topic/652440\n\n\n《Java编程思想》\n\n《深入理解Java虚拟机》\n\nhttp://jiangzhengjun.iteye.com/blog/652532\n\nhttp://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\n\nhttp://ifeve.com/volatile/\n\nhttp://blog.csdn.net/ccit0519/article/details/11241403\n\nhttp://blog.csdn.net/ns_code/article/details/17101369\n\nhttp://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\n\nhttp://www.cppblog.com/elva/archive/2011/01/21/139019.html\n\nhttp://ifeve.com/volatile-array-visiblity/\n\nhttp://www.bdqn.cn/news/201312/12579.shtml\n\nhttp://exploer.blog.51cto.com/7123589/1193399\n\nhttp://www.cnblogs.com/Mainz/p/3556430.html","slug":"Java并发编程：volatile关键字解析","published":1,"updated":"2017-12-28T05:57:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpha000pv7c04jkxkm0y","content":"<p>原文出处：<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<h3 id=\"一-内存模型的相关概念\"><a href=\"#一-内存模型的相关概念\" class=\"headerlink\" title=\"一.内存模型的相关概念\"></a>一.内存模型的相关概念</h3><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>\n<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>\n<pre><code>i = i + 1;\n</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>\n<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>\n<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>\n<ol>\n<li><p>通过在总线加LOCK#锁的方式</p>\n</li>\n<li><p>通过缓存一致性协议</p>\n</li>\n</ol>\n<p>这2种方式都是硬件层面上提供的方式。</p>\n<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>\n<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>\n<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<h3 id=\"二-并发编程中的三个概念\"><a href=\"#二-并发编程中的三个概念\" class=\"headerlink\" title=\"二.并发编程中的三个概念\"></a>二.并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<pre><code>i = 9;\n</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>举个简单的例子，看下面这段代码：</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n\n//线程2执行的代码\nj = i;\n</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>\n<pre><code>int i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<pre><code>int a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>语句2  语句1  语句3  语句4</p>\n<p>那么可不可能是这个执行顺序呢：</p>\n<p> 语句2   语句1    语句4   语句3</p>\n<p> 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p> 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<pre><code> //线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<h3 id=\"三-Java内存模型\"><a href=\"#三-Java内存模型\" class=\"headerlink\" title=\"三.Java内存模型\"></a>三.Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>\n<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<pre><code>i  = 10;\n</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<pre><code>x = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n</ul>\n<ul>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n</ul>\n<ul>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n</ul>\n<ul>\n<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n</li>\n<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n</li>\n</ul>\n<ul>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n</ul>\n<ul>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n</ul>\n<ul>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<p>这8条原则摘自《深入理解Java虚拟机》。</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<h3 id=\"四-深入剖析volatile关键字\"><a href=\"#四-深入剖析volatile关键字\" class=\"headerlink\" title=\"四.深入剖析volatile关键字\"></a>四.深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>\n<ol>\n<li>volatile关键字的两层语义</li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n</li>\n<li><p>禁止进行指令重排序。</p>\n</li>\n</ul>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<pre><code>//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n\n//线程2\nstop = true;\n</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<ul>\n<li><p>第一，使用volatile关键字会强制将修改的值立即写入主存；</p>\n</li>\n<li><p>第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n</li>\n<li><p>第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</li>\n</ul>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<ol>\n<li>volatile保证原子性吗？</li>\n</ol>\n<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>\n<p>下面看一个例子：</p>\n<pre><code>public class Test {\n    public volatile int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>把上面的代码改成以下任何一种都可以达到效果：</p>\n<p>采用synchronized：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n\n    public synchronized void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用Lock：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n\n    public  void increase() {\n        lock.lock();\n        try {\n            inc++;\n        } finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用AtomicInteger：</p>\n<pre><code>public class Test {\n    public  AtomicInteger inc = new AtomicInteger();\n\n    public  void increase() {\n        inc.getAndIncrement();\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<ol>\n<li>volatile能保证有序性吗？</li>\n</ol>\n<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<ul>\n<li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n</li>\n<li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n</li>\n</ul>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<pre><code>//x、y为非volatile变量\n//flag为volatile变量\n\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<ol>\n<li>volatile的原理和实现机制</li>\n</ol>\n<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>\n<p>下面这段话摘自《深入理解Java虚拟机》：</p>\n<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>\n<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>\n<ol>\n<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>\n</li>\n<li><p>它会强制将对缓存的修改操作立即写入主存；</p>\n</li>\n<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>\n</li>\n</ol>\n<h3 id=\"五-使用volatile关键字的场景\"><a href=\"#五-使用volatile关键字的场景\" class=\"headerlink\" title=\"五.使用volatile关键字的场景\"></a>五.使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<ul>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ul>\n<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>\n<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<ol>\n<li><p>状态标记量</p>\n<pre><code>volatile boolean flag = false;\n\nwhile(!flag){\n    doSomething();\n}\n\npublic void setFlag() {\n    flag = true;\n}\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;            \n\n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n</code></pre></li>\n<li><p>double check</p>\n<pre><code>class Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n</code></pre></li>\n</ol>\n<p>参考资料：</p>\n<p>《Java 中的双重检查（Double-Check）》<a href=\"http://blog.csdn.net/dl88250/article/details/5439024\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dl88250/article/details/5439024</a></p>\n<p>和<a href=\"http://www.iteye.com/topic/652440\" target=\"_blank\" rel=\"external\">http://www.iteye.com/topic/652440</a></p>\n<p>《Java编程思想》</p>\n<p>《深入理解Java虚拟机》</p>\n<p><a href=\"http://jiangzhengjun.iteye.com/blog/652532\" target=\"_blank\" rel=\"external\">http://jiangzhengjun.iteye.com/blog/652532</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>\n<p><a href=\"http://ifeve.com/volatile/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile/</a></p>\n<p><a href=\"http://blog.csdn.net/ccit0519/article/details/11241403\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>\n<p><a href=\"http://blog.csdn.net/ns_code/article/details/17101369\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ns_code/article/details/17101369</a></p>\n<p><a href=\"http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>\n<p><a href=\"http://www.cppblog.com/elva/archive/2011/01/21/139019.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>\n<p><a href=\"http://ifeve.com/volatile-array-visiblity/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile-array-visiblity/</a></p>\n<p><a href=\"http://www.bdqn.cn/news/201312/12579.shtml\" target=\"_blank\" rel=\"external\">http://www.bdqn.cn/news/201312/12579.shtml</a></p>\n<p><a href=\"http://exploer.blog.51cto.com/7123589/1193399\" target=\"_blank\" rel=\"external\">http://exploer.blog.51cto.com/7123589/1193399</a></p>\n<p><a href=\"http://www.cnblogs.com/Mainz/p/3556430.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文出处：<a href=\"http://www.cnblogs.com/dolphin0520/p/3920373.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<h3 id=\"一-内存模型的相关概念\"><a href=\"#一-内存模型的相关概念\" class=\"headerlink\" title=\"一.内存模型的相关概念\"></a>一.内存模型的相关概念</h3><p>计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>\n<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>\n<pre><code>i = i + 1;\n</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>\n<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>\n<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>\n<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>\n<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>\n<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>\n<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>\n<ol>\n<li><p>通过在总线加LOCK#锁的方式</p>\n</li>\n<li><p>通过缓存一致性协议</p>\n</li>\n</ol>\n<p>这2种方式都是硬件层面上提供的方式。</p>\n<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>\n<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>\n<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<h3 id=\"二-并发编程中的三个概念\"><a href=\"#二-并发编程中的三个概念\" class=\"headerlink\" title=\"二.并发编程中的三个概念\"></a>二.并发编程中的三个概念</h3><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>\n<p>一个很经典的例子就是银行账户转账问题：</p>\n<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>\n<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>\n<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>\n<p>同样地反映到并发编程中会出现什么结果呢？</p>\n<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>\n<pre><code>i = 9;\n</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>\n<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>\n<p>举个简单的例子，看下面这段代码：</p>\n<pre><code>//线程1执行的代码\nint i = 0;\ni = 10;\n\n//线程2执行的代码\nj = i;\n</code></pre><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>\n<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>\n<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>\n<pre><code>int i = 0;              \nboolean flag = false;\ni = 1;                //语句1  \nflag = true;          //语句2\n</code></pre><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>\n<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>\n<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>\n<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>\n<pre><code>int a = 10;    //语句1\nint r = 2;    //语句2\na = a + 3;    //语句3\nr = a*a;     //语句4\n</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p>\n<p>语句2  语句1  语句3  语句4</p>\n<p>那么可不可能是这个执行顺序呢：</p>\n<p> 语句2   语句1    语句4   语句3</p>\n<p> 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>\n<p> 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>\n<pre><code> //线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n\n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n</code></pre><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>\n<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>\n<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>\n<h3 id=\"三-Java内存模型\"><a href=\"#三-Java内存模型\" class=\"headerlink\" title=\"三.Java内存模型\"></a>三.Java内存模型</h3><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>\n<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n<p>举个简单的例子：在java中，执行下面这个语句：</p>\n<pre><code>i  = 10;\n</code></pre><p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>\n<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>\n<ol>\n<li>原子性</li>\n</ol>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<pre><code>x = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n</code></pre><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>\n<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>\n<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>\n<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>所以上面4个语句只有语句1的操作具备原子性。</p>\n<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>\n<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<ol>\n<li>可见性</li>\n</ol>\n<p>对于可见性，Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol>\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>\n<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>\n<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n</ul>\n<ul>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n</ul>\n<ul>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n</ul>\n<ul>\n<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>\n</li>\n<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>\n</li>\n</ul>\n<ul>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n</ul>\n<ul>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n</ul>\n<ul>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<p>这8条原则摘自《深入理解Java虚拟机》。</p>\n<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>\n<p>下面我们来解释一下前4条规则：</p>\n<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>\n<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>\n<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>\n<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>\n<h3 id=\"四-深入剖析volatile关键字\"><a href=\"#四-深入剖析volatile关键字\" class=\"headerlink\" title=\"四.深入剖析volatile关键字\"></a>四.深入剖析volatile关键字</h3><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>\n<ol>\n<li>volatile关键字的两层语义</li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>\n</li>\n<li><p>禁止进行指令重排序。</p>\n</li>\n</ul>\n<p>先看一段代码，假如线程1先执行，线程2后执行：</p>\n<pre><code>//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n\n//线程2\nstop = true;\n</code></pre><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>\n<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>\n<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>\n<p>但是用volatile修饰之后就变得不一样了：</p>\n<ul>\n<li><p>第一，使用volatile关键字会强制将修改的值立即写入主存；</p>\n</li>\n<li><p>第二，使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n</li>\n<li><p>第三，由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</li>\n</ul>\n<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>\n<p>那么线程1读取到的就是最新的正确的值。</p>\n<ol>\n<li>volatile保证原子性吗？</li>\n</ol>\n<p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>\n<p>下面看一个例子：</p>\n<pre><code>public class Test {\n    public volatile int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>\n<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>\n<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>\n<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>\n<p>假如某个时刻变量inc的值为10，</p>\n<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>\n<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>\n<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>\n<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>\n<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>\n<p>把上面的代码改成以下任何一种都可以达到效果：</p>\n<p>采用synchronized：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n\n    public synchronized void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用Lock：</p>\n<pre><code>public class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n\n    public  void increase() {\n        lock.lock();\n        try {\n            inc++;\n        } finally{\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>采用AtomicInteger：</p>\n<pre><code>public class Test {\n    public  AtomicInteger inc = new AtomicInteger();\n\n    public  void increase() {\n        inc.getAndIncrement();\n    }\n\n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i&lt;10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j&lt;1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n\n        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n</code></pre><p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>\n<ol>\n<li>volatile能保证有序性吗？</li>\n</ol>\n<p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>\n<p>volatile关键字禁止指令重排序有两层意思：</p>\n<ul>\n<li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>\n</li>\n<li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>\n</li>\n</ul>\n<p>可能上面说的比较绕，举个简单的例子：</p>\n<pre><code>//x、y为非volatile变量\n//flag为volatile变量\n\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n</code></pre><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>\n<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>\n<ol>\n<li>volatile的原理和实现机制</li>\n</ol>\n<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>\n<p>下面这段话摘自《深入理解Java虚拟机》：</p>\n<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>\n<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>\n<ol>\n<li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>\n</li>\n<li><p>它会强制将对缓存的修改操作立即写入主存；</p>\n</li>\n<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>\n</li>\n</ol>\n<h3 id=\"五-使用volatile关键字的场景\"><a href=\"#五-使用volatile关键字的场景\" class=\"headerlink\" title=\"五.使用volatile关键字的场景\"></a>五.使用volatile关键字的场景</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>\n<ul>\n<li><p>对变量的写操作不依赖于当前值</p>\n</li>\n<li><p>该变量没有包含在具有其他变量的不变式中</p>\n</li>\n</ul>\n<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>\n<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>\n<p>下面列举几个Java中使用volatile的几个场景。</p>\n<ol>\n<li><p>状态标记量</p>\n<pre><code>volatile boolean flag = false;\n\nwhile(!flag){\n    doSomething();\n}\n\npublic void setFlag() {\n    flag = true;\n}\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext();  \ninited = true;            \n\n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n</code></pre></li>\n<li><p>double check</p>\n<pre><code>class Singleton{\n    private volatile static Singleton instance = null;\n\n    private Singleton() {\n\n    }\n\n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n</code></pre></li>\n</ol>\n<p>参考资料：</p>\n<p>《Java 中的双重检查（Double-Check）》<a href=\"http://blog.csdn.net/dl88250/article/details/5439024\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/dl88250/article/details/5439024</a></p>\n<p>和<a href=\"http://www.iteye.com/topic/652440\" target=\"_blank\" rel=\"external\">http://www.iteye.com/topic/652440</a></p>\n<p>《Java编程思想》</p>\n<p>《深入理解Java虚拟机》</p>\n<p><a href=\"http://jiangzhengjun.iteye.com/blog/652532\" target=\"_blank\" rel=\"external\">http://jiangzhengjun.iteye.com/blog/652532</a></p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>\n<p><a href=\"http://ifeve.com/volatile/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile/</a></p>\n<p><a href=\"http://blog.csdn.net/ccit0519/article/details/11241403\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>\n<p><a href=\"http://blog.csdn.net/ns_code/article/details/17101369\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ns_code/article/details/17101369</a></p>\n<p><a href=\"http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>\n<p><a href=\"http://www.cppblog.com/elva/archive/2011/01/21/139019.html\" target=\"_blank\" rel=\"external\">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>\n<p><a href=\"http://ifeve.com/volatile-array-visiblity/\" target=\"_blank\" rel=\"external\">http://ifeve.com/volatile-array-visiblity/</a></p>\n<p><a href=\"http://www.bdqn.cn/news/201312/12579.shtml\" target=\"_blank\" rel=\"external\">http://www.bdqn.cn/news/201312/12579.shtml</a></p>\n<p><a href=\"http://exploer.blog.51cto.com/7123589/1193399\" target=\"_blank\" rel=\"external\">http://exploer.blog.51cto.com/7123589/1193399</a></p>\n<p><a href=\"http://www.cnblogs.com/Mainz/p/3556430.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>\n"},{"title":"OkHttp3源码学习（1）-简单实用教程","date":"2017-07-25T02:19:43.000Z","_content":"\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","source":"_posts/OkHttp3源码学习（1）.md","raw":"---\ntitle: OkHttp3源码学习（1）-简单实用教程\ndate: 2017-07-25 10:19:43\ntags: [OkHttp3]\n---\n\n背景简介：\n\n尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。\nOkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。\n\nOkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。\n\n使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。\n\n简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~\n\n\n\n### 一、基本使用\n\n基本步骤：\n\n* 创建OkHttpClient对象\n \n  OkHttpClient client = new OkHttpClient();\n\t\n* 创建网络请求\n\n  Request request = new Request.Builder().url(url).build();\n  \n* 发送请求,得到返回\n\n  Response response = client.newCall(request).excute();(或者异步)\n\t\n\t\n\n\n1. GET请求\n\t* 同步\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString run(String url) throws IOException {\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\t\n\t\t\tResponse response = client.newCall(request).execute();\n\t\t\treturn response.body().string();\n\t}\n\t\t\t\n\t* 异步\n\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(url)\n\t\t\t\t.build();\n\t\t\tclient.newCall(request).enqueue(new CallBack(){\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\t\n2. POST请求\n\t* 同步请求\n\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\tString post(String url, String json) throws IOException {\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  Response response = client.newCall(request).execute();\n\t\t\t  return response.body().string();\n\t\t\t}\n\t\t\t\n\t* 异步请求\n\t\t\t\n\t\t\tpublic static final MediaType JSON\n\t\t\t    = MediaType.parse(\"application/json; charset=utf-8\");\n\t\t\t\n\t\t\tOkHttpClient client = new OkHttpClient();\n\t\t\t\n\t\t\t  RequestBody body = RequestBody.create(JSON, json);\n\t\t\t  Request request = new Request.Builder()\n\t\t\t      .url(url)\n\t\t\t      .post(body)\n\t\t\t      .build();\n\t\t\t  client.newCall(request).enqueue(new CallBack(){\n\t\t\t  \t\t@Override\n\t\t\t\t\tpublic void onFailure(Request request,IOException e){\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onResponse(Response response){\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t  \n\t\t\t  \n\t\t\t  \n#### 二、架构总览\n借用网上的图···（侵权必删）\n![“okhttp3整体架构”](http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png)\n\n\n#### 三、OkHttp的优点\n\n网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···\n\n* 支持HTTP2/SPDY黑科技\n* socket自动选择最好路线，并支持自动重连\n* 拥有自动维护的socket连接池，减少握手次数\n* 拥有队列线程池，轻松写并发\n* 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）\n* 实现基于Headers的缓存策略\n\n\n#### 四、小结\n\n首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···\n\n\n\n\t\t\n\t   \n\t   ","slug":"OkHttp3源码学习（1）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphc000qv7c0nw9ceot1","content":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n","site":{"data":{}},"excerpt":"","more":"<p>背景简介：</p>\n<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>\n<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>\n<p>使用 OkHttp 无需重写程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>\n<p>简单来说，其他的太难用了，这个才是最好用的，不用你会后悔的~</p>\n<h3 id=\"一、基本使用\"><a href=\"#一、基本使用\" class=\"headerlink\" title=\"一、基本使用\"></a>一、基本使用</h3><p>基本步骤：</p>\n<ul>\n<li><p>创建OkHttpClient对象</p>\n<p>OkHttpClient client = new OkHttpClient();</p>\n</li>\n<li><p>创建网络请求</p>\n<p>Request request = new Request.Builder().url(url).build();</p>\n</li>\n<li><p>发送请求,得到返回</p>\n<p>Response response = client.newCall(request).excute();(或者异步)</p>\n</li>\n</ul>\n<ol>\n<li><p>GET请求</p>\n<ul>\n<li><p>同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\n\nResponse response = client.newCall(request).execute();\nreturn response.body().string();\n</code></pre><p>}</p>\n</li>\n<li><p>异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\nRequest request = new Request.Builder()\n    .url(url)\n    .build();\nclient.newCall(request).enqueue(new CallBack(){\n    @Override\n    public void onFailure(Request request,IOException e){\n    }\n    @Override\n    public void onResponse(Response response){\n    }\n})\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>POST请求</p>\n<ul>\n<li><p>同步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>异步请求</p>\n<pre><code>public static final MediaType JSON\n    = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\n  RequestBody body = RequestBody.create(JSON, json);\n  Request request = new Request.Builder()\n      .url(url)\n      .post(body)\n      .build();\n  client.newCall(request).enqueue(new CallBack(){\n          @Override\n        public void onFailure(Request request,IOException e){\n        }\n        @Override\n        public void onResponse(Response response){\n        }\n  })\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"二、架构总览\"><a href=\"#二、架构总览\" class=\"headerlink\" title=\"二、架构总览\"></a>二、架构总览</h4><p>借用网上的图···（侵权必删）<br><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3all.png\" alt=\"“okhttp3整体架构”\"></p>\n<h4 id=\"三、OkHttp的优点\"><a href=\"#三、OkHttp的优点\" class=\"headerlink\" title=\"三、OkHttp的优点\"></a>三、OkHttp的优点</h4><p>网上的各路大神已经总结过很多遍了，我再来一遍，加深记忆···</p>\n<ul>\n<li>支持HTTP2/SPDY黑科技</li>\n<li>socket自动选择最好路线，并支持自动重连</li>\n<li>拥有自动维护的socket连接池，减少握手次数</li>\n<li>拥有队列线程池，轻松写并发</li>\n<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩,LOGGING）</li>\n<li>实现基于Headers的缓存策略</li>\n</ul>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>首先对OkHttp有一个整体的认识，了解基本用法。熟悉整体框架结构。下篇开始进行源码的解读···</p>\n"},{"title":"OkHttp3源码学习（2）-发起请求源码实现","date":"2017-07-26T07:25:37.000Z","_content":"\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","source":"_posts/OkHttp3源码学习（2）.md","raw":"---\ntitle: OkHttp3源码学习（2）-发起请求源码实现\ndate: 2017-07-26 15:25:37\ntags: [OkHttp3]\n---\n\n#### 上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\n\n![“整体流程“](http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png)\n\n那么，从这一节开始，进行源码分析解读···\n\n\n#### 一、创建OkHttpClient对象\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n创建时，做了什么事情？\n\n直接进OkHttpClient.java \n\n如果我们不做任何配置，那么就采用默认的配置，已经写好。\n\n\tpublic OkHttpClient() {\n\t    this(new Builder());\n\t  }\n\t  \n\tpublic Builder() {\n      dispatcher = new Dispatcher();\n      protocols = DEFAULT_PROTOCOLS;\n      connectionSpecs = DEFAULT_CONNECTION_SPECS;\n      eventListenerFactory = EventListener.factory(EventListener.NONE);\n      proxySelector = ProxySelector.getDefault();\n      cookieJar = CookieJar.NO_COOKIES;\n      socketFactory = SocketFactory.getDefault();\n      hostnameVerifier = OkHostnameVerifier.INSTANCE;\n      certificatePinner = CertificatePinner.DEFAULT;\n      proxyAuthenticator = Authenticator.NONE;\n      authenticator = Authenticator.NONE;\n      connectionPool = new ConnectionPool();\n      dns = Dns.SYSTEM;\n      followSslRedirects = true;\n      followRedirects = true;\n      retryOnConnectionFailure = true;\n      connectTimeout = 10_000;\n      readTimeout = 10_000;\n      writeTimeout = 10_000;\n      pingInterval = 0;\n    }\n    \n    \n  当然，如果自己想设置一些参数:\n  \n\t  OkHttpClient client = new OkHttpClient.Builder()  \n\t        .connectTimeout(10, TimeUnit.SECONDS)\n\t        .addInterceptor(...)\n\t        ....\n\t        .build();\n\t        \n 个性化配置包你满意。\n \n \n#### 二、创建网络请求\n\n\n\tRequest request = new Request.Builder()  \n        .addHeader(\"Connection\", \"Keep-Alive\")\n        .url(\"http://www.google.com\")\n        ....\n        .build();\n        \n  这里默认发送的请求是GET：\n  \n\t   public Builder() {\n\t      this.method = \"GET\";\n\t      this.headers = new Headers.Builder();\n\t    }\n\t    \n\n发送POST请求，上一章节已经说明了请求方法，源码中实现：\n\n\t  public Builder post(RequestBody body) {\n      return method(\"POST\", body);\n    }\n    \n    \n#### 三、拿到Call对象\n\n\tCall call = client.newCall(request);\n\t\nCall即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。\n\n\t/**\n\t * A call is a request that has been prepared for execution. A call can be canceled. As this object\n\t * represents a single request/response pair (stream), it cannot be executed twice.\n\t */\n\tpublic interface Call extends Cloneable {\n\t\t···\n\t}\n\t\n一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。\n        \n\t  /**\n\t   * Prepares the {@code request} to be executed at some point in the future.\n\t   */\n\t  @Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  }\n\t  \n实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。\n\n\n* 发起一个同步请求\n\n\t\t\n\t\t  @Override public Response execute() throws IOException {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    try {\n\t\t      client.dispatcher().executed(this);\n\t\t      Response result = getResponseWithInterceptorChain();\n\t\t      if (result == null) throw new IOException(\"Canceled\");\n\t\t      return result;\n\t\t    } finally {\n\t\t      client.dispatcher().finished(this);\n\t\t    }\n\t\t  }\n\t\t  \n\t\t  \n\t\t  \n\t\t   /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t\t  synchronized void executed(RealCall call) {\n\t\t\t    runningSyncCalls.add(call);\n\t\t\t  }\n\t\t\t  \n\t* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n\t* 调用getResponseWithInterceptorChain获取服务器返回\n\t* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n\t\t  \n* 发起异步请求\n\n\n\t\t  @Override public void enqueue(Callback responseCallback) {\n\t\t    synchronized (this) {\n\t\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t\t      executed = true;\n\t\t    }\n\t\t    captureCallStackTrace();\n\t\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t\t  }\n\t\t  \n\t\t  \n\t  \n\t\tsynchronized void enqueue(AsyncCall call) {\n\t\tif (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t  runningAsyncCalls.add(call);\n\t\t  executorService().execute(call);\n\t\t} else {\n\t\t  readyAsyncCalls.add(call);\n\t\t}\n\t\t}\n    \n    \n    AsyncCall.java\n    \n\t    final class AsyncCall extends NamedRunnable {\n\t    private final Callback responseCallback;\n\t\n\t    AsyncCall(Callback responseCallback) {\n\t      super(\"OkHttp %s\", redactedUrl());\n\t      this.responseCallback = responseCallback;\n\t    }\n\t\n\t    String host() {\n\t      return originalRequest.url().host();\n\t    }\n\t\n\t    Request request() {\n\t      return originalRequest;\n\t    }\n\t\n\t    RealCall get() {\n\t      return RealCall.this;\n\t    }\n\t\n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t  \t}\n\t  \t\n\t  \t\n\t RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n\t \n\n#### 四、构建拦截器链\n\n还是在RealCall.java中，看源码是如何构建的。\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\t  \n\t  \n\t  \n* 创建一系列拦截器，并存放在拦截器数组中。\n* 然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)\n* 经过一系列拦截器的处理后，获取Response.\n\n\n#### 五、小结\n\n本节主要对请求的整个流程进行相对应的源码实现过程解析。\n\n下节对几种拦截器进行解析。\n\n\n\n\n\t  \n\t  \n\n","slug":"OkHttp3源码学习（2）","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphd000sv7c0kc2ynrtb","content":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"><a href=\"#上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\" class=\"headerlink\" title=\"上一节对OkHttp3做了一个简单的介绍及科普了一下使用。\"></a>上一节对OkHttp3做了一个简单的介绍及科普了一下使用。</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/okhttp3second.png\" alt=\"“整体流程“\"></p>\n<p>那么，从这一节开始，进行源码分析解读···</p>\n<h4 id=\"一、创建OkHttpClient对象\"><a href=\"#一、创建OkHttpClient对象\" class=\"headerlink\" title=\"一、创建OkHttpClient对象\"></a>一、创建OkHttpClient对象</h4><pre><code>OkHttpClient client = new OkHttpClient();\n</code></pre><p>创建时，做了什么事情？</p>\n<p>直接进OkHttpClient.java </p>\n<p>如果我们不做任何配置，那么就采用默认的配置，已经写好。</p>\n<pre><code>public OkHttpClient() {\n    this(new Builder());\n  }\n\npublic Builder() {\n  dispatcher = new Dispatcher();\n  protocols = DEFAULT_PROTOCOLS;\n  connectionSpecs = DEFAULT_CONNECTION_SPECS;\n  eventListenerFactory = EventListener.factory(EventListener.NONE);\n  proxySelector = ProxySelector.getDefault();\n  cookieJar = CookieJar.NO_COOKIES;\n  socketFactory = SocketFactory.getDefault();\n  hostnameVerifier = OkHostnameVerifier.INSTANCE;\n  certificatePinner = CertificatePinner.DEFAULT;\n  proxyAuthenticator = Authenticator.NONE;\n  authenticator = Authenticator.NONE;\n  connectionPool = new ConnectionPool();\n  dns = Dns.SYSTEM;\n  followSslRedirects = true;\n  followRedirects = true;\n  retryOnConnectionFailure = true;\n  connectTimeout = 10_000;\n  readTimeout = 10_000;\n  writeTimeout = 10_000;\n  pingInterval = 0;\n}\n</code></pre><p>  当然，如果自己想设置一些参数:</p>\n<pre><code>OkHttpClient client = new OkHttpClient.Builder()  \n      .connectTimeout(10, TimeUnit.SECONDS)\n      .addInterceptor(...)\n      ....\n      .build();\n</code></pre><p> 个性化配置包你满意。</p>\n<h4 id=\"二、创建网络请求\"><a href=\"#二、创建网络请求\" class=\"headerlink\" title=\"二、创建网络请求\"></a>二、创建网络请求</h4><pre><code>Request request = new Request.Builder()  \n    .addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)\n    .url(&quot;http://www.google.com&quot;)\n    ....\n    .build();\n</code></pre><p>  这里默认发送的请求是GET：</p>\n<pre><code>public Builder() {\n   this.method = &quot;GET&quot;;\n   this.headers = new Headers.Builder();\n }\n</code></pre><p>发送POST请求，上一章节已经说明了请求方法，源码中实现：</p>\n<pre><code>  public Builder post(RequestBody body) {\n  return method(&quot;POST&quot;, body);\n}\n</code></pre><h4 id=\"三、拿到Call对象\"><a href=\"#三、拿到Call对象\" class=\"headerlink\" title=\"三、拿到Call对象\"></a>三、拿到Call对象</h4><pre><code>Call call = client.newCall(request);\n</code></pre><p>Call即是一个实际的访问请求，用户的每一个网络请求都是一个Call实例。</p>\n<pre><code>/**\n * A call is a request that has been prepared for execution. A call can be canceled. As this object\n * represents a single request/response pair (stream), it cannot be executed twice.\n */\npublic interface Call extends Cloneable {\n    ···\n}\n</code></pre><p>一个call就是一次已准备好的请求执行，并且可以被取消。这个请求对象是单个，所以不能执行两次。</p>\n<pre><code>/**\n * Prepares the {@code request} to be executed at some point in the future.\n */\n@Override public Call newCall(Request request) {\n  return new RealCall(this, request, false /* for web socket */);\n}\n</code></pre><p>实际在执行过程中，OkHttp会为每个请求创建一个RealCall.那么再进RealCall看看。</p>\n<ul>\n<li>发起一个同步请求</li>\n</ul>\n<pre><code>      @Override public Response execute() throws IOException {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        try {\n          client.dispatcher().executed(this);\n          Response result = getResponseWithInterceptorChain();\n          if (result == null) throw new IOException(&quot;Canceled&quot;);\n          return result;\n        } finally {\n          client.dispatcher().finished(this);\n        }\n      }\n\n\n\n       /** Used by {@code Call#execute} to signal it is in-flight. */\n          synchronized void executed(RealCall call) {\n            runningSyncCalls.add(call);\n          }\n\n* 发起同步请求，通过dispatcher.executed()添加到同步队列中执行\n* 调用getResponseWithInterceptorChain获取服务器返回\n* 最后通知任务分发器client.dispatcher().finished(this)任务结束\n</code></pre><ul>\n<li>发起异步请求</li>\n</ul>\n<pre><code>      @Override public void enqueue(Callback responseCallback) {\n        synchronized (this) {\n          if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n          executed = true;\n        }\n        captureCallStackTrace();\n        client.dispatcher().enqueue(new AsyncCall(responseCallback));\n      }\n\n\n\n    synchronized void enqueue(AsyncCall call) {\n    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    } else {\n      readyAsyncCalls.add(call);\n    }\n    }\n\n\nAsyncCall.java\n\n    final class AsyncCall extends NamedRunnable {\n    private final Callback responseCallback;\n\n    AsyncCall(Callback responseCallback) {\n      super(&quot;OkHttp %s&quot;, redactedUrl());\n      this.responseCallback = responseCallback;\n    }\n\n    String host() {\n      return originalRequest.url().host();\n    }\n\n    Request request() {\n      return originalRequest;\n    }\n\n    RealCall get() {\n      return RealCall.this;\n    }\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n      }\n\n\n RealCall被转化成一个AsyncCall并被放入到任务队列中,AsyncCall的excute方法最终将会被执行.execute方法的逻辑并不复杂,和之前一样。\n</code></pre><h4 id=\"四、构建拦截器链\"><a href=\"#四、构建拦截器链\" class=\"headerlink\" title=\"四、构建拦截器链\"></a>四、构建拦截器链</h4><p>还是在RealCall.java中，看源码是如何构建的。</p>\n<pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><ul>\n<li>创建一系列拦截器，并存放在拦截器数组中。</li>\n<li>然后创建一个拦截器链RealInterceptorChain，执行拦截器链的方法chain.proceed(originalRequest)</li>\n<li>经过一系列拦截器的处理后，获取Response.</li>\n</ul>\n<h4 id=\"五、小结\"><a href=\"#五、小结\" class=\"headerlink\" title=\"五、小结\"></a>五、小结</h4><p>本节主要对请求的整个流程进行相对应的源码实现过程解析。</p>\n<p>下节对几种拦截器进行解析。</p>\n"},{"title":"OkHttp3源码学习（3）-拦截器链详解","date":"2017-07-27T09:02:28.000Z","_content":"#### 一、发起请求\n\n\tOkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"\")\n                .build();\n        Call call = client.newCall(request);\n        try {\n            call.enqueue(new okhttp3.Callback() {\n                @Override\n                public void onFailure(Call call, IOException e) {\n                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n                }\n\n                @Override\n                public void onResponse(Call call, Response response) throws IOException {\n                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n                }\n            });\n        } catch (Exception e) {\n            Log.e(\"OkHttp\",e.getMessage());\n        }\n        \n* 发起请求时：client.newCall(request)。\n\n\t\t@Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  \t}\n  \n  实际上就是创建一个RealCall的实例。\n  \n*  然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。\n\n\t\t@Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\n#### 二、AsyncCall\n\n\t @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  \n  \n  AsyncCall会执行execute方法。execute方法逻辑很简单：\n  \n\n* 通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功\n\n\t\tResponse response = getResponseWithInterceptorChain();\n  \n\n* 通知任务分发器该任务结束\n\n  \t\tclient.dispatcher().finished(this);\n\n\n        \n#### 三、构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n从源码来看，基本逻辑就是：\n\n* 创建一系列拦截器，加到拦截器数组中。\n* 创建拦截器链RealInterceptorChain\n* 执行拦截器链中的proceed方法\n\n\n\n#### 四、RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n\n* 创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。\n\n\t\t// Call the next interceptor in the chain.\n\t\tRealInterceptorChain next = new RealInterceptorChain(\n\t\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n        \n* 获取索引为index的interceptor,执行索引为index的intercept方法。\n\t\n\t\tInterceptor interceptor = interceptors.get(index);\n    \tResponse response = interceptor.intercept(next);\n\n\n#### 五、拦截器链\n\n##### 1.RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n\t请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n\t毁掉,再新建一个StreamAllocation连接,进行重试。\n      if (!sameConnection(response, followUp.url(s))) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.\n\n\n\n\n\n下面就来对几种拦截器一一介绍。\n\n##### 2.BidgeInterceptor\n\n官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.\n\n整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。\n\n下面就看一下核心方法intercept()\n\n\t@Override public Response intercept(Chain chain) throws IOException {\n\t//拿到用户的请求\n    Request userRequest = chain.request();\n    Request.Builder requestBuilder = userRequest.newBuilder();\n\t//拿到用户请求body\n    RequestBody body = userRequest.body();\n    //对请求头的补充\n    if (body != null) {\n      MediaType contentType = body.contentType();\n      if (contentType != null) {\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n      }\n\n      long contentLength = body.contentLength();\n      if (contentLength != -1) {\n        requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n        requestBuilder.removeHeader(\"Transfer-Encoding\");\n      } else {\n        requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n        requestBuilder.removeHeader(\"Content-Length\");\n      }\n    }\n\n    if (userRequest.header(\"Host\") == null) {\n      requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false));\n    }\n\t//默认是保持连接的（Keep-Alive）\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n\t//默认GZIP压缩\n\t//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n    // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing\n    // the transfer stream.\n    boolean transparentGzip = false;\n    if (userRequest.header(\"Accept-Encoding\") == null && userRequest.header(\"Range\") == null) {\n      transparentGzip = true;\n      requestBuilder.header(\"Accept-Encoding\", \"gzip\");\n    }\n\t//添加cookie头\n    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());\n    if (!cookies.isEmpty()) {\n      requestBuilder.header(\"Cookie\", cookieHeader(cookies));\n    }\n\n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n\t//继续执行下一个拦截器的方法\n    Response networkResponse = chain.proceed(requestBuilder.build());\n\t//接收服务器返回的cookie\n    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\n    Response.Builder responseBuilder = networkResponse.newBuilder()\n        .request(userRequest);\n\n    if (transparentGzip\n        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n        && HttpHeaders.hasBody(networkResponse)) {\n      //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n      Headers strippedHeaders = networkResponse.headers().newBuilder()\n          .removeAll(\"Content-Encoding\")\n          .removeAll(\"Content-Length\")\n          .build();\n      responseBuilder.headers(strippedHeaders);\n      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n    }\n\t//构建一个Response\n    return responseBuilder.build();\n  \t}\n\n\nBridgeInterceptor主要流程逻辑：\n\n1. 拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求\n2. 将这个符合网络请求的Request进行网络请求\n3. 将网络请求返回的Response转化为用户可用的Response\n\t\n\t\n代码中构建网络Request添加的请求头信息：\n\n* 简单了解一下先，头信息\n\n协议头字段名 |说明| 示例 | 状态\n---- | --- | --- | ---\nContent-Type | 请求体的 多媒体类型 （用于POST和PUT请求中）|Content-Type: application/x-www-form-urlencoded|常设\nContent-Length |  以 八位字节数组 （8位的字节）表示的请求体的长度|Content-Length: 348|常设\nTransfer-Encoding|用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity|Transfer-Encoding: chunked|常设\nHost|服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。| Host: en.wikipedia.org:80 Host: en.wikipedia.org|常设\nConnection|该浏览器想要优先使用的连接类型|Connection: keep-alive  \t，Connection: Upgrade|常设\nAccept-Encoding|能够接受的编码方式列表|Accept-Encoding: gzip, deflate|常设\nCookie|之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109|Cookie: $Version=1; Skin=new;|常设: 标准\n\n###### 小结：\n\n* 构建完头信息后，进行网络请求\n\n\t\tResponse networkResponse = chain.proceed(requestBuilder.build());\n\t\t\n* 获取到返回的Response,转化为客户端可用的Response\n\t\n\t\t Response.Builder responseBuilder = networkResponse.newBuilder()\n\t        .request(userRequest);\n\t\n\t    if (transparentGzip\n\t        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n\t        && HttpHeaders.hasBody(networkResponse)) {\n\t      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n\t      Headers strippedHeaders = networkResponse.headers().newBuilder()\n\t          .removeAll(\"Content-Encoding\")\n\t          .removeAll(\"Content-Length\")\n\t          .build();\n\t      responseBuilder.headers(strippedHeaders);\n\t      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n\n\t\n\t\n\n##### 3.CacheIntetceptor\n\nCacheIntetceptor的职责就是负责Cache的管理\n\n看一下核心方法：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t //1.读取候选的缓存\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n\t//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //4.不需要访问网络的情况下，取本地缓存作为结果返回。\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n    //5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    //6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\t\t//8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n\t//9.读取网络请求\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\t//10.对数据进行缓存\n    if (cache != null) {\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        CacheRequest cacheRequest = cache.put(response);\n        return cacheWritingResponse(cacheRequest, response);\n      }\n\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\t//11.返回网络请求的结果\n    return response;\n  \t}\n\t\n\t\n####### 整个过程大致：\n\nCacheInterceptor主要就是负责Cache的管理\n\n   * 当网络被禁止访问，缓存不完整，那么返回失败（504）\n   * 缓存可用，返回缓存结果\n   * 当网络访问，返回（304），更新本地缓存\n   * 当Cache失效，删除缓存\n\n  \n##### 4.ConnectInterceptor\n\n代码不多，但包含的内容很多。\n\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    Request request = realChain.request();\n\t    //拿到StreamAllocation对象。\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t\n\t    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n\t    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n\t    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n\t    RealConnection connection = streamAllocation.connection();\n\t\n\t    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n\t  \t}\n\t\n\t\n从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化\n\n\t    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n        \n三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用\n\n看一下StreamAllocation的构造方法\n\n\tpublic StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\n    this.connectionPool = connectionPool;\n    this.address = address;\n    this.routeSelector = new RouteSelector(address, routeDatabase());\n    this.callStackTrace = callStackTrace;\n  \t}\n在把这个三个参数保存为内部变量的同时也创建了一个线路选择器\n\nstreamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。\n\n接下来继续看StreamAllocation中的newSream()方法\n\n\tpublic HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n\t//读取从OkHttpClient配置的超时时间\n    int connectTimeout = client.connectTimeoutMillis();\n    //获取读写超时时间\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    //连接重试\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n    //找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  \t}\n  \t\n 下面就再看一下它是如何找到一个健康的连接的\n\t\t\n\t  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n\t      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n\t      throws IOException {\n\t    while (true) {\n\t    //找到健康的连接\n\t      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n\t          connectionRetryEnabled);\n\t\n\t      // If this is a brand new connection, we can skip the extensive health checks.\n\t      synchronized (connectionPool) {\n\t        if (candidate.successCount == 0) {\n\t          return candidate;\n\t        }\n\t      }\n\t\n\t      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n\t      // isn't, take it out of the pool and start again.\n\t      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n\t        noNewStreams();\n\t        continue;\n\t      }\n\t\n\t      return candidate;\n\t    }\n\t  }\n\t  \n从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。\n\n那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法\n\t          \n\t          \n\tprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n\t      boolean connectionRetryEnabled) throws IOException {\n\t    Route selectedRoute;\n\t    //同步线程池\n\t    synchronized (connectionPool) {\n\t      if (released) throw new IllegalStateException(\"released\");\n\t      if (codec != null) throw new IllegalStateException(\"codec != null\");\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t\t\t//尝试使用现有连接，判断是否可用\n\t      // Attempt to use an already-allocated connection.\n\t      RealConnection allocatedConnection = this.connection;\n\t      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {\n\t        return allocatedConnection;\n\t      }\n\t\t\t//尝试在连接池中获取一个连接，\n\t      // Attempt to get a connection from the pool.\n\t      Internal.instance.get(connectionPool, address, this, null);\n\t      if (connection != null) {\n\t        return connection;\n\t      }\n\t\n\t      selectedRoute = route;\n\t    }\n\t\n\t    // If we need a route, make one. This is a blocking operation.\n\t    if (selectedRoute == null) {\n\t      selectedRoute = routeSelector.next();\n\t    }\n\t\n\t    RealConnection result;\n\t    synchronized (connectionPool) {\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n\t      // This could match due to connection coalescing.\n\t      Internal.instance.get(connectionPool, address, this, selectedRoute);\n\t      if (connection != null) {\n\t        route = selectedRoute;\n\t        return connection;\n\t      }\n\t\n\t      // Create a connection and assign it to this allocation immediately. This makes it possible\n\t      // for an asynchronous cancel() to interrupt the handshake we're about to do.\n\t      route = selectedRoute;\n\t      refusedStreamCount = 0;\n\t      result = new RealConnection(connectionPool, selectedRoute);\n\t      acquire(result);\n\t    }\n\t\n\t    // Do TCP + TLS handshakes. This is a blocking operation.\n\t    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n\t    routeDatabase().connected(result.route());\n\t\n\t    Socket socket = null;\n\t    synchronized (connectionPool) {\n\t      // Pool the connection.\n\t      Internal.instance.put(connectionPool, result);\n\t\n\t      // If another multiplexed connection to the same address was created concurrently, then\n\t      // release this connection and acquire that one.\n\t      if (result.isMultiplexed()) {\n\t        socket = Internal.instance.deduplicate(connectionPool, address, this);\n\t        result = connection;\n\t      }\n\t    }\n\t    closeQuietly(socket);\n\t\n\t    return result;\n\t  }\n\n这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。\n\n那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。\n\n##### 5.CallServerInterceptor\n\n整个拦截器链中的最后一个拦截器，看一下源码。\n\n关键方法intercept,如下：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    HttpCodec httpCodec = realChain.httpStream();\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t    RealConnection connection = (RealConnection) realChain.connection();\n\t    Request request = realChain.request();\n\t\t\n\t    long sentRequestMillis = System.currentTimeMillis();\n\t\t //1.首先写请求头\n\t    realChain.eventListener().requestHeadersStart(realChain.call());\n\t    httpCodec.writeRequestHeaders(request);\n\t    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\t\n\t    Response.Builder responseBuilder = null;\n\t    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n\t      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n\t      // Continue\" response before transmitting the request body. If we don't get that, return\n\t      // what we did get (such as a 4xx response) without ever transmitting the request body.\n\t      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n\t        httpCodec.flushRequest();\n\t        realChain.eventListener().responseHeadersStart(realChain.call());\n\t        responseBuilder = httpCodec.readResponseHeaders(true);\n\t      }\n\t\t   //2.然后写请求体\n\t      if (responseBuilder == null) {\n\t        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n\t        realChain.eventListener().requestBodyStart(realChain.call());\n\t        long contentLength = request.body().contentLength();\n\t        CountingSink requestBodyOut =\n\t            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n\t        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\t\n\t        request.body().writeTo(bufferedRequestBody);\n\t        bufferedRequestBody.close();\n\t        realChain.eventListener()\n\t            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n\t      } else if (!connection.isMultiplexed()) {\n\t        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n\t        // from being reused. Otherwise we're still obligated to transmit the request body to\n\t        // leave the connection in a consistent state.\n\t        streamAllocation.noNewStreams();\n\t      }\n\t    }\n\t\n\t    httpCodec.finishRequest();\n\t\t //读取响应头\n\t    if (responseBuilder == null) {\n\t      realChain.eventListener().responseHeadersStart(realChain.call());\n\t      responseBuilder = httpCodec.readResponseHeaders(false);\n\t    }\n\t\n\t    Response response = responseBuilder\n\t        .request(request)\n\t        .handshake(streamAllocation.connection().handshake())\n\t        .sentRequestAtMillis(sentRequestMillis)\n\t        .receivedResponseAtMillis(System.currentTimeMillis())\n\t        .build();\n\t\n\t    realChain.eventListener()\n\t        .responseHeadersEnd(realChain.call(), response);\n\t    //判断响应码，读取响应体\n\t    int code = response.code();\n\t    if (forWebSocket && code == 101) {\n\t      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n\t      response = response.newBuilder()\n\t          .body(Util.EMPTY_RESPONSE)\n\t          .build();\n\t    } else {\n\t      response = response.newBuilder()\n\t          .body(httpCodec.openResponseBody(response))\n\t          .build();\n\t    }\n\t\n\t    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n\t        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n\t      streamAllocation.noNewStreams();\n\t    }\n\t\n\t    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n\t      throw new ProtocolException(\n\t          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n\t    }\n\t\n\t    return response;\n\t  }\n\n真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。\n\n\n##### 最后\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n","source":"_posts/OkHttp3源码学习（3）.md","raw":"---\ntitle: OkHttp3源码学习（3）-拦截器链详解\ndate: 2017-07-27 17:02:28\ntags: [OkHttp3]\n---\n#### 一、发起请求\n\n\tOkHttpClient client = new OkHttpClient();\n        Request request = new Request.Builder()\n                .url(\"\")\n                .build();\n        Call call = client.newCall(request);\n        try {\n            call.enqueue(new okhttp3.Callback() {\n                @Override\n                public void onFailure(Call call, IOException e) {\n                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n                }\n\n                @Override\n                public void onResponse(Call call, Response response) throws IOException {\n                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n                }\n            });\n        } catch (Exception e) {\n            Log.e(\"OkHttp\",e.getMessage());\n        }\n        \n* 发起请求时：client.newCall(request)。\n\n\t\t@Override public Call newCall(Request request) {\n\t    return new RealCall(this, request, false /* for web socket */);\n\t  \t}\n  \n  实际上就是创建一个RealCall的实例。\n  \n*  然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。\n\n\t\t@Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\n#### 二、AsyncCall\n\n\t @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n  \n  \n  AsyncCall会执行execute方法。execute方法逻辑很简单：\n  \n\n* 通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功\n\n\t\tResponse response = getResponseWithInterceptorChain();\n  \n\n* 通知任务分发器该任务结束\n\n  \t\tclient.dispatcher().finished(this);\n\n\n        \n#### 三、构建拦截器链\n\n\t Response getResponseWithInterceptorChain() throws IOException {\n\t    // Build a full stack of interceptors.\n\t    List<Interceptor> interceptors = new ArrayList<>();\n\t    interceptors.addAll(client.interceptors());\n\t    interceptors.add(retryAndFollowUpInterceptor);\n\t    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n\t    interceptors.add(new CacheInterceptor(client.internalCache()));\n\t    interceptors.add(new ConnectInterceptor(client));\n\t    if (!forWebSocket) {\n\t      interceptors.addAll(client.networkInterceptors());\n\t    }\n\t    interceptors.add(new CallServerInterceptor(forWebSocket));\n\t\n\t    Interceptor.Chain chain = new RealInterceptorChain(\n\t        interceptors, null, null, null, 0, originalRequest);\n\t    return chain.proceed(originalRequest);\n\t  }\n\n\n从源码来看，基本逻辑就是：\n\n* 创建一系列拦截器，加到拦截器数组中。\n* 创建拦截器链RealInterceptorChain\n* 执行拦截器链中的proceed方法\n\n\n\n#### 四、RealInterceptorChain\n\n\t/**\n\t * A concrete interceptor chain that carries the entire interceptor chain: all application\n\t * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n\t */\n\tpublic final class RealInterceptorChain implements Interceptor.Chain {\n\t  private final List<Interceptor> interceptors;\n\t  private final StreamAllocation streamAllocation;\n\t  private final HttpCodec httpCodec;\n\t  private final RealConnection connection;\n\t  private final int index;\n\t  private final Request request;\n\t  private int calls;\n\t\n\t  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,\n\t      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n\t    this.interceptors = interceptors;\n\t    this.connection = connection;\n\t    this.streamAllocation = streamAllocation;\n\t    this.httpCodec = httpCodec;\n\t    this.index = index;\n\t    this.request = request;\n\t  }\n\t\n\t  @Override public Connection connection() {\n\t    return connection;\n\t  }\n\t\n\t  public StreamAllocation streamAllocation() {\n\t    return streamAllocation;\n\t  }\n\t\n\t  public HttpCodec httpStream() {\n\t    return httpCodec;\n\t  }\n\t\n\t  @Override public Request request() {\n\t    return request;\n\t  }\n\t\n\t  @Override public Response proceed(Request request) throws IOException {\n\t    return proceed(request, streamAllocation, httpCodec, connection);\n\t  }\n\t\n\t  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n\t      RealConnection connection) throws IOException {\n\t    if (index >= interceptors.size()) throw new AssertionError();\n\t\n\t    calls++;\n\t\n\t    // If we already have a stream, confirm that the incoming request will use it.\n\t    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must retain the same host and port\");\n\t    }\n\t\n\t    // If we already have a stream, confirm that this is the only call to chain.proceed().\n\t    if (this.httpCodec != null && calls > 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1)\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    \n\n\t    Interceptor interceptor = interceptors.get(index);\n\t    Response response = interceptor.intercept(next);\n\t\n\t    // Confirm that the next interceptor made its required call to chain.proceed().\n\t    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n\t      throw new IllegalStateException(\"network interceptor \" + interceptor\n\t          + \" must call proceed() exactly once\");\n\t    }\n\t\n\t    // Confirm that the intercepted response isn't null.\n\t    if (response == null) {\n\t      throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n\t    }\n\t\n\t    return response;\n\t  }\n\t}\n\n\n可以看到procees方法的逻辑：\n\n* 创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。\n\n\t\t// Call the next interceptor in the chain.\n\t\tRealInterceptorChain next = new RealInterceptorChain(\n\t\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n        \n* 获取索引为index的interceptor,执行索引为index的intercept方法。\n\t\n\t\tInterceptor interceptor = interceptors.get(index);\n    \tResponse response = interceptor.intercept(next);\n\n\n#### 五、拦截器链\n\n##### 1.RetryAndFollowUpInterceptor\n\n\n\t\n\t  @Override public Response intercept(Chain chain) throws IOException {\n\t    Request request = chain.request();\n\t\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n\t\n    int followUpCount = 0;\n    Response priorResponse = null;\n    while (true) {\n      if (canceled) {\n        streamAllocation.release();\n        throw new IOException(\"Canceled\");\n      }\n\t\n      Response response = null;\n      boolean releaseConnection = true;\n      try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      } catch (RouteException e) {\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.getLastConnectException(), false, request)) {\n          throw e.getLastConnectException();\n        }\n        releaseConnection = false;\n        continue;\n      } catch (IOException e) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n        if (!recover(e, requestSendStarted, request)) throw e;\n        releaseConnection = false;\n        continue;\n      } finally {\n        // We're throwing an unchecked exception. Release any resources.\n        if (releaseConnection) {\n          streamAllocation.streamFailed(null);\n          streamAllocation.release();\n        }\n      }\n\t\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                    .body(null)\n                    .build())\n            .build();\n      }\n\t\n      Request followUp = followUpRequest(response);\n\t\n      if (followUp == null) {\n        if (!forWebSocket) {\n          streamAllocation.release();\n        }\n        return response;\n      }\n\t\n      closeQuietly(response.body());\n\t\n      if (++followUpCount > MAX_FOLLOW_UPS) {\n        streamAllocation.release();\n        throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n      }\n\t\n      if (followUp.body() instanceof UnrepeatableRequestBody) {\n        streamAllocation.release();\n        throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n      }\n\t//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n\t请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n\t毁掉,再新建一个StreamAllocation连接,进行重试。\n      if (!sameConnection(response, followUp.url(s))) {\n        streamAllocation.release();\n        streamAllocation = new StreamAllocation(\n            client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n      } else if (streamAllocation.codec() != null) {\n        throw new IllegalStateException(\"Closing the body of \" + response\n            + \" didn't close its backing stream. Bad interceptor?\");\n      }\n\t\n      request = followUp;\n      priorResponse = response;\n    }\n\t}\n\t\n\t\n\t\n* 发起请求前拦截器对request处理\n* 然后调用下一个拦截器，获取Response\n\n调用的关键：\n\n\ttry {\n\t        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n\t        releaseConnection = false;\n\t      }\n\n那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.\n\n\n\n\n\n下面就来对几种拦截器一一介绍。\n\n##### 2.BidgeInterceptor\n\n官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.\n\n整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。\n\n下面就看一下核心方法intercept()\n\n\t@Override public Response intercept(Chain chain) throws IOException {\n\t//拿到用户的请求\n    Request userRequest = chain.request();\n    Request.Builder requestBuilder = userRequest.newBuilder();\n\t//拿到用户请求body\n    RequestBody body = userRequest.body();\n    //对请求头的补充\n    if (body != null) {\n      MediaType contentType = body.contentType();\n      if (contentType != null) {\n        requestBuilder.header(\"Content-Type\", contentType.toString());\n      }\n\n      long contentLength = body.contentLength();\n      if (contentLength != -1) {\n        requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n        requestBuilder.removeHeader(\"Transfer-Encoding\");\n      } else {\n        requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n        requestBuilder.removeHeader(\"Content-Length\");\n      }\n    }\n\n    if (userRequest.header(\"Host\") == null) {\n      requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false));\n    }\n\t//默认是保持连接的（Keep-Alive）\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n\t//默认GZIP压缩\n\t//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n    // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing\n    // the transfer stream.\n    boolean transparentGzip = false;\n    if (userRequest.header(\"Accept-Encoding\") == null && userRequest.header(\"Range\") == null) {\n      transparentGzip = true;\n      requestBuilder.header(\"Accept-Encoding\", \"gzip\");\n    }\n\t//添加cookie头\n    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());\n    if (!cookies.isEmpty()) {\n      requestBuilder.header(\"Cookie\", cookieHeader(cookies));\n    }\n\n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n\t//继续执行下一个拦截器的方法\n    Response networkResponse = chain.proceed(requestBuilder.build());\n\t//接收服务器返回的cookie\n    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\n    Response.Builder responseBuilder = networkResponse.newBuilder()\n        .request(userRequest);\n\n    if (transparentGzip\n        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n        && HttpHeaders.hasBody(networkResponse)) {\n      //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n      Headers strippedHeaders = networkResponse.headers().newBuilder()\n          .removeAll(\"Content-Encoding\")\n          .removeAll(\"Content-Length\")\n          .build();\n      responseBuilder.headers(strippedHeaders);\n      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n    }\n\t//构建一个Response\n    return responseBuilder.build();\n  \t}\n\n\nBridgeInterceptor主要流程逻辑：\n\n1. 拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求\n2. 将这个符合网络请求的Request进行网络请求\n3. 将网络请求返回的Response转化为用户可用的Response\n\t\n\t\n代码中构建网络Request添加的请求头信息：\n\n* 简单了解一下先，头信息\n\n协议头字段名 |说明| 示例 | 状态\n---- | --- | --- | ---\nContent-Type | 请求体的 多媒体类型 （用于POST和PUT请求中）|Content-Type: application/x-www-form-urlencoded|常设\nContent-Length |  以 八位字节数组 （8位的字节）表示的请求体的长度|Content-Length: 348|常设\nTransfer-Encoding|用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity|Transfer-Encoding: chunked|常设\nHost|服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。| Host: en.wikipedia.org:80 Host: en.wikipedia.org|常设\nConnection|该浏览器想要优先使用的连接类型|Connection: keep-alive  \t，Connection: Upgrade|常设\nAccept-Encoding|能够接受的编码方式列表|Accept-Encoding: gzip, deflate|常设\nCookie|之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109|Cookie: $Version=1; Skin=new;|常设: 标准\n\n###### 小结：\n\n* 构建完头信息后，进行网络请求\n\n\t\tResponse networkResponse = chain.proceed(requestBuilder.build());\n\t\t\n* 获取到返回的Response,转化为客户端可用的Response\n\t\n\t\t Response.Builder responseBuilder = networkResponse.newBuilder()\n\t        .request(userRequest);\n\t\n\t    if (transparentGzip\n\t        && \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\"))\n\t        && HttpHeaders.hasBody(networkResponse)) {\n\t      GzipSource responseBody = new GzipSource(networkResponse.body().source());\n\t      Headers strippedHeaders = networkResponse.headers().newBuilder()\n\t          .removeAll(\"Content-Encoding\")\n\t          .removeAll(\"Content-Length\")\n\t          .build();\n\t      responseBuilder.headers(strippedHeaders);\n\t      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n\n\t\n\t\n\n##### 3.CacheIntetceptor\n\nCacheIntetceptor的职责就是负责Cache的管理\n\n看一下核心方法：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t //1.读取候选的缓存\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n\t//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //4.不需要访问网络的情况下，取本地缓存作为结果返回。\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n    //5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    //6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\t\t//8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n\t//9.读取网络请求\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\t//10.对数据进行缓存\n    if (cache != null) {\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        CacheRequest cacheRequest = cache.put(response);\n        return cacheWritingResponse(cacheRequest, response);\n      }\n\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\t//11.返回网络请求的结果\n    return response;\n  \t}\n\t\n\t\n####### 整个过程大致：\n\nCacheInterceptor主要就是负责Cache的管理\n\n   * 当网络被禁止访问，缓存不完整，那么返回失败（504）\n   * 缓存可用，返回缓存结果\n   * 当网络访问，返回（304），更新本地缓存\n   * 当Cache失效，删除缓存\n\n  \n##### 4.ConnectInterceptor\n\n代码不多，但包含的内容很多。\n\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    Request request = realChain.request();\n\t    //拿到StreamAllocation对象。\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t\n\t    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n\t    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n\t    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n\t    RealConnection connection = streamAllocation.connection();\n\t\n\t    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n\t  \t}\n\t\n\t\n从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化\n\n\t    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(request.url()), callStackTrace);\n        \n三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用\n\n看一下StreamAllocation的构造方法\n\n\tpublic StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\n    this.connectionPool = connectionPool;\n    this.address = address;\n    this.routeSelector = new RouteSelector(address, routeDatabase());\n    this.callStackTrace = callStackTrace;\n  \t}\n在把这个三个参数保存为内部变量的同时也创建了一个线路选择器\n\nstreamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。\n\n接下来继续看StreamAllocation中的newSream()方法\n\n\tpublic HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n\t//读取从OkHttpClient配置的超时时间\n    int connectTimeout = client.connectTimeoutMillis();\n    //获取读写超时时间\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    //连接重试\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n    //找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  \t}\n  \t\n 下面就再看一下它是如何找到一个健康的连接的\n\t\t\n\t  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n\t      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n\t      throws IOException {\n\t    while (true) {\n\t    //找到健康的连接\n\t      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n\t          connectionRetryEnabled);\n\t\n\t      // If this is a brand new connection, we can skip the extensive health checks.\n\t      synchronized (connectionPool) {\n\t        if (candidate.successCount == 0) {\n\t          return candidate;\n\t        }\n\t      }\n\t\n\t      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n\t      // isn't, take it out of the pool and start again.\n\t      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n\t        noNewStreams();\n\t        continue;\n\t      }\n\t\n\t      return candidate;\n\t    }\n\t  }\n\t  \n从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。\n\n那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法\n\t          \n\t          \n\tprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n\t      boolean connectionRetryEnabled) throws IOException {\n\t    Route selectedRoute;\n\t    //同步线程池\n\t    synchronized (connectionPool) {\n\t      if (released) throw new IllegalStateException(\"released\");\n\t      if (codec != null) throw new IllegalStateException(\"codec != null\");\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t\t\t//尝试使用现有连接，判断是否可用\n\t      // Attempt to use an already-allocated connection.\n\t      RealConnection allocatedConnection = this.connection;\n\t      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {\n\t        return allocatedConnection;\n\t      }\n\t\t\t//尝试在连接池中获取一个连接，\n\t      // Attempt to get a connection from the pool.\n\t      Internal.instance.get(connectionPool, address, this, null);\n\t      if (connection != null) {\n\t        return connection;\n\t      }\n\t\n\t      selectedRoute = route;\n\t    }\n\t\n\t    // If we need a route, make one. This is a blocking operation.\n\t    if (selectedRoute == null) {\n\t      selectedRoute = routeSelector.next();\n\t    }\n\t\n\t    RealConnection result;\n\t    synchronized (connectionPool) {\n\t      if (canceled) throw new IOException(\"Canceled\");\n\t\n\t      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n\t      // This could match due to connection coalescing.\n\t      Internal.instance.get(connectionPool, address, this, selectedRoute);\n\t      if (connection != null) {\n\t        route = selectedRoute;\n\t        return connection;\n\t      }\n\t\n\t      // Create a connection and assign it to this allocation immediately. This makes it possible\n\t      // for an asynchronous cancel() to interrupt the handshake we're about to do.\n\t      route = selectedRoute;\n\t      refusedStreamCount = 0;\n\t      result = new RealConnection(connectionPool, selectedRoute);\n\t      acquire(result);\n\t    }\n\t\n\t    // Do TCP + TLS handshakes. This is a blocking operation.\n\t    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n\t    routeDatabase().connected(result.route());\n\t\n\t    Socket socket = null;\n\t    synchronized (connectionPool) {\n\t      // Pool the connection.\n\t      Internal.instance.put(connectionPool, result);\n\t\n\t      // If another multiplexed connection to the same address was created concurrently, then\n\t      // release this connection and acquire that one.\n\t      if (result.isMultiplexed()) {\n\t        socket = Internal.instance.deduplicate(connectionPool, address, this);\n\t        result = connection;\n\t      }\n\t    }\n\t    closeQuietly(socket);\n\t\n\t    return result;\n\t  }\n\n这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。\n\n那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。\n\n##### 5.CallServerInterceptor\n\n整个拦截器链中的最后一个拦截器，看一下源码。\n\n关键方法intercept,如下：\n\n\t @Override public Response intercept(Chain chain) throws IOException {\n\t    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n\t    HttpCodec httpCodec = realChain.httpStream();\n\t    StreamAllocation streamAllocation = realChain.streamAllocation();\n\t    RealConnection connection = (RealConnection) realChain.connection();\n\t    Request request = realChain.request();\n\t\t\n\t    long sentRequestMillis = System.currentTimeMillis();\n\t\t //1.首先写请求头\n\t    realChain.eventListener().requestHeadersStart(realChain.call());\n\t    httpCodec.writeRequestHeaders(request);\n\t    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\t\n\t    Response.Builder responseBuilder = null;\n\t    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n\t      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n\t      // Continue\" response before transmitting the request body. If we don't get that, return\n\t      // what we did get (such as a 4xx response) without ever transmitting the request body.\n\t      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n\t        httpCodec.flushRequest();\n\t        realChain.eventListener().responseHeadersStart(realChain.call());\n\t        responseBuilder = httpCodec.readResponseHeaders(true);\n\t      }\n\t\t   //2.然后写请求体\n\t      if (responseBuilder == null) {\n\t        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n\t        realChain.eventListener().requestBodyStart(realChain.call());\n\t        long contentLength = request.body().contentLength();\n\t        CountingSink requestBodyOut =\n\t            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n\t        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\t\n\t        request.body().writeTo(bufferedRequestBody);\n\t        bufferedRequestBody.close();\n\t        realChain.eventListener()\n\t            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n\t      } else if (!connection.isMultiplexed()) {\n\t        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n\t        // from being reused. Otherwise we're still obligated to transmit the request body to\n\t        // leave the connection in a consistent state.\n\t        streamAllocation.noNewStreams();\n\t      }\n\t    }\n\t\n\t    httpCodec.finishRequest();\n\t\t //读取响应头\n\t    if (responseBuilder == null) {\n\t      realChain.eventListener().responseHeadersStart(realChain.call());\n\t      responseBuilder = httpCodec.readResponseHeaders(false);\n\t    }\n\t\n\t    Response response = responseBuilder\n\t        .request(request)\n\t        .handshake(streamAllocation.connection().handshake())\n\t        .sentRequestAtMillis(sentRequestMillis)\n\t        .receivedResponseAtMillis(System.currentTimeMillis())\n\t        .build();\n\t\n\t    realChain.eventListener()\n\t        .responseHeadersEnd(realChain.call(), response);\n\t    //判断响应码，读取响应体\n\t    int code = response.code();\n\t    if (forWebSocket && code == 101) {\n\t      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n\t      response = response.newBuilder()\n\t          .body(Util.EMPTY_RESPONSE)\n\t          .build();\n\t    } else {\n\t      response = response.newBuilder()\n\t          .body(httpCodec.openResponseBody(response))\n\t          .build();\n\t    }\n\t\n\t    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n\t        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n\t      streamAllocation.noNewStreams();\n\t    }\n\t\n\t    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n\t      throw new ProtocolException(\n\t          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n\t    }\n\t\n\t    return response;\n\t  }\n\n真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。\n\n\n##### 最后\n\n\t\t // Call the next interceptor in the chain.\n\t\t    RealInterceptorChain next = new RealInterceptorChain(\n\t\t        interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n\t\t    Interceptor interceptor = interceptors.get(index);\n\t\t    Response response = interceptor.intercept(next);\n\t\t    \n\t\t    \n整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。\n\n\n\n","slug":"OkHttp3源码学习（3）","published":1,"updated":"2017-12-20T07:22:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphe000tv7c0dyiqt0x4","content":"<h4 id=\"一、发起请求\"><a href=\"#一、发起请求\" class=\"headerlink\" title=\"一、发起请求\"></a>一、发起请求</h4><pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre><ul>\n<li><p>发起请求时：client.newCall(request)。</p>\n<pre><code>@Override public Call newCall(Request request) {\nreturn new RealCall(this, request, false /* for web socket */);\n  }\n</code></pre><p>实际上就是创建一个RealCall的实例。</p>\n</li>\n<li><p>然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre></li>\n</ul>\n<h4 id=\"二、AsyncCall\"><a href=\"#二、AsyncCall\" class=\"headerlink\" title=\"二、AsyncCall\"></a>二、AsyncCall</h4><pre><code> @Override protected void execute() {\n  boolean signalledCallback = false;\n  try {\n    Response response = getResponseWithInterceptorChain();\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      signalledCallback = true;\n      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n    } else {\n      signalledCallback = true;\n      responseCallback.onResponse(RealCall.this, response);\n    }\n  } catch (IOException e) {\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n    } else {\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n</code></pre><p>  AsyncCall会执行execute方法。execute方法逻辑很简单：</p>\n<ul>\n<li><p>通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功</p>\n<pre><code>Response response = getResponseWithInterceptorChain();\n</code></pre></li>\n</ul>\n<ul>\n<li><p>通知任务分发器该任务结束</p>\n<pre><code>client.dispatcher().finished(this);\n</code></pre></li>\n</ul>\n<h4 id=\"三、构建拦截器链\"><a href=\"#三、构建拦截器链\" class=\"headerlink\" title=\"三、构建拦截器链\"></a>三、构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><p>从源码来看，基本逻辑就是：</p>\n<ul>\n<li>创建一系列拦截器，加到拦截器数组中。</li>\n<li>创建拦截器链RealInterceptorChain</li>\n<li>执行拦截器链中的proceed方法</li>\n</ul>\n<h4 id=\"四、RealInterceptorChain\"><a href=\"#四、RealInterceptorChain\" class=\"headerlink\" title=\"四、RealInterceptorChain\"></a>四、RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：</p>\n<ul>\n<li><p>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。</p>\n<pre><code>// Call the next interceptor in the chain.\nRealInterceptorChain next = new RealInterceptorChain(\n            interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n</code></pre></li>\n<li><p>获取索引为index的interceptor,执行索引为index的intercept方法。</p>\n<pre><code>Interceptor interceptor = interceptors.get(index);\nResponse response = interceptor.intercept(next);\n</code></pre></li>\n</ul>\n<h4 id=\"五、拦截器链\"><a href=\"#五、拦截器链\" class=\"headerlink\" title=\"五、拦截器链\"></a>五、拦截器链</h4><h5 id=\"1-RetryAndFollowUpInterceptor\"><a href=\"#1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"1.RetryAndFollowUpInterceptor\"></a>1.RetryAndFollowUpInterceptor</h5><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n毁掉,再新建一个StreamAllocation连接,进行重试。\n  if (!sameConnection(response, followUp.url(s))) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.</p>\n<p>下面就来对几种拦截器一一介绍。</p>\n<h5 id=\"2-BidgeInterceptor\"><a href=\"#2-BidgeInterceptor\" class=\"headerlink\" title=\"2.BidgeInterceptor\"></a>2.BidgeInterceptor</h5><p>官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.</p>\n<p>整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。</p>\n<p>下面就看一下核心方法intercept()</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n//拿到用户的请求\nRequest userRequest = chain.request();\nRequest.Builder requestBuilder = userRequest.newBuilder();\n//拿到用户请求body\nRequestBody body = userRequest.body();\n//对请求头的补充\nif (body != null) {\n  MediaType contentType = body.contentType();\n  if (contentType != null) {\n    requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());\n  }\n\n  long contentLength = body.contentLength();\n  if (contentLength != -1) {\n    requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));\n    requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);\n  } else {\n    requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);\n    requestBuilder.removeHeader(&quot;Content-Length&quot;);\n  }\n}\n\nif (userRequest.header(&quot;Host&quot;) == null) {\n  requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));\n}\n//默认是保持连接的（Keep-Alive）\nif (userRequest.header(&quot;Connection&quot;) == null) {\n  requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n}\n//默认GZIP压缩\n//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n// If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing\n// the transfer stream.\nboolean transparentGzip = false;\nif (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {\n  transparentGzip = true;\n  requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);\n}\n//添加cookie头\nList&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());\nif (!cookies.isEmpty()) {\n  requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));\n}\n\nif (userRequest.header(&quot;User-Agent&quot;) == null) {\n  requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());\n}\n//继续执行下一个拦截器的方法\nResponse networkResponse = chain.proceed(requestBuilder.build());\n//接收服务器返回的cookie\nHttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\nResponse.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n}\n//构建一个Response\nreturn responseBuilder.build();\n  }\n</code></pre><p>BridgeInterceptor主要流程逻辑：</p>\n<ol>\n<li>拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求</li>\n<li>将这个符合网络请求的Request进行网络请求</li>\n<li>将网络请求返回的Response转化为用户可用的Response</li>\n</ol>\n<p>代码中构建网络Request添加的请求头信息：</p>\n<ul>\n<li>简单了解一下先，头信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议头字段名</th>\n<th>说明</th>\n<th>示例</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content-Type</td>\n<td>请求体的 多媒体类型 （用于POST和PUT请求中）</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>\n<td>Content-Length: 348</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity</td>\n<td>Transfer-Encoding: chunked</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。</td>\n<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>该浏览器想要优先使用的连接类型</td>\n<td>Connection: keep-alive      ，Connection: Upgrade</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>能够接受的编码方式列表</td>\n<td>Accept-Encoding: gzip, deflate</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n<td>常设: 标准</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li><p>构建完头信息后，进行网络请求</p>\n<pre><code>Response networkResponse = chain.proceed(requestBuilder.build());\n</code></pre></li>\n<li><p>获取到返回的Response,转化为客户端可用的Response</p>\n<pre><code> Response.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n</code></pre></li>\n</ul>\n<h5 id=\"3-CacheIntetceptor\"><a href=\"#3-CacheIntetceptor\" class=\"headerlink\" title=\"3.CacheIntetceptor\"></a>3.CacheIntetceptor</h5><p>CacheIntetceptor的职责就是负责Cache的管理</p>\n<p>看一下核心方法：</p>\n<pre><code> @Override public Response intercept(Chain chain) throws IOException {\n //1.读取候选的缓存\nResponse cacheCandidate = cache != null\n    ? cache.get(chain.request())\n    : null;\n\nlong now = System.currentTimeMillis();\n//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\nCacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\nRequest networkRequest = strategy.networkRequest;\nResponse cacheResponse = strategy.cacheResponse;\n\nif (cache != null) {\n  cache.trackResponse(strategy);\n}\n\nif (cacheCandidate != null &amp;&amp; cacheResponse == null) {\n  closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.\n}\n\n// If we&apos;re forbidden from using the network and the cache is insufficient, fail.\n//3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\nif (networkRequest == null &amp;&amp; cacheResponse == null) {\n  return new Response.Builder()\n      .request(chain.request())\n      .protocol(Protocol.HTTP_1_1)\n      .code(504)\n      .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)\n      .body(Util.EMPTY_RESPONSE)\n      .sentRequestAtMillis(-1L)\n      .receivedResponseAtMillis(System.currentTimeMillis())\n      .build();\n}\n\n// If we don&apos;t need the network, we&apos;re done.\n//4.不需要访问网络的情况下，取本地缓存作为结果返回。\nif (networkRequest == null) {\n  return cacheResponse.newBuilder()\n      .cacheResponse(stripBody(cacheResponse))\n      .build();\n}\n\nResponse networkResponse = null;\ntry {\n//5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n  networkResponse = chain.proceed(networkRequest);\n} finally {\n  // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.\n  if (networkResponse == null &amp;&amp; cacheCandidate != null) {\n    closeQuietly(cacheCandidate.body());\n  }\n}\n\n// If we have a cache response too, then we&apos;re doing a conditional get.\n//6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\nif (cacheResponse != null) {\n  if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n    Response response = cacheResponse.newBuilder()\n        .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n    networkResponse.body().close();\n    //8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n    // Update the cache after combining headers but before stripping the\n    // Content-Encoding header (as performed by initContentStream()).\n    cache.trackConditionalCacheHit();\n    cache.update(cacheResponse, response);\n    return response;\n  } else {\n    closeQuietly(cacheResponse.body());\n  }\n}\n//9.读取网络请求\nResponse response = networkResponse.newBuilder()\n    .cacheResponse(stripBody(cacheResponse))\n    .networkResponse(stripBody(networkResponse))\n    .build();\n//10.对数据进行缓存\nif (cache != null) {\n  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {\n    // Offer this request to the cache.\n    CacheRequest cacheRequest = cache.put(response);\n    return cacheWritingResponse(cacheRequest, response);\n  }\n\n  if (HttpMethod.invalidatesCache(networkRequest.method())) {\n    try {\n      cache.remove(networkRequest);\n    } catch (IOException ignored) {\n      // The cache cannot be written.\n    }\n  }\n}\n//11.返回网络请求的结果\nreturn response;\n  }\n</code></pre><p>####### 整个过程大致：</p>\n<p>CacheInterceptor主要就是负责Cache的管理</p>\n<ul>\n<li>当网络被禁止访问，缓存不完整，那么返回失败（504）</li>\n<li>缓存可用，返回缓存结果</li>\n<li>当网络访问，返回（304），更新本地缓存</li>\n<li>当Cache失效，删除缓存</li>\n</ul>\n<h5 id=\"4-ConnectInterceptor\"><a href=\"#4-ConnectInterceptor\" class=\"headerlink\" title=\"4.ConnectInterceptor\"></a>4.ConnectInterceptor</h5><p>代码不多，但包含的内容很多。</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   Request request = realChain.request();\n   //拿到StreamAllocation对象。\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n\n   // We need the network to satisfy this request. Possibly for validating a conditional GET.\n   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);\n   HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n   RealConnection connection = streamAllocation.connection();\n\n   return realChain.proceed(request, streamAllocation, httpCodec, connection);\n     }\n</code></pre><p>从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化</p>\n<pre><code>streamAllocation = new StreamAllocation(\nclient.connectionPool(), createAddress(request.url()), callStackTrace);\n</code></pre><p>三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用</p>\n<p>看一下StreamAllocation的构造方法</p>\n<pre><code>public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\nthis.connectionPool = connectionPool;\nthis.address = address;\nthis.routeSelector = new RouteSelector(address, routeDatabase());\nthis.callStackTrace = callStackTrace;\n  }\n</code></pre><p>在把这个三个参数保存为内部变量的同时也创建了一个线路选择器</p>\n<p>streamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。</p>\n<p>接下来继续看StreamAllocation中的newSream()方法</p>\n<pre><code>public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n//读取从OkHttpClient配置的超时时间\nint connectTimeout = client.connectTimeoutMillis();\n//获取读写超时时间\nint readTimeout = client.readTimeoutMillis();\nint writeTimeout = client.writeTimeoutMillis();\n//连接重试\nboolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\ntry {\n//找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n  //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n  HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n  synchronized (connectionPool) {\n    codec = resultCodec;\n    return resultCodec;\n  }\n} catch (IOException e) {\n  throw new RouteException(e);\n}\n  }\n</code></pre><p> 下面就再看一下它是如何找到一个健康的连接的</p>\n<pre><code>private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n    int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n    throws IOException {\n  while (true) {\n  //找到健康的连接\n    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n        connectionRetryEnabled);\n\n    // If this is a brand new connection, we can skip the extensive health checks.\n    synchronized (connectionPool) {\n      if (candidate.successCount == 0) {\n        return candidate;\n      }\n    }\n\n    // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n    // isn&apos;t, take it out of the pool and start again.\n    if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n      noNewStreams();\n      continue;\n    }\n\n    return candidate;\n  }\n}\n</code></pre><p>从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。</p>\n<p>那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法</p>\n<pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    Route selectedRoute;\n    //同步线程池\n    synchronized (connectionPool) {\n      if (released) throw new IllegalStateException(&quot;released&quot;);\n      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n        //尝试使用现有连接，判断是否可用\n      // Attempt to use an already-allocated connection.\n      RealConnection allocatedConnection = this.connection;\n      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) {\n        return allocatedConnection;\n      }\n        //尝试在连接池中获取一个连接，\n      // Attempt to get a connection from the pool.\n      Internal.instance.get(connectionPool, address, this, null);\n      if (connection != null) {\n        return connection;\n      }\n\n      selectedRoute = route;\n    }\n\n    // If we need a route, make one. This is a blocking operation.\n    if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n    }\n\n    RealConnection result;\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n      // This could match due to connection coalescing.\n      Internal.instance.get(connectionPool, address, this, selectedRoute);\n      if (connection != null) {\n        route = selectedRoute;\n        return connection;\n      }\n\n      // Create a connection and assign it to this allocation immediately. This makes it possible\n      // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.\n      route = selectedRoute;\n      refusedStreamCount = 0;\n      result = new RealConnection(connectionPool, selectedRoute);\n      acquire(result);\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      // Pool the connection.\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    return result;\n  }\n</code></pre><p>这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。</p>\n<p>那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p>\n<h5 id=\"5-CallServerInterceptor\"><a href=\"#5-CallServerInterceptor\" class=\"headerlink\" title=\"5.CallServerInterceptor\"></a>5.CallServerInterceptor</h5><p>整个拦截器链中的最后一个拦截器，看一下源码。</p>\n<p>关键方法intercept,如下：</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   HttpCodec httpCodec = realChain.httpStream();\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n   RealConnection connection = (RealConnection) realChain.connection();\n   Request request = realChain.request();\n\n   long sentRequestMillis = System.currentTimeMillis();\n    //1.首先写请求头\n   realChain.eventListener().requestHeadersStart(realChain.call());\n   httpCodec.writeRequestHeaders(request);\n   realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n   Response.Builder responseBuilder = null;\n   if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {\n     // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100\n     // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return\n     // what we did get (such as a 4xx response) without ever transmitting the request body.\n     if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {\n       httpCodec.flushRequest();\n       realChain.eventListener().responseHeadersStart(realChain.call());\n       responseBuilder = httpCodec.readResponseHeaders(true);\n     }\n      //2.然后写请求体\n     if (responseBuilder == null) {\n       // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.\n       realChain.eventListener().requestBodyStart(realChain.call());\n       long contentLength = request.body().contentLength();\n       CountingSink requestBodyOut =\n           new CountingSink(httpCodec.createRequestBody(request, contentLength));\n       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n       request.body().writeTo(bufferedRequestBody);\n       bufferedRequestBody.close();\n       realChain.eventListener()\n           .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n     } else if (!connection.isMultiplexed()) {\n       // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection\n       // from being reused. Otherwise we&apos;re still obligated to transmit the request body to\n       // leave the connection in a consistent state.\n       streamAllocation.noNewStreams();\n     }\n   }\n\n   httpCodec.finishRequest();\n    //读取响应头\n   if (responseBuilder == null) {\n     realChain.eventListener().responseHeadersStart(realChain.call());\n     responseBuilder = httpCodec.readResponseHeaders(false);\n   }\n\n   Response response = responseBuilder\n       .request(request)\n       .handshake(streamAllocation.connection().handshake())\n       .sentRequestAtMillis(sentRequestMillis)\n       .receivedResponseAtMillis(System.currentTimeMillis())\n       .build();\n\n   realChain.eventListener()\n       .responseHeadersEnd(realChain.call(), response);\n   //判断响应码，读取响应体\n   int code = response.code();\n   if (forWebSocket &amp;&amp; code == 101) {\n     // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n     response = response.newBuilder()\n         .body(Util.EMPTY_RESPONSE)\n         .build();\n   } else {\n     response = response.newBuilder()\n         .body(httpCodec.openResponseBody(response))\n         .build();\n   }\n\n   if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))\n       || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {\n     streamAllocation.noNewStreams();\n   }\n\n   if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {\n     throw new ProtocolException(\n         &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());\n   }\n\n   return response;\n }\n</code></pre><p>真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、发起请求\"><a href=\"#一、发起请求\" class=\"headerlink\" title=\"一、发起请求\"></a>一、发起请求</h4><pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre><ul>\n<li><p>发起请求时：client.newCall(request)。</p>\n<pre><code>@Override public Call newCall(Request request) {\nreturn new RealCall(this, request, false /* for web socket */);\n  }\n</code></pre><p>实际上就是创建一个RealCall的实例。</p>\n</li>\n<li><p>然后call.enqueue,源码实现就是将RealCall加到任务队列中，等合适的机会去执行。</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre></li>\n</ul>\n<h4 id=\"二、AsyncCall\"><a href=\"#二、AsyncCall\" class=\"headerlink\" title=\"二、AsyncCall\"></a>二、AsyncCall</h4><pre><code> @Override protected void execute() {\n  boolean signalledCallback = false;\n  try {\n    Response response = getResponseWithInterceptorChain();\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      signalledCallback = true;\n      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n    } else {\n      signalledCallback = true;\n      responseCallback.onResponse(RealCall.this, response);\n    }\n  } catch (IOException e) {\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n    } else {\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n</code></pre><p>  AsyncCall会执行execute方法。execute方法逻辑很简单：</p>\n<ul>\n<li><p>通过调用getResponseWithInterceptorChain获取服务器返回结果，失败或者成功</p>\n<pre><code>Response response = getResponseWithInterceptorChain();\n</code></pre></li>\n</ul>\n<ul>\n<li><p>通知任务分发器该任务结束</p>\n<pre><code>client.dispatcher().finished(this);\n</code></pre></li>\n</ul>\n<h4 id=\"三、构建拦截器链\"><a href=\"#三、构建拦截器链\" class=\"headerlink\" title=\"三、构建拦截器链\"></a>三、构建拦截器链</h4><pre><code>Response getResponseWithInterceptorChain() throws IOException {\n   // Build a full stack of interceptors.\n   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();\n   interceptors.addAll(client.interceptors());\n   interceptors.add(retryAndFollowUpInterceptor);\n   interceptors.add(new BridgeInterceptor(client.cookieJar()));\n   interceptors.add(new CacheInterceptor(client.internalCache()));\n   interceptors.add(new ConnectInterceptor(client));\n   if (!forWebSocket) {\n     interceptors.addAll(client.networkInterceptors());\n   }\n   interceptors.add(new CallServerInterceptor(forWebSocket));\n\n   Interceptor.Chain chain = new RealInterceptorChain(\n       interceptors, null, null, null, 0, originalRequest);\n   return chain.proceed(originalRequest);\n }\n</code></pre><p>从源码来看，基本逻辑就是：</p>\n<ul>\n<li>创建一系列拦截器，加到拦截器数组中。</li>\n<li>创建拦截器链RealInterceptorChain</li>\n<li>执行拦截器链中的proceed方法</li>\n</ul>\n<h4 id=\"四、RealInterceptorChain\"><a href=\"#四、RealInterceptorChain\" class=\"headerlink\" title=\"四、RealInterceptorChain\"></a>四、RealInterceptorChain</h4><pre><code>/**\n * A concrete interceptor chain that carries the entire interceptor chain: all application\n * interceptors, the OkHttp core, all network interceptors, and finally the network caller.\n */\npublic final class RealInterceptorChain implements Interceptor.Chain {\n  private final List&lt;Interceptor&gt; interceptors;\n  private final StreamAllocation streamAllocation;\n  private final HttpCodec httpCodec;\n  private final RealConnection connection;\n  private final int index;\n  private final Request request;\n  private int calls;\n\n  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,\n      HttpCodec httpCodec, RealConnection connection, int index, Request request) {\n    this.interceptors = interceptors;\n    this.connection = connection;\n    this.streamAllocation = streamAllocation;\n    this.httpCodec = httpCodec;\n    this.index = index;\n    this.request = request;\n  }\n\n  @Override public Connection connection() {\n    return connection;\n  }\n\n  public StreamAllocation streamAllocation() {\n    return streamAllocation;\n  }\n\n  public HttpCodec httpStream() {\n    return httpCodec;\n  }\n\n  @Override public Request request() {\n    return request;\n  }\n\n  @Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n  }\n\n  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n      RealConnection connection) throws IOException {\n    if (index &gt;= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    // If we already have a stream, confirm that the incoming request will use it.\n    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must retain the same host and port&quot;);\n    }\n\n    // If we already have a stream, confirm that this is the only call to chain.proceed().\n    if (this.httpCodec != null &amp;&amp; calls &gt; 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n\n\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {\n      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor\n          + &quot; must call proceed() exactly once&quot;);\n    }\n\n    // Confirm that the intercepted response isn&apos;t null.\n    if (response == null) {\n      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);\n    }\n\n    return response;\n  }\n}\n</code></pre><p>可以看到procees方法的逻辑：</p>\n<ul>\n<li><p>创建下一个拦截链（代码中的next），传入index+1，使创建的下一个拦截器链只能从下一个拦截器访问。</p>\n<pre><code>// Call the next interceptor in the chain.\nRealInterceptorChain next = new RealInterceptorChain(\n            interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n</code></pre></li>\n<li><p>获取索引为index的interceptor,执行索引为index的intercept方法。</p>\n<pre><code>Interceptor interceptor = interceptors.get(index);\nResponse response = interceptor.intercept(next);\n</code></pre></li>\n</ul>\n<h4 id=\"五、拦截器链\"><a href=\"#五、拦截器链\" class=\"headerlink\" title=\"五、拦截器链\"></a>五、拦截器链</h4><h5 id=\"1-RetryAndFollowUpInterceptor\"><a href=\"#1-RetryAndFollowUpInterceptor\" class=\"headerlink\" title=\"1.RetryAndFollowUpInterceptor\"></a>1.RetryAndFollowUpInterceptor</h5><pre><code>  @Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n\nstreamAllocation = new StreamAllocation(\n    client.connectionPool(), createAddress(request.url()), callStackTrace);\n\nint followUpCount = 0;\nResponse priorResponse = null;\nwhile (true) {\n  if (canceled) {\n    streamAllocation.release();\n    throw new IOException(&quot;Canceled&quot;);\n  }\n\n  Response response = null;\n  boolean releaseConnection = true;\n  try {\n    response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n    releaseConnection = false;\n  } catch (RouteException e) {\n    // The attempt to connect via a route failed. The request will not have been sent.\n    if (!recover(e.getLastConnectException(), false, request)) {\n      throw e.getLastConnectException();\n    }\n    releaseConnection = false;\n    continue;\n  } catch (IOException e) {\n    // An attempt to communicate with a server failed. The request may have been sent.\n    boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n    if (!recover(e, requestSendStarted, request)) throw e;\n    releaseConnection = false;\n    continue;\n  } finally {\n    // We&apos;re throwing an unchecked exception. Release any resources.\n    if (releaseConnection) {\n      streamAllocation.streamFailed(null);\n      streamAllocation.release();\n    }\n  }\n\n  // Attach the prior response if it exists. Such responses never have a body.\n  if (priorResponse != null) {\n    response = response.newBuilder()\n        .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n        .build();\n  }\n\n  Request followUp = followUpRequest(response);\n\n  if (followUp == null) {\n    if (!forWebSocket) {\n      streamAllocation.release();\n    }\n    return response;\n  }\n\n  closeQuietly(response.body());\n\n  if (++followUpCount &gt; MAX_FOLLOW_UPS) {\n    streamAllocation.release();\n    throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);\n  }\n\n  if (followUp.body() instanceof UnrepeatableRequestBody) {\n    streamAllocation.release();\n    throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());\n  }\n//与当前的响应进行对比，检查是否同一个连接。通常，当发生请求重定向时，url地址将会有所不同，也就是说，\n请求的资源在这时已经被分配了新的url.当不是同一个url请求时，将原先的streamAllocation执行release销\n毁掉,再新建一个StreamAllocation连接,进行重试。\n  if (!sameConnection(response, followUp.url(s))) {\n    streamAllocation.release();\n    streamAllocation = new StreamAllocation(\n        client.connectionPool(), createAddress(followUp.url()), callStackTrace);\n  } else if (streamAllocation.codec() != null) {\n    throw new IllegalStateException(&quot;Closing the body of &quot; + response\n        + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);\n  }\n\n  request = followUp;\n  priorResponse = response;\n}\n}\n</code></pre><ul>\n<li>发起请求前拦截器对request处理</li>\n<li>然后调用下一个拦截器，获取Response</li>\n</ul>\n<p>调用的关键：</p>\n<pre><code>try {\n        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n      }\n</code></pre><p>那么这个时候就会去调用下一个拦截器。对response进行处理，返回给上一个拦截器.</p>\n<p>下面就来对几种拦截器一一介绍。</p>\n<h5 id=\"2-BidgeInterceptor\"><a href=\"#2-BidgeInterceptor\" class=\"headerlink\" title=\"2.BidgeInterceptor\"></a>2.BidgeInterceptor</h5><p>官方注释解释：从应用程序代码到网络代码的桥梁，首先从用户的请求构建一个网络请求，然后执行访问网络，最后返回Response.</p>\n<p>整个过程就是：首先将客户端构建的Request对象信息构建成真正的网络请求;然后发起网络请求，最后就是将服务器返回的消息封装成一个Response对象。</p>\n<p>下面就看一下核心方法intercept()</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n//拿到用户的请求\nRequest userRequest = chain.request();\nRequest.Builder requestBuilder = userRequest.newBuilder();\n//拿到用户请求body\nRequestBody body = userRequest.body();\n//对请求头的补充\nif (body != null) {\n  MediaType contentType = body.contentType();\n  if (contentType != null) {\n    requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());\n  }\n\n  long contentLength = body.contentLength();\n  if (contentLength != -1) {\n    requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));\n    requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);\n  } else {\n    requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);\n    requestBuilder.removeHeader(&quot;Content-Length&quot;);\n  }\n}\n\nif (userRequest.header(&quot;Host&quot;) == null) {\n  requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));\n}\n//默认是保持连接的（Keep-Alive）\nif (userRequest.header(&quot;Connection&quot;) == null) {\n  requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);\n}\n//默认GZIP压缩\n//Accept-Encoding就是告诉服务器客户端能接收的数据编码类型\n// If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing\n// the transfer stream.\nboolean transparentGzip = false;\nif (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {\n  transparentGzip = true;\n  requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);\n}\n//添加cookie头\nList&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());\nif (!cookies.isEmpty()) {\n  requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));\n}\n\nif (userRequest.header(&quot;User-Agent&quot;) == null) {\n  requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());\n}\n//继续执行下一个拦截器的方法\nResponse networkResponse = chain.proceed(requestBuilder.build());\n//接收服务器返回的cookie\nHttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());\n\nResponse.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  //当服务器返回的数据是GZIP压缩的，那么客户端就进行GZIP解压操作\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n}\n//构建一个Response\nreturn responseBuilder.build();\n  }\n</code></pre><p>BridgeInterceptor主要流程逻辑：</p>\n<ol>\n<li>拿到用户的请求,将用户的构建的Request请求转化为真正的网络请求</li>\n<li>将这个符合网络请求的Request进行网络请求</li>\n<li>将网络请求返回的Response转化为用户可用的Response</li>\n</ol>\n<p>代码中构建网络Request添加的请求头信息：</p>\n<ul>\n<li>简单了解一下先，头信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议头字段名</th>\n<th>说明</th>\n<th>示例</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Content-Type</td>\n<td>请求体的 多媒体类型 （用于POST和PUT请求中）</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>以 八位字节数组 （8位的字节）表示的请求体的长度</td>\n<td>Content-Length: 348</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>用来将实体安全地传输给用户的编码形式。当前定义的方法包括：分块（chunked）、compress、deflate、gzip和identity</td>\n<td>Transfer-Encoding: chunked</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。自超文件传输协议版本1.1（HTTP/1.1）开始便是必需字段。</td>\n<td>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>该浏览器想要优先使用的连接类型</td>\n<td>Connection: keep-alive      ，Connection: Upgrade</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>能够接受的编码方式列表</td>\n<td>Accept-Encoding: gzip, deflate</td>\n<td>常设</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie。指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n<td>常设: 标准</td>\n</tr>\n</tbody>\n</table>\n<h6 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h6><ul>\n<li><p>构建完头信息后，进行网络请求</p>\n<pre><code>Response networkResponse = chain.proceed(requestBuilder.build());\n</code></pre></li>\n<li><p>获取到返回的Response,转化为客户端可用的Response</p>\n<pre><code> Response.Builder responseBuilder = networkResponse.newBuilder()\n    .request(userRequest);\n\nif (transparentGzip\n    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))\n    &amp;&amp; HttpHeaders.hasBody(networkResponse)) {\n  GzipSource responseBody = new GzipSource(networkResponse.body().source());\n  Headers strippedHeaders = networkResponse.headers().newBuilder()\n      .removeAll(&quot;Content-Encoding&quot;)\n      .removeAll(&quot;Content-Length&quot;)\n      .build();\n  responseBuilder.headers(strippedHeaders);\n  responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));\n</code></pre></li>\n</ul>\n<h5 id=\"3-CacheIntetceptor\"><a href=\"#3-CacheIntetceptor\" class=\"headerlink\" title=\"3.CacheIntetceptor\"></a>3.CacheIntetceptor</h5><p>CacheIntetceptor的职责就是负责Cache的管理</p>\n<p>看一下核心方法：</p>\n<pre><code> @Override public Response intercept(Chain chain) throws IOException {\n //1.读取候选的缓存\nResponse cacheCandidate = cache != null\n    ? cache.get(chain.request())\n    : null;\n\nlong now = System.currentTimeMillis();\n//2.首先创建缓存策略，networkRequest为网络请求，cacheResponse为缓存\nCacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\nRequest networkRequest = strategy.networkRequest;\nResponse cacheResponse = strategy.cacheResponse;\n\nif (cache != null) {\n  cache.trackResponse(strategy);\n}\n\nif (cacheCandidate != null &amp;&amp; cacheResponse == null) {\n  closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.\n}\n\n// If we&apos;re forbidden from using the network and the cache is insufficient, fail.\n//3.如果禁止网络访问并且本地cache缓存也不完整，那么请求失败\nif (networkRequest == null &amp;&amp; cacheResponse == null) {\n  return new Response.Builder()\n      .request(chain.request())\n      .protocol(Protocol.HTTP_1_1)\n      .code(504)\n      .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)\n      .body(Util.EMPTY_RESPONSE)\n      .sentRequestAtMillis(-1L)\n      .receivedResponseAtMillis(System.currentTimeMillis())\n      .build();\n}\n\n// If we don&apos;t need the network, we&apos;re done.\n//4.不需要访问网络的情况下，取本地缓存作为结果返回。\nif (networkRequest == null) {\n  return cacheResponse.newBuilder()\n      .cacheResponse(stripBody(cacheResponse))\n      .build();\n}\n\nResponse networkResponse = null;\ntry {\n//5.当以上情况都没有结果返回，就读取网络结果（继续执行下一个拦截器）\n  networkResponse = chain.proceed(networkRequest);\n} finally {\n  // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.\n  if (networkResponse == null &amp;&amp; cacheCandidate != null) {\n    closeQuietly(cacheCandidate.body());\n  }\n}\n\n// If we have a cache response too, then we&apos;re doing a conditional get.\n//6.接收到网络结果返回，如果我们也有缓存，那么就会进行条件对比组合\nif (cacheResponse != null) {\n  if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n    Response response = cacheResponse.newBuilder()\n        .headers(combine(cacheResponse.headers(), networkResponse.headers()))//7.将缓存返回与网络返回的头信息进行组合\n        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n    networkResponse.body().close();\n    //8.组合头后，但在剥离Content-Encoding头（由initContentStream（）执行）之前更新缓存。\n    // Update the cache after combining headers but before stripping the\n    // Content-Encoding header (as performed by initContentStream()).\n    cache.trackConditionalCacheHit();\n    cache.update(cacheResponse, response);\n    return response;\n  } else {\n    closeQuietly(cacheResponse.body());\n  }\n}\n//9.读取网络请求\nResponse response = networkResponse.newBuilder()\n    .cacheResponse(stripBody(cacheResponse))\n    .networkResponse(stripBody(networkResponse))\n    .build();\n//10.对数据进行缓存\nif (cache != null) {\n  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {\n    // Offer this request to the cache.\n    CacheRequest cacheRequest = cache.put(response);\n    return cacheWritingResponse(cacheRequest, response);\n  }\n\n  if (HttpMethod.invalidatesCache(networkRequest.method())) {\n    try {\n      cache.remove(networkRequest);\n    } catch (IOException ignored) {\n      // The cache cannot be written.\n    }\n  }\n}\n//11.返回网络请求的结果\nreturn response;\n  }\n</code></pre><p>####### 整个过程大致：</p>\n<p>CacheInterceptor主要就是负责Cache的管理</p>\n<ul>\n<li>当网络被禁止访问，缓存不完整，那么返回失败（504）</li>\n<li>缓存可用，返回缓存结果</li>\n<li>当网络访问，返回（304），更新本地缓存</li>\n<li>当Cache失效，删除缓存</li>\n</ul>\n<h5 id=\"4-ConnectInterceptor\"><a href=\"#4-ConnectInterceptor\" class=\"headerlink\" title=\"4.ConnectInterceptor\"></a>4.ConnectInterceptor</h5><p>代码不多，但包含的内容很多。</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   Request request = realChain.request();\n   //拿到StreamAllocation对象。\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n\n   // We need the network to satisfy this request. Possibly for validating a conditional GET.\n   boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);\n   HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);\n   RealConnection connection = streamAllocation.connection();\n\n   return realChain.proceed(request, streamAllocation, httpCodec, connection);\n     }\n</code></pre><p>从源码来看，StreamAllocation在RetryAndFollowUpInterceptor中进行的初始化</p>\n<pre><code>streamAllocation = new StreamAllocation(\nclient.connectionPool(), createAddress(request.url()), callStackTrace);\n</code></pre><p>三个参数分别是：一个连接池，一个地址类，一个调用堆栈跟踪相关。主要是把这个三个参数保存为内部变量，供后面使用</p>\n<p>看一下StreamAllocation的构造方法</p>\n<pre><code>public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {\nthis.connectionPool = connectionPool;\nthis.address = address;\nthis.routeSelector = new RouteSelector(address, routeDatabase());\nthis.callStackTrace = callStackTrace;\n  }\n</code></pre><p>在把这个三个参数保存为内部变量的同时也创建了一个线路选择器</p>\n<p>streamAllocation.newStream 通过这个方法得到一个 HttpStream 这个接口有两个实现类分别是 Http1xStream 和 Http2xStream 现在只分析 Http1xStream ，这个 Http1xStream 流是通过 SOCKET 与服务端建立连接之后，通向服务端的输入和输出流的封装。</p>\n<p>接下来继续看StreamAllocation中的newSream()方法</p>\n<pre><code>public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n//读取从OkHttpClient配置的超时时间\nint connectTimeout = client.connectTimeoutMillis();\n//获取读写超时时间\nint readTimeout = client.readTimeoutMillis();\nint writeTimeout = client.writeTimeoutMillis();\n//连接重试\nboolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\ntry {\n//找到一个健康的连接（在连接池中寻找或者新创建一个连接）\n  RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n      writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n  //HttpCodec用来编码HTTP请求并解码HTTP响应。在这里初始化\n  HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n  synchronized (connectionPool) {\n    codec = resultCodec;\n    return resultCodec;\n  }\n} catch (IOException e) {\n  throw new RouteException(e);\n}\n  }\n</code></pre><p> 下面就再看一下它是如何找到一个健康的连接的</p>\n<pre><code>private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n    int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n    throws IOException {\n  while (true) {\n  //找到健康的连接\n    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n        connectionRetryEnabled);\n\n    // If this is a brand new connection, we can skip the extensive health checks.\n    synchronized (connectionPool) {\n      if (candidate.successCount == 0) {\n        return candidate;\n      }\n    }\n\n    // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n    // isn&apos;t, take it out of the pool and start again.\n    if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n      noNewStreams();\n      continue;\n    }\n\n    return candidate;\n  }\n}\n</code></pre><p>从源码来看，这个方法就是找到一个连接并返回它，如果它是健康的。 如果这是不健康的，那么这个过程将被重复，直到找到一个健康的连接。</p>\n<p>那么继续跟进，看一下是怎么找到健康的连接，进入findConnection(connectTimeout,readTimeout, writeTimeout,connectionRetryEnabled)方法</p>\n<pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    Route selectedRoute;\n    //同步线程池\n    synchronized (connectionPool) {\n      if (released) throw new IllegalStateException(&quot;released&quot;);\n      if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n        //尝试使用现有连接，判断是否可用\n      // Attempt to use an already-allocated connection.\n      RealConnection allocatedConnection = this.connection;\n      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) {\n        return allocatedConnection;\n      }\n        //尝试在连接池中获取一个连接，\n      // Attempt to get a connection from the pool.\n      Internal.instance.get(connectionPool, address, this, null);\n      if (connection != null) {\n        return connection;\n      }\n\n      selectedRoute = route;\n    }\n\n    // If we need a route, make one. This is a blocking operation.\n    if (selectedRoute == null) {\n      selectedRoute = routeSelector.next();\n    }\n\n    RealConnection result;\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(&quot;Canceled&quot;);\n\n      // Now that we have an IP address, make another attempt at getting a connection from the pool.\n      // This could match due to connection coalescing.\n      Internal.instance.get(connectionPool, address, this, selectedRoute);\n      if (connection != null) {\n        route = selectedRoute;\n        return connection;\n      }\n\n      // Create a connection and assign it to this allocation immediately. This makes it possible\n      // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.\n      route = selectedRoute;\n      refusedStreamCount = 0;\n      result = new RealConnection(connectionPool, selectedRoute);\n      acquire(result);\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      // Pool the connection.\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      if (result.isMultiplexed()) {\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    closeQuietly(socket);\n\n    return result;\n  }\n</code></pre><p>这个方法的大致逻辑就是：返回连接以托管新流。 如果现有的连接存在，则优先选择池，最后建立一个新的连接。</p>\n<p>那么回到ConnectInterceptor,它的作用就是为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p>\n<h5 id=\"5-CallServerInterceptor\"><a href=\"#5-CallServerInterceptor\" class=\"headerlink\" title=\"5.CallServerInterceptor\"></a>5.CallServerInterceptor</h5><p>整个拦截器链中的最后一个拦截器，看一下源码。</p>\n<p>关键方法intercept,如下：</p>\n<pre><code>@Override public Response intercept(Chain chain) throws IOException {\n   RealInterceptorChain realChain = (RealInterceptorChain) chain;\n   HttpCodec httpCodec = realChain.httpStream();\n   StreamAllocation streamAllocation = realChain.streamAllocation();\n   RealConnection connection = (RealConnection) realChain.connection();\n   Request request = realChain.request();\n\n   long sentRequestMillis = System.currentTimeMillis();\n    //1.首先写请求头\n   realChain.eventListener().requestHeadersStart(realChain.call());\n   httpCodec.writeRequestHeaders(request);\n   realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n   Response.Builder responseBuilder = null;\n   if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {\n     // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100\n     // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return\n     // what we did get (such as a 4xx response) without ever transmitting the request body.\n     if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {\n       httpCodec.flushRequest();\n       realChain.eventListener().responseHeadersStart(realChain.call());\n       responseBuilder = httpCodec.readResponseHeaders(true);\n     }\n      //2.然后写请求体\n     if (responseBuilder == null) {\n       // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.\n       realChain.eventListener().requestBodyStart(realChain.call());\n       long contentLength = request.body().contentLength();\n       CountingSink requestBodyOut =\n           new CountingSink(httpCodec.createRequestBody(request, contentLength));\n       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n       request.body().writeTo(bufferedRequestBody);\n       bufferedRequestBody.close();\n       realChain.eventListener()\n           .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n     } else if (!connection.isMultiplexed()) {\n       // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection\n       // from being reused. Otherwise we&apos;re still obligated to transmit the request body to\n       // leave the connection in a consistent state.\n       streamAllocation.noNewStreams();\n     }\n   }\n\n   httpCodec.finishRequest();\n    //读取响应头\n   if (responseBuilder == null) {\n     realChain.eventListener().responseHeadersStart(realChain.call());\n     responseBuilder = httpCodec.readResponseHeaders(false);\n   }\n\n   Response response = responseBuilder\n       .request(request)\n       .handshake(streamAllocation.connection().handshake())\n       .sentRequestAtMillis(sentRequestMillis)\n       .receivedResponseAtMillis(System.currentTimeMillis())\n       .build();\n\n   realChain.eventListener()\n       .responseHeadersEnd(realChain.call(), response);\n   //判断响应码，读取响应体\n   int code = response.code();\n   if (forWebSocket &amp;&amp; code == 101) {\n     // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n     response = response.newBuilder()\n         .body(Util.EMPTY_RESPONSE)\n         .build();\n   } else {\n     response = response.newBuilder()\n         .body(httpCodec.openResponseBody(response))\n         .build();\n   }\n\n   if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))\n       || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {\n     streamAllocation.noNewStreams();\n   }\n\n   if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {\n     throw new ProtocolException(\n         &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());\n   }\n\n   return response;\n }\n</code></pre><p>真个过程就是CallServerInterceptor向服务器发起真正的请求，并在接收服务器的返回后读取响应返回。</p>\n<h5 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h5><pre><code>// Call the next interceptor in the chain.\n   RealInterceptorChain next = new RealInterceptorChain(\n       interceptors, streamAllocation, httpCodec, connection, index + 1, request);\n   Interceptor interceptor = interceptors.get(index);\n   Response response = interceptor.intercept(next);\n</code></pre><p>整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。</p>\n"},{"title":"OkHttp3源码学习（4）-Dispatcher","date":"2017-07-28T07:47:24.000Z","_content":"\n### 一、基本概念\nOkHttp3 有两种运行方式：\n\n1.同步\n\n2.异步\n\n在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。\n\n* 线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.\n线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。\n\n* 多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程\n\n* 线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。\n\n了解了基本概念，就来看一下OkHttp的任务队列。\n\n从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：\n\t\n* 1.通过对线程进行缓存，减少了创建销毁的时间损失;\n\n* 2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.\n\n### 二、OkHttp请求方式\n\n* 1.同步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t\n\t\tString run(String url) throws IOException {\n\t\t  Request request = new Request.Builder()\n\t\t      .url(url)\n\t\t      .build();\n\t\t\n\t\t  Response response = client.newCall(request).execute();\n\t\t  return response.body().string();\n\t\t}\n\t\t\n* 2.异步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t        Request request = new Request.Builder()\n\t                .url(\"\")\n\t                .build();\n\t        Call call = client.newCall(request);\n\t        try {\n\t            call.enqueue(new okhttp3.Callback() {\n\t                @Override\n\t                public void onFailure(Call call, IOException e) {\n\t                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n\t                }\n\t\n\t                @Override\n\t                public void onResponse(Call call, Response response) throws IOException {\n\t                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n\t                }\n\t            });\n\t        } catch (Exception e) {\n\t            Log.e(\"OkHttp\",e.getMessage());\n\t        }\n\t        \n\t        \n* 先看同步是如何实现的。看源码\n\n  RealCall.java\n\n\t\t@Override public Response execute() throws IOException {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    try {\n\t    //执行同步请求\n\t      client.dispatcher().executed(this);\n\t      Response result = getResponseWithInterceptorChain();\n\t      if (result == null) throw new IOException(\"Canceled\");\n\t      return result;\n\t    } finally {\n\t      client.dispatcher().finished(this);\n\t    }\n\t  \t}\n  \t\n   Dispatcher.java\n\n\t\t\t /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t  synchronized void executed(RealCall call) {\n\t\t    runningSyncCalls.add(call);\n\t\t  }\n\t  \n   直接加入到运行中同步任务队列runningSyncCalls中执行即完成。\n   \n   \n* 异步请求\n\n  RealCall.java\n  \n\t    @Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\t  \t\n  也是通过Dispatcher入队。\n    \n  Dispatcher.java\n  \n\t\t   synchronized void enqueue(AsyncCall call) {\n\t\t    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t      runningAsyncCalls.add(call);\n\t\t      executorService().execute(call);\n\t\t    } else {\n\t\t      readyAsyncCalls.add(call);\n\t\t    }\n\t\t  }\n\n\t\n    根据判断条件，加到对应的队列中。(runningRequests<64 && runningRequestsPerHost<5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n    \n    AsyncCall\n    \n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t\n\t\n\t\n\t当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\t\n\t再看promoteCalls方法\n\t\n\t\tprivate void promoteCalls() {\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t      AsyncCall call = i.next();\n\t\n\t      if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n\t        i.remove();\n\t        runningAsyncCalls.add(call);\n\t        executorService().execute(call);\n\t      }\n\t\n\t      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t    }\n\t  \t}\n\t  \t\n\t 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n\t \n\t \n### 三、OkHttp任务队列\n\n   看一下Dispacher源码\n   \n\t  public final class Dispatcher {\n\t  private int maxRequests = 64;\n\t  private int maxRequestsPerHost = 5;\n\t  private @Nullable Runnable idleCallback;\n\t\n\t  /** Executes calls. Created lazily. */\n\t  private @Nullable ExecutorService executorService;\n\t\n\t  /** Ready async calls in the order they'll be run. */\n\t  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\t\n\t  public Dispatcher(ExecutorService executorService) {\n\t    this.executorService = executorService;\n\t  }\n\t\n\t  public Dispatcher() {\n\t  }\n\t\n\t  public synchronized ExecutorService executorService() {\n\t    if (executorService == null) {\n\t      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t    }\n\t    return executorService;\n\t  }\n\n\n几个重要的知识点：\n\n* readyAsyncCalls ：待执行异步任务队列\n\n* runningAsyncCalls：运行中异步任务队列\n\n* runningSyncCalls：运行中同步任务队列\n\n* executorService：任务队列线程池\n\n几种队列很好理解，再解释一下OkHttp中的队列线程池\n\n 看一下ThreadPoolExecutor.java\n \n\t  public ThreadPoolExecutor(int corePoolSize,\n\t                              int maximumPoolSize,\n\t                              long keepAliveTime,\n\t                              TimeUnit unit,\n\t                              BlockingQueue<Runnable> workQueue,\n\t                              ThreadFactory threadFactory) {\n\t        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n\t             threadFactory, defaultHandler);\n\t    }\n\t    \n解释一下这些参数的具体含义：\n\n* int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁\n\n\n* int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理\n\n\n* long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n\n\n* TimeUnit unit: 时间单位，一般用秒\n\n\n* BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列\n\n\n* ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做\"OkHttp Dispatcher\"的线程工厂。\n\n也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。\n\n\n### 四、Dispatcher\n\ndispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接\n\n![dispatcher](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png)\n\n\n### 五、总结\n\n1. OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行\n\n\n2. Okhttp采用Deque作为缓存，按照入队的顺序先进先出\n\n\n3. OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性\n\n\t \n \n\n\t\n\t\n\t","source":"_posts/OkHttp3源码学习（4）-Dispatcher.md","raw":"---\ntitle: OkHttp3源码学习（4）-Dispatcher\ndate: 2017-07-28 15:47:24\ntags: [OkHttp3]\n---\n\n### 一、基本概念\nOkHttp3 有两种运行方式：\n\n1.同步\n\n2.异步\n\n在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。\n\n* 线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。\n线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.\n线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。\n\n* 多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程\n\n* 线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。\n\n了解了基本概念，就来看一下OkHttp的任务队列。\n\n从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：\n\t\n* 1.通过对线程进行缓存，减少了创建销毁的时间损失;\n\n* 2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.\n\n### 二、OkHttp请求方式\n\n* 1.同步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t\n\t\tString run(String url) throws IOException {\n\t\t  Request request = new Request.Builder()\n\t\t      .url(url)\n\t\t      .build();\n\t\t\n\t\t  Response response = client.newCall(request).execute();\n\t\t  return response.body().string();\n\t\t}\n\t\t\n* 2.异步\n\t\n\t\tOkHttpClient client = new OkHttpClient();\n\t        Request request = new Request.Builder()\n\t                .url(\"\")\n\t                .build();\n\t        Call call = client.newCall(request);\n\t        try {\n\t            call.enqueue(new okhttp3.Callback() {\n\t                @Override\n\t                public void onFailure(Call call, IOException e) {\n\t                    Log.d(\"OkHttp\", \"Call Failed:\" + e.getMessage());\n\t                }\n\t\n\t                @Override\n\t                public void onResponse(Call call, Response response) throws IOException {\n\t                    Log.d(\"OkHttp\", \"Call succeeded:\" + response.message());\n\t                }\n\t            });\n\t        } catch (Exception e) {\n\t            Log.e(\"OkHttp\",e.getMessage());\n\t        }\n\t        \n\t        \n* 先看同步是如何实现的。看源码\n\n  RealCall.java\n\n\t\t@Override public Response execute() throws IOException {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    try {\n\t    //执行同步请求\n\t      client.dispatcher().executed(this);\n\t      Response result = getResponseWithInterceptorChain();\n\t      if (result == null) throw new IOException(\"Canceled\");\n\t      return result;\n\t    } finally {\n\t      client.dispatcher().finished(this);\n\t    }\n\t  \t}\n  \t\n   Dispatcher.java\n\n\t\t\t /** Used by {@code Call#execute} to signal it is in-flight. */\n\t\t  synchronized void executed(RealCall call) {\n\t\t    runningSyncCalls.add(call);\n\t\t  }\n\t  \n   直接加入到运行中同步任务队列runningSyncCalls中执行即完成。\n   \n   \n* 异步请求\n\n  RealCall.java\n  \n\t    @Override public void enqueue(Callback responseCallback) {\n\t    synchronized (this) {\n\t      if (executed) throw new IllegalStateException(\"Already Executed\");\n\t      executed = true;\n\t    }\n\t    captureCallStackTrace();\n\t    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n\t  \t}\n\t  \t\n  也是通过Dispatcher入队。\n    \n  Dispatcher.java\n  \n\t\t   synchronized void enqueue(AsyncCall call) {\n\t\t    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t\t      runningAsyncCalls.add(call);\n\t\t      executorService().execute(call);\n\t\t    } else {\n\t\t      readyAsyncCalls.add(call);\n\t\t    }\n\t\t  }\n\n\t\n    根据判断条件，加到对应的队列中。(runningRequests<64 && runningRequestsPerHost<5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n    \n    AsyncCall\n    \n\t    @Override protected void execute() {\n\t      boolean signalledCallback = false;\n\t      try {\n\t        Response response = getResponseWithInterceptorChain();\n\t        if (retryAndFollowUpInterceptor.isCanceled()) {\n\t          signalledCallback = true;\n\t          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t        } else {\n\t          signalledCallback = true;\n\t          responseCallback.onResponse(RealCall.this, response);\n\t        }\n\t      } catch (IOException e) {\n\t        if (signalledCallback) {\n\t          // Do not signal the callback twice!\n\t          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n\t        } else {\n\t          responseCallback.onFailure(RealCall.this, e);\n\t        }\n\t      } finally {\n\t        client.dispatcher().finished(this);\n\t      }\n\t    }\n\t\n\t\n\t\n\t当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\t\n\t再看promoteCalls方法\n\t\n\t\tprivate void promoteCalls() {\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t      AsyncCall call = i.next();\n\t\n\t      if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n\t        i.remove();\n\t        runningAsyncCalls.add(call);\n\t        executorService().execute(call);\n\t      }\n\t\n\t      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t    }\n\t  \t}\n\t  \t\n\t 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n\t \n\t \n### 三、OkHttp任务队列\n\n   看一下Dispacher源码\n   \n\t  public final class Dispatcher {\n\t  private int maxRequests = 64;\n\t  private int maxRequestsPerHost = 5;\n\t  private @Nullable Runnable idleCallback;\n\t\n\t  /** Executes calls. Created lazily. */\n\t  private @Nullable ExecutorService executorService;\n\t\n\t  /** Ready async calls in the order they'll be run. */\n\t  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\t\n\t  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n\t  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n\t\n\t  public Dispatcher(ExecutorService executorService) {\n\t    this.executorService = executorService;\n\t  }\n\t\n\t  public Dispatcher() {\n\t  }\n\t\n\t  public synchronized ExecutorService executorService() {\n\t    if (executorService == null) {\n\t      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t    }\n\t    return executorService;\n\t  }\n\n\n几个重要的知识点：\n\n* readyAsyncCalls ：待执行异步任务队列\n\n* runningAsyncCalls：运行中异步任务队列\n\n* runningSyncCalls：运行中同步任务队列\n\n* executorService：任务队列线程池\n\n几种队列很好理解，再解释一下OkHttp中的队列线程池\n\n 看一下ThreadPoolExecutor.java\n \n\t  public ThreadPoolExecutor(int corePoolSize,\n\t                              int maximumPoolSize,\n\t                              long keepAliveTime,\n\t                              TimeUnit unit,\n\t                              BlockingQueue<Runnable> workQueue,\n\t                              ThreadFactory threadFactory) {\n\t        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n\t             threadFactory, defaultHandler);\n\t    }\n\t    \n解释一下这些参数的具体含义：\n\n* int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁\n\n\n* int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理\n\n\n* long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n\n\n* TimeUnit unit: 时间单位，一般用秒\n\n\n* BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列\n\n\n* ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做\"OkHttp Dispatcher\"的线程工厂。\n\n也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。\n\n\n### 四、Dispatcher\n\ndispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接\n\n![dispatcher](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png)\n\n\n### 五、总结\n\n1. OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行\n\n\n2. Okhttp采用Deque作为缓存，按照入队的顺序先进先出\n\n\n3. OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性\n\n\t \n \n\n\t\n\t\n\t","slug":"OkHttp3源码学习（4）-Dispatcher","published":1,"updated":"2017-10-27T02:02:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphe000wv7c052h8w1hh","content":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>OkHttp3 有两种运行方式：</p>\n<p>1.同步</p>\n<p>2.异步</p>\n<p>在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。</p>\n<ul>\n<li><p>线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。<br>线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.<br>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。</p>\n</li>\n<li><p>多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程</p>\n</li>\n<li><p>线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>\n</li>\n</ul>\n<p>了解了基本概念，就来看一下OkHttp的任务队列。</p>\n<p>从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：</p>\n<ul>\n<li><p>1.通过对线程进行缓存，减少了创建销毁的时间损失;</p>\n</li>\n<li><p>2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.</p>\n</li>\n</ul>\n<h3 id=\"二、OkHttp请求方式\"><a href=\"#二、OkHttp请求方式\" class=\"headerlink\" title=\"二、OkHttp请求方式\"></a>二、OkHttp请求方式</h3><ul>\n<li><p>1.同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\n  Request request = new Request.Builder()\n      .url(url)\n      .build();\n\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>2.异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>先看同步是如何实现的。看源码</p>\n<p>RealCall.java</p>\n<pre><code>@Override public Response execute() throws IOException {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\ntry {\n//执行同步请求\n  client.dispatcher().executed(this);\n  Response result = getResponseWithInterceptorChain();\n  if (result == null) throw new IOException(&quot;Canceled&quot;);\n  return result;\n} finally {\n  client.dispatcher().finished(this);\n}\n  }\n</code></pre><p> Dispatcher.java</p>\n<pre><code>   /** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n  runningSyncCalls.add(call);\n}\n</code></pre><p> 直接加入到运行中同步任务队列runningSyncCalls中执行即完成。</p>\n</li>\n</ul>\n<ul>\n<li><p>异步请求</p>\n<p>RealCall.java</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre><p>也是通过Dispatcher入队。</p>\n<p>Dispatcher.java</p>\n<pre><code> synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n    runningAsyncCalls.add(call);\n    executorService().execute(call);\n  } else {\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>根据判断条件，加到对应的队列中。(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n\nAsyncCall\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n\n\n\n当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\n再看promoteCalls方法\n\n    private void promoteCalls() {\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n    }\n      }\n\n 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n</code></pre><h3 id=\"三、OkHttp任务队列\"><a href=\"#三、OkHttp任务队列\" class=\"headerlink\" title=\"三、OkHttp任务队列\"></a>三、OkHttp任务队列</h3><p>   看一下Dispacher源码</p>\n<pre><code>public final class Dispatcher {\nprivate int maxRequests = 64;\nprivate int maxRequestsPerHost = 5;\nprivate @Nullable Runnable idleCallback;\n\n/** Executes calls. Created lazily. */\nprivate @Nullable ExecutorService executorService;\n\n/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n\npublic Dispatcher(ExecutorService executorService) {\n  this.executorService = executorService;\n}\n\npublic Dispatcher() {\n}\n\npublic synchronized ExecutorService executorService() {\n  if (executorService == null) {\n    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n  }\n  return executorService;\n}\n</code></pre><p>几个重要的知识点：</p>\n<ul>\n<li><p>readyAsyncCalls ：待执行异步任务队列</p>\n</li>\n<li><p>runningAsyncCalls：运行中异步任务队列</p>\n</li>\n<li><p>runningSyncCalls：运行中同步任务队列</p>\n</li>\n<li><p>executorService：任务队列线程池</p>\n</li>\n</ul>\n<p>几种队列很好理解，再解释一下OkHttp中的队列线程池</p>\n<p> 看一下ThreadPoolExecutor.java</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue&lt;Runnable&gt; workQueue,\n                            ThreadFactory threadFactory) {\n      this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n           threadFactory, defaultHandler);\n  }\n</code></pre><p>解释一下这些参数的具体含义：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>\n</ul>\n<ul>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>\n</ul>\n<ul>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n</ul>\n<ul>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n</ul>\n<ul>\n<li>BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列</li>\n</ul>\n<ul>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p>\n<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>\n<h3 id=\"四、Dispatcher\"><a href=\"#四、Dispatcher\" class=\"headerlink\" title=\"四、Dispatcher\"></a>四、Dispatcher</h3><p>dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png\" alt=\"dispatcher\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><ol>\n<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行</li>\n</ol>\n<ol>\n<li>Okhttp采用Deque作为缓存，按照入队的顺序先进先出</li>\n</ol>\n<ol>\n<li>OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>OkHttp3 有两种运行方式：</p>\n<p>1.同步</p>\n<p>2.异步</p>\n<p>在了解OkHttp的任务队列原理之前，先了解一下线程、多线程、线程池的基本概念。</p>\n<ul>\n<li><p>线程：进程中负责程序执行的最小单元。每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。<br>线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.<br>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。</p>\n</li>\n<li><p>多线程：那么了解了线程，对多线程就很好理解了。指的是这个程序（一个进程）运行时产生了不止一个线程</p>\n</li>\n<li><p>线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>\n</li>\n</ul>\n<p>了解了基本概念，就来看一下OkHttp的任务队列。</p>\n<p>从上面的基本概念就可以知道，线程池的关键在于线程复用来减少非核心任务的损耗。减少创建和销毁的事件，提高效率。即：</p>\n<ul>\n<li><p>1.通过对线程进行缓存，减少了创建销毁的时间损失;</p>\n</li>\n<li><p>2.通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力.</p>\n</li>\n</ul>\n<h3 id=\"二、OkHttp请求方式\"><a href=\"#二、OkHttp请求方式\" class=\"headerlink\" title=\"二、OkHttp请求方式\"></a>二、OkHttp请求方式</h3><ul>\n<li><p>1.同步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n\nString run(String url) throws IOException {\n  Request request = new Request.Builder()\n      .url(url)\n      .build();\n\n  Response response = client.newCall(request).execute();\n  return response.body().string();\n}\n</code></pre></li>\n<li><p>2.异步</p>\n<pre><code>OkHttpClient client = new OkHttpClient();\n    Request request = new Request.Builder()\n            .url(&quot;&quot;)\n            .build();\n    Call call = client.newCall(request);\n    try {\n        call.enqueue(new okhttp3.Callback() {\n            @Override\n            public void onFailure(Call call, IOException e) {\n                Log.d(&quot;OkHttp&quot;, &quot;Call Failed:&quot; + e.getMessage());\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException {\n                Log.d(&quot;OkHttp&quot;, &quot;Call succeeded:&quot; + response.message());\n            }\n        });\n    } catch (Exception e) {\n        Log.e(&quot;OkHttp&quot;,e.getMessage());\n    }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>先看同步是如何实现的。看源码</p>\n<p>RealCall.java</p>\n<pre><code>@Override public Response execute() throws IOException {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\ntry {\n//执行同步请求\n  client.dispatcher().executed(this);\n  Response result = getResponseWithInterceptorChain();\n  if (result == null) throw new IOException(&quot;Canceled&quot;);\n  return result;\n} finally {\n  client.dispatcher().finished(this);\n}\n  }\n</code></pre><p> Dispatcher.java</p>\n<pre><code>   /** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n  runningSyncCalls.add(call);\n}\n</code></pre><p> 直接加入到运行中同步任务队列runningSyncCalls中执行即完成。</p>\n</li>\n</ul>\n<ul>\n<li><p>异步请求</p>\n<p>RealCall.java</p>\n<pre><code>@Override public void enqueue(Callback responseCallback) {\nsynchronized (this) {\n  if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);\n  executed = true;\n}\ncaptureCallStackTrace();\nclient.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n</code></pre><p>也是通过Dispatcher入队。</p>\n<p>Dispatcher.java</p>\n<pre><code> synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n    runningAsyncCalls.add(call);\n    executorService().execute(call);\n  } else {\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre></li>\n</ul>\n<pre><code>根据判断条件，加到对应的队列中。(runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。 \n\nAsyncCall\n\n    @Override protected void execute() {\n      boolean signalledCallback = false;\n      try {\n        Response response = getResponseWithInterceptorChain();\n        if (retryAndFollowUpInterceptor.isCanceled()) {\n          signalledCallback = true;\n          responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));\n        } else {\n          signalledCallback = true;\n          responseCallback.onResponse(RealCall.this, response);\n        }\n      } catch (IOException e) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);\n        } else {\n          responseCallback.onFailure(RealCall.this, e);\n        }\n      } finally {\n        client.dispatcher().finished(this);\n      }\n    }\n\n\n\n当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数\n\n再看promoteCalls方法\n\n    private void promoteCalls() {\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.\n    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\n    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n      AsyncCall call = i.next();\n\n      if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //当运行中的队列可以继续加入任务时，将缓存等待队列中的移到运行队列在合适的时机执行\n        i.remove();\n        runningAsyncCalls.add(call);\n        executorService().execute(call);\n      }\n\n      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n    }\n      }\n\n 扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。就这样把缓存队列中的任务加入到运行中的队列中执行。\n</code></pre><h3 id=\"三、OkHttp任务队列\"><a href=\"#三、OkHttp任务队列\" class=\"headerlink\" title=\"三、OkHttp任务队列\"></a>三、OkHttp任务队列</h3><p>   看一下Dispacher源码</p>\n<pre><code>public final class Dispatcher {\nprivate int maxRequests = 64;\nprivate int maxRequestsPerHost = 5;\nprivate @Nullable Runnable idleCallback;\n\n/** Executes calls. Created lazily. */\nprivate @Nullable ExecutorService executorService;\n\n/** Ready async calls in the order they&apos;ll be run. */\nprivate final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();\n\n/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */\nprivate final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();\n\npublic Dispatcher(ExecutorService executorService) {\n  this.executorService = executorService;\n}\n\npublic Dispatcher() {\n}\n\npublic synchronized ExecutorService executorService() {\n  if (executorService == null) {\n    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));\n  }\n  return executorService;\n}\n</code></pre><p>几个重要的知识点：</p>\n<ul>\n<li><p>readyAsyncCalls ：待执行异步任务队列</p>\n</li>\n<li><p>runningAsyncCalls：运行中异步任务队列</p>\n</li>\n<li><p>runningSyncCalls：运行中同步任务队列</p>\n</li>\n<li><p>executorService：任务队列线程池</p>\n</li>\n</ul>\n<p>几种队列很好理解，再解释一下OkHttp中的队列线程池</p>\n<p> 看一下ThreadPoolExecutor.java</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue&lt;Runnable&gt; workQueue,\n                            ThreadFactory threadFactory) {\n      this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n           threadFactory, defaultHandler);\n  }\n</code></pre><p>解释一下这些参数的具体含义：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>\n</ul>\n<ul>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>\n</ul>\n<ul>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n</ul>\n<ul>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n</ul>\n<ul>\n<li>BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列</li>\n</ul>\n<ul>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>也就是说在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p>\n<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>\n<h3 id=\"四、Dispatcher\"><a href=\"#四、Dispatcher\" class=\"headerlink\" title=\"四、Dispatcher\"></a>四、Dispatcher</h3><p>dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接</p>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png\" alt=\"dispatcher\"></p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><ol>\n<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行</li>\n</ol>\n<ol>\n<li>Okhttp采用Deque作为缓存，按照入队的顺序先进先出</li>\n</ol>\n<ol>\n<li>OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性</li>\n</ol>\n"},{"title":"PackageManager使用姿势","date":"2017-10-25T12:04:03.000Z","_content":"\nPackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。\n\n#### 一、主要功能\n\n1. 安装、卸载应用\n2. 查询权限\n3. 查询Application相关信息\n\n#### 二、常用方法\n\n1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：\n GET_ACTIVITIES\nGET_GIDS\nGET_CONFIGURATIONS\nGET_INSTRUMENTATION\nGET_PERMISSIONS\nGET_PROVIDERS\nGET_RECEIVERS\nGET_SERVICES\nGET_SIGNATURES\nGET_UNINSTALLED_PACKAGES\n（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids\n\n（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息\n\n（4）、public abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合\n\n（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,\n    int flags)根据指定的Group名称获取PermissionGroupInfo对象。\n\n（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,\n            int flags)，根据指定的包名获取ApplicationInfo信息。\n\n（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,\n            int flags)，根据指定的组件，获取ActivityInfo信息\n\n（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,\n            int flags)，根据指定组件获取ServiceInfo\n\n（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,\n            int flags)，根据指定组件名称获取ProviderInfo信息\n\n（10）、public abstract List<PackageInfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息\n\n（11）、public abstract List<PackageInfo> getPackagesHoldingPermissions(\n            String[] permissions, int flags);获取具有特定权限的PackagInfo\n\n（12）、public abstract List<ApplicationInfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息\n\n（13）、public abstract boolean addPermission(PermissionInfo info);添加权限\n\n（14）、public abstract void removePermission(String name);移除权限\n\n2、PackageInfo用于描述mainfest中所有描述信息。    \n常见字段：   \n（1）、public String packageName;包名    \n（2）、public String[] splitNames;   \n（3）、public int versionCode;版本号　　　　　\n（4）、public String versionName;版本名称    \n（5）、public ApplicationInfo applicationInfo;    \n（6）、public long firstInstallTime;第一次安装时间   \n（7）、public long lastUpdateTime;上次更新时间     \n（8）、public ActivityInfo[] activities;所有的Activity信息     \n（9）、public ActivityInfo[] receivers; 所有的广播接收者    \n（10）、public ServiceInfo[] services;所有的服务信息     \n（11）、public ProviderInfo[] providers;获取ContentProvide     \n（12）、public PermissionInfo[] permissions;所有的权限信息\n\n\n#### 三、AndroidManifest文件结构\n\n首先看一下AndroidManifest.xml文件结构。\n\n例如：\n\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.test\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <service\n        \tandroid:name=\"testservice\"\n        \tandroid:enable=\"true\"\n        \tandroid:exproted=\"true\">\n        \t</service>\n    </application>\n\n\t</manifest>\n\t\n\t\n\t\n\t\n根据AndroidManifest的各个节点可以看出来其中的对应关系：\n\t\n\t* 一个Package对应一个Application\n\t* 一个Application对应n个Activity、Service等等\n\n* 通过包名判断APP是否安装\n* 通过遍历获取AndroidManifest.xml文件信息\n\t\n\t\n\n\n#### 四、获取信息\n\n\n##### 1.ApplicationInfo类测试：获取Application节点信息\n\n  * 示例：\n\n\t\t\tApplicationInfo applicationInfo = getApplicationInfo();  \n\t\t\t Log.d(\"lsh\",applicationInfo.className + \"\\n\" +  \n\t\t\t        applicationInfo.dataDir+\"\\n\" +  \n\t\t\t        applicationInfo.permission + \"\\n\"  \n\t\t\t        + applicationInfo.packageName + \"\\n\"  \n\t\t\t        + applicationInfo.processName + \"\\n\"  \n\t\t\t        + applicationInfo.taskAffinity + \"\\n\"  \n\t\t\t);  \n\t\n\n * Logcat:\n\n\t\t\t3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n\t\t\t    /data/data/com.example.liushihan.glidedemo\n\t\t\t    null\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \t\n##### 2. 获取所有安装的Packages\n\n  * 示例：\n\n\t\t\tList<PackageInfo> listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n\n\n   * Logcat:\n   部分日志\n\n\t\t\t D/lsh: PackageInfo{132b54a7 com.android.smoketest}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n\t\t\t\n\t\t\t\n\t\t\t\n##### 3. 获取指定应用的PackageInfo\n\n * 示例：\n\n\t\t\tPackageManager packageManager = getPackageManager();\n\t\t\t        PackageInfo packageInfo = null;\n\t\t\t        try {\n\t\t\t            packageInfo = packageManager.getPackageInfo(\"com.example.liushihan\",\n\t\t\t                    PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh\", packageInfo.packageName + \"\\n\"\n\t\t\t                    + packageInfo.versionName + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n * Logcat\n\n\t\t\t D/lsh: com.example.liushihan.glidedemo\n\t\t\t                             1.0\n\t\t\t                             \n\t\t\t                             \n\t\t\t       \n##### 4. 获取应用程序中的permission\n\n * 示例：\n\n\t\t\t   try {\n\t\t\t            PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(\"android.permission.INTERNET\",\n\t\t\t                    PermissionInfo.PROTECTION_NORMAL);\n\t\t\t            List<PermissionGroupInfo> list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n\t\t\t            Log.d(\"lsh\",\n\t\t\t                    permissionInfo.group + \"\\n\"\n\t\t\t                            + permissionInfo.packageName + \"\\n\"\n\t\t\t                            + permissionInfo.name + \"\\n\"\n\t\t\t                            + permissionInfo.flags + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n   * Logcat:\n\n\t\t    D/lsh: android.permission-group.NETWORK\n\t\t                                      android\n\t\t                                      android.permission.INTERNET\n\t\t                                      0\n\t\t                                      \n                  \n                  \n##### 5. 获取应用程序中执行的ActivityInfo\n\n * 示例：\n\n\n\t\t\tComponentName componentName = new ComponentName(\"com.example.liushihan.glidedemo\",\"com.example.liushihan.glidedemo.MainActivity\");\n\t\t\t        try {\n\t\t\t            @SuppressLint(\"WrongConstant\") ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh:activityInfo\",activityInfo.name + \"\\n\"\n\t\t\t                    + activityInfo.packageName +\"\\n\"\n\t\t\t                    + activityInfo.targetActivity\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }  \n\t\t        \n\t\t        \n * Logcat:\n\n\t\t\t\n\t\t\t4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n\t\t\t                                                                                 com.example.liushihan.glidedemo\n\t\t\t                                                                                 null\n\t\t                                                                                 \n\t\t                                                                                 ","source":"_posts/PackageManager使用姿势.md","raw":"---\ntitle: PackageManager使用姿势\ndate: 2017-10-25 20:04:03\ntags: [PackageManager]\n---\n\nPackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。\n\n#### 一、主要功能\n\n1. 安装、卸载应用\n2. 查询权限\n3. 查询Application相关信息\n\n#### 二、常用方法\n\n1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：\n GET_ACTIVITIES\nGET_GIDS\nGET_CONFIGURATIONS\nGET_INSTRUMENTATION\nGET_PERMISSIONS\nGET_PROVIDERS\nGET_RECEIVERS\nGET_SERVICES\nGET_SIGNATURES\nGET_UNINSTALLED_PACKAGES\n（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids\n\n（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息\n\n（4）、public abstract List<PermissionGroupInfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合\n\n（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,\n    int flags)根据指定的Group名称获取PermissionGroupInfo对象。\n\n（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,\n            int flags)，根据指定的包名获取ApplicationInfo信息。\n\n（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,\n            int flags)，根据指定的组件，获取ActivityInfo信息\n\n（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,\n            int flags)，根据指定组件获取ServiceInfo\n\n（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,\n            int flags)，根据指定组件名称获取ProviderInfo信息\n\n（10）、public abstract List<PackageInfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息\n\n（11）、public abstract List<PackageInfo> getPackagesHoldingPermissions(\n            String[] permissions, int flags);获取具有特定权限的PackagInfo\n\n（12）、public abstract List<ApplicationInfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息\n\n（13）、public abstract boolean addPermission(PermissionInfo info);添加权限\n\n（14）、public abstract void removePermission(String name);移除权限\n\n2、PackageInfo用于描述mainfest中所有描述信息。    \n常见字段：   \n（1）、public String packageName;包名    \n（2）、public String[] splitNames;   \n（3）、public int versionCode;版本号　　　　　\n（4）、public String versionName;版本名称    \n（5）、public ApplicationInfo applicationInfo;    \n（6）、public long firstInstallTime;第一次安装时间   \n（7）、public long lastUpdateTime;上次更新时间     \n（8）、public ActivityInfo[] activities;所有的Activity信息     \n（9）、public ActivityInfo[] receivers; 所有的广播接收者    \n（10）、public ServiceInfo[] services;所有的服务信息     \n（11）、public ProviderInfo[] providers;获取ContentProvide     \n（12）、public PermissionInfo[] permissions;所有的权限信息\n\n\n#### 三、AndroidManifest文件结构\n\n首先看一下AndroidManifest.xml文件结构。\n\n例如：\n\n\t<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t    package=\"com.example.test\">\n\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n        <activity android:name=\".TestActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <service\n        \tandroid:name=\"testservice\"\n        \tandroid:enable=\"true\"\n        \tandroid:exproted=\"true\">\n        \t</service>\n    </application>\n\n\t</manifest>\n\t\n\t\n\t\n\t\n根据AndroidManifest的各个节点可以看出来其中的对应关系：\n\t\n\t* 一个Package对应一个Application\n\t* 一个Application对应n个Activity、Service等等\n\n* 通过包名判断APP是否安装\n* 通过遍历获取AndroidManifest.xml文件信息\n\t\n\t\n\n\n#### 四、获取信息\n\n\n##### 1.ApplicationInfo类测试：获取Application节点信息\n\n  * 示例：\n\n\t\t\tApplicationInfo applicationInfo = getApplicationInfo();  \n\t\t\t Log.d(\"lsh\",applicationInfo.className + \"\\n\" +  \n\t\t\t        applicationInfo.dataDir+\"\\n\" +  \n\t\t\t        applicationInfo.permission + \"\\n\"  \n\t\t\t        + applicationInfo.packageName + \"\\n\"  \n\t\t\t        + applicationInfo.processName + \"\\n\"  \n\t\t\t        + applicationInfo.taskAffinity + \"\\n\"  \n\t\t\t);  \n\t\n\n * Logcat:\n\n\t\t\t3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n\t\t\t    /data/data/com.example.liushihan.glidedemo\n\t\t\t    null\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \tcom.example.liushihan.glidedemo\n\t\t\t \t\n##### 2. 获取所有安装的Packages\n\n  * 示例：\n\n\t\t\tList<PackageInfo> listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n\n\n   * Logcat:\n   部分日志\n\n\t\t\t D/lsh: PackageInfo{132b54a7 com.android.smoketest}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\n\t\t\tcom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n\t\t\t\n\t\t\t\n\t\t\t\n##### 3. 获取指定应用的PackageInfo\n\n * 示例：\n\n\t\t\tPackageManager packageManager = getPackageManager();\n\t\t\t        PackageInfo packageInfo = null;\n\t\t\t        try {\n\t\t\t            packageInfo = packageManager.getPackageInfo(\"com.example.liushihan\",\n\t\t\t                    PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh\", packageInfo.packageName + \"\\n\"\n\t\t\t                    + packageInfo.versionName + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n * Logcat\n\n\t\t\t D/lsh: com.example.liushihan.glidedemo\n\t\t\t                             1.0\n\t\t\t                             \n\t\t\t                             \n\t\t\t       \n##### 4. 获取应用程序中的permission\n\n * 示例：\n\n\t\t\t   try {\n\t\t\t            PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(\"android.permission.INTERNET\",\n\t\t\t                    PermissionInfo.PROTECTION_NORMAL);\n\t\t\t            List<PermissionGroupInfo> list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n\t\t\t            Log.d(\"lsh\",\n\t\t\t                    permissionInfo.group + \"\\n\"\n\t\t\t                            + permissionInfo.packageName + \"\\n\"\n\t\t\t                            + permissionInfo.name + \"\\n\"\n\t\t\t                            + permissionInfo.flags + \"\\n\"\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }\n\t\t\t        \n\t\t\t        \n   * Logcat:\n\n\t\t    D/lsh: android.permission-group.NETWORK\n\t\t                                      android\n\t\t                                      android.permission.INTERNET\n\t\t                                      0\n\t\t                                      \n                  \n                  \n##### 5. 获取应用程序中执行的ActivityInfo\n\n * 示例：\n\n\n\t\t\tComponentName componentName = new ComponentName(\"com.example.liushihan.glidedemo\",\"com.example.liushihan.glidedemo.MainActivity\");\n\t\t\t        try {\n\t\t\t            @SuppressLint(\"WrongConstant\") ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n\t\t\t            Log.d(\"lsh:activityInfo\",activityInfo.name + \"\\n\"\n\t\t\t                    + activityInfo.packageName +\"\\n\"\n\t\t\t                    + activityInfo.targetActivity\n\t\t\t            );\n\t\t\t        } catch (PackageManager.NameNotFoundException e) {\n\t\t\t            e.printStackTrace();\n\t\t\t        }  \n\t\t        \n\t\t        \n * Logcat:\n\n\t\t\t\n\t\t\t4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n\t\t\t                                                                                 com.example.liushihan.glidedemo\n\t\t\t                                                                                 null\n\t\t                                                                                 \n\t\t                                                                                 ","slug":"PackageManager使用姿势","published":1,"updated":"2017-12-30T06:29:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphf000yv7c01uge6yic","content":"<p>PackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。</p>\n<h4 id=\"一、主要功能\"><a href=\"#一、主要功能\" class=\"headerlink\" title=\"一、主要功能\"></a>一、主要功能</h4><ol>\n<li>安装、卸载应用</li>\n<li>查询权限</li>\n<li>查询Application相关信息</li>\n</ol>\n<h4 id=\"二、常用方法\"><a href=\"#二、常用方法\" class=\"headerlink\" title=\"二、常用方法\"></a>二、常用方法</h4><p>1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：<br> GET_ACTIVITIES<br>GET_GIDS<br>GET_CONFIGURATIONS<br>GET_INSTRUMENTATION<br>GET_PERMISSIONS<br>GET_PROVIDERS<br>GET_RECEIVERS<br>GET_SERVICES<br>GET_SIGNATURES<br>GET_UNINSTALLED_PACKAGES<br>（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids</p>\n<p>（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息</p>\n<p>（4）、public abstract List<permissiongroupinfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合</permissiongroupinfo></p>\n<p>（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,<br>    int flags)根据指定的Group名称获取PermissionGroupInfo对象。</p>\n<p>（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,<br>            int flags)，根据指定的包名获取ApplicationInfo信息。</p>\n<p>（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,<br>            int flags)，根据指定的组件，获取ActivityInfo信息</p>\n<p>（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,<br>            int flags)，根据指定组件获取ServiceInfo</p>\n<p>（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,<br>            int flags)，根据指定组件名称获取ProviderInfo信息</p>\n<p>（10）、public abstract List<packageinfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息</packageinfo></p>\n<p>（11）、public abstract List<packageinfo> getPackagesHoldingPermissions(<br>            String[] permissions, int flags);获取具有特定权限的PackagInfo</packageinfo></p>\n<p>（12）、public abstract List<applicationinfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息</applicationinfo></p>\n<p>（13）、public abstract boolean addPermission(PermissionInfo info);添加权限</p>\n<p>（14）、public abstract void removePermission(String name);移除权限</p>\n<p>2、PackageInfo用于描述mainfest中所有描述信息。<br>常见字段：<br>（1）、public String packageName;包名<br>（2）、public String[] splitNames;<br>（3）、public int versionCode;版本号　　　　　<br>（4）、public String versionName;版本名称<br>（5）、public ApplicationInfo applicationInfo;<br>（6）、public long firstInstallTime;第一次安装时间<br>（7）、public long lastUpdateTime;上次更新时间<br>（8）、public ActivityInfo[] activities;所有的Activity信息<br>（9）、public ActivityInfo[] receivers; 所有的广播接收者<br>（10）、public ServiceInfo[] services;所有的服务信息<br>（11）、public ProviderInfo[] providers;获取ContentProvide<br>（12）、public PermissionInfo[] permissions;所有的权限信息</p>\n<h4 id=\"三、AndroidManifest文件结构\"><a href=\"#三、AndroidManifest文件结构\" class=\"headerlink\" title=\"三、AndroidManifest文件结构\"></a>三、AndroidManifest文件结构</h4><p>首先看一下AndroidManifest.xml文件结构。</p>\n<p>例如：</p>\n<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.test&quot;&gt;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n&lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@mipmap/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n    android:supportsRtl=&quot;true&quot;\n    android:theme=&quot;@style/AppTheme&quot;&gt;\n    &lt;activity android:name=&quot;.TestActivity&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n    &lt;service\n        android:name=&quot;testservice&quot;\n        android:enable=&quot;true&quot;\n        android:exproted=&quot;true&quot;&gt;\n        &lt;/service&gt;\n&lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre><p>根据AndroidManifest的各个节点可以看出来其中的对应关系：</p>\n<pre><code>* 一个Package对应一个Application\n* 一个Application对应n个Activity、Service等等\n</code></pre><ul>\n<li>通过包名判断APP是否安装</li>\n<li>通过遍历获取AndroidManifest.xml文件信息</li>\n</ul>\n<h4 id=\"四、获取信息\"><a href=\"#四、获取信息\" class=\"headerlink\" title=\"四、获取信息\"></a>四、获取信息</h4><h5 id=\"1-ApplicationInfo类测试：获取Application节点信息\"><a href=\"#1-ApplicationInfo类测试：获取Application节点信息\" class=\"headerlink\" title=\"1.ApplicationInfo类测试：获取Application节点信息\"></a>1.ApplicationInfo类测试：获取Application节点信息</h5><ul>\n<li><p>示例：</p>\n<pre><code>ApplicationInfo applicationInfo = getApplicationInfo();  \n Log.d(&quot;lsh&quot;,applicationInfo.className + &quot;\\n&quot; +  \n        applicationInfo.dataDir+&quot;\\n&quot; +  \n        applicationInfo.permission + &quot;\\n&quot;  \n        + applicationInfo.packageName + &quot;\\n&quot;  \n        + applicationInfo.processName + &quot;\\n&quot;  \n        + applicationInfo.taskAffinity + &quot;\\n&quot;  \n);  \n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n    /data/data/com.example.liushihan.glidedemo\n    null\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n</code></pre></li>\n</ul>\n<h5 id=\"2-获取所有安装的Packages\"><a href=\"#2-获取所有安装的Packages\" class=\"headerlink\" title=\"2. 获取所有安装的Packages\"></a>2. 获取所有安装的Packages</h5><ul>\n<li><p>示例：</p>\n<pre><code>List&lt;PackageInfo&gt; listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:<br>部分日志</p>\n<pre><code> D/lsh: PackageInfo{132b54a7 com.android.smoketest}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n</code></pre></li>\n</ul>\n<h5 id=\"3-获取指定应用的PackageInfo\"><a href=\"#3-获取指定应用的PackageInfo\" class=\"headerlink\" title=\"3. 获取指定应用的PackageInfo\"></a>3. 获取指定应用的PackageInfo</h5><ul>\n<li><p>示例：</p>\n<pre><code>PackageManager packageManager = getPackageManager();\n        PackageInfo packageInfo = null;\n        try {\n            packageInfo = packageManager.getPackageInfo(&quot;com.example.liushihan&quot;,\n                    PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh&quot;, packageInfo.packageName + &quot;\\n&quot;\n                    + packageInfo.versionName + &quot;\\n&quot;\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat</p>\n<pre><code>D/lsh: com.example.liushihan.glidedemo\n                            1.0\n</code></pre></li>\n</ul>\n<h5 id=\"4-获取应用程序中的permission\"><a href=\"#4-获取应用程序中的permission\" class=\"headerlink\" title=\"4. 获取应用程序中的permission\"></a>4. 获取应用程序中的permission</h5><ul>\n<li><p>示例：</p>\n<pre><code>try {\n         PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(&quot;android.permission.INTERNET&quot;,\n                 PermissionInfo.PROTECTION_NORMAL);\n         List&lt;PermissionGroupInfo&gt; list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n         Log.d(&quot;lsh&quot;,\n                 permissionInfo.group + &quot;\\n&quot;\n                         + permissionInfo.packageName + &quot;\\n&quot;\n                         + permissionInfo.name + &quot;\\n&quot;\n                         + permissionInfo.flags + &quot;\\n&quot;\n         );\n     } catch (PackageManager.NameNotFoundException e) {\n         e.printStackTrace();\n     }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>D/lsh: android.permission-group.NETWORK\n                                  android\n                                  android.permission.INTERNET\n                                  0\n</code></pre></li>\n</ul>\n<h5 id=\"5-获取应用程序中执行的ActivityInfo\"><a href=\"#5-获取应用程序中执行的ActivityInfo\" class=\"headerlink\" title=\"5. 获取应用程序中执行的ActivityInfo\"></a>5. 获取应用程序中执行的ActivityInfo</h5><ul>\n<li>示例：</li>\n</ul>\n<pre><code>ComponentName componentName = new ComponentName(&quot;com.example.liushihan.glidedemo&quot;,&quot;com.example.liushihan.glidedemo.MainActivity&quot;);\n        try {\n            @SuppressLint(&quot;WrongConstant&quot;) ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh:activityInfo&quot;,activityInfo.name + &quot;\\n&quot;\n                    + activityInfo.packageName +&quot;\\n&quot;\n                    + activityInfo.targetActivity\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }  \n</code></pre><ul>\n<li>Logcat:</li>\n</ul>\n<pre><code>4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n                                                                                 com.example.liushihan.glidedemo\n                                                                                 null\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>PackageManager它的主要职责是管理应用程序包。 通过PackageManager，我们就可以获取应用程序信息。</p>\n<h4 id=\"一、主要功能\"><a href=\"#一、主要功能\" class=\"headerlink\" title=\"一、主要功能\"></a>一、主要功能</h4><ol>\n<li>安装、卸载应用</li>\n<li>查询权限</li>\n<li>查询Application相关信息</li>\n</ol>\n<h4 id=\"二、常用方法\"><a href=\"#二、常用方法\" class=\"headerlink\" title=\"二、常用方法\"></a>二、常用方法</h4><p>1）、public abstract PackageInfo getPackageInfo(String packageName, int flags)根据包名获取对应的PackageInfo，注意，此处的flags标签：<br> GET_ACTIVITIES<br>GET_GIDS<br>GET_CONFIGURATIONS<br>GET_INSTRUMENTATION<br>GET_PERMISSIONS<br>GET_PROVIDERS<br>GET_RECEIVERS<br>GET_SERVICES<br>GET_SIGNATURES<br>GET_UNINSTALLED_PACKAGES<br>（2）、public abstract int[] getPackageGids(String packageName)，根据包名获取group-ids</p>\n<p>（3）、public abstract PermissionInfo getPermissionInfo(String name, int flags)，根据包名和指定的flags获取指定的授权信息</p>\n<p>（4）、public abstract List<permissiongroupinfo> getAllPermissionGroups(int flags);获取所以PermissGroup集合</permissiongroupinfo></p>\n<p>（5）、public abstract PermissionGroupInfo getPermissionGroupInfo(String name,<br>    int flags)根据指定的Group名称获取PermissionGroupInfo对象。</p>\n<p>（6）、public abstract ApplicationInfo getApplicationInfo(String packageName,<br>            int flags)，根据指定的包名获取ApplicationInfo信息。</p>\n<p>（7）、public abstract ActivityInfo getActivityInfo(ComponentName component,<br>            int flags)，根据指定的组件，获取ActivityInfo信息</p>\n<p>（8）、public abstract ServiceInfo getServiceInfo(ComponentName component,<br>            int flags)，根据指定组件获取ServiceInfo</p>\n<p>（9）、public abstract ProviderInfo getProviderInfo(ComponentName component,<br>            int flags)，根据指定组件名称获取ProviderInfo信息</p>\n<p>（10）、public abstract List<packageinfo> getInstalledPackages(int flags);获取所有安装的PackagInfo信息</packageinfo></p>\n<p>（11）、public abstract List<packageinfo> getPackagesHoldingPermissions(<br>            String[] permissions, int flags);获取具有特定权限的PackagInfo</packageinfo></p>\n<p>（12）、public abstract List<applicationinfo> getInstalledApplications(int flags);获取安装的ApplicationInfo信息</applicationinfo></p>\n<p>（13）、public abstract boolean addPermission(PermissionInfo info);添加权限</p>\n<p>（14）、public abstract void removePermission(String name);移除权限</p>\n<p>2、PackageInfo用于描述mainfest中所有描述信息。<br>常见字段：<br>（1）、public String packageName;包名<br>（2）、public String[] splitNames;<br>（3）、public int versionCode;版本号　　　　　<br>（4）、public String versionName;版本名称<br>（5）、public ApplicationInfo applicationInfo;<br>（6）、public long firstInstallTime;第一次安装时间<br>（7）、public long lastUpdateTime;上次更新时间<br>（8）、public ActivityInfo[] activities;所有的Activity信息<br>（9）、public ActivityInfo[] receivers; 所有的广播接收者<br>（10）、public ServiceInfo[] services;所有的服务信息<br>（11）、public ProviderInfo[] providers;获取ContentProvide<br>（12）、public PermissionInfo[] permissions;所有的权限信息</p>\n<h4 id=\"三、AndroidManifest文件结构\"><a href=\"#三、AndroidManifest文件结构\" class=\"headerlink\" title=\"三、AndroidManifest文件结构\"></a>三、AndroidManifest文件结构</h4><p>首先看一下AndroidManifest.xml文件结构。</p>\n<p>例如：</p>\n<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    package=&quot;com.example.test&quot;&gt;\n\n&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;\n\n&lt;application\n    android:allowBackup=&quot;true&quot;\n    android:icon=&quot;@mipmap/ic_launcher&quot;\n    android:label=&quot;@string/app_name&quot;\n    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;\n    android:supportsRtl=&quot;true&quot;\n    android:theme=&quot;@style/AppTheme&quot;&gt;\n    &lt;activity android:name=&quot;.TestActivity&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;\n\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n    &lt;service\n        android:name=&quot;testservice&quot;\n        android:enable=&quot;true&quot;\n        android:exproted=&quot;true&quot;&gt;\n        &lt;/service&gt;\n&lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre><p>根据AndroidManifest的各个节点可以看出来其中的对应关系：</p>\n<pre><code>* 一个Package对应一个Application\n* 一个Application对应n个Activity、Service等等\n</code></pre><ul>\n<li>通过包名判断APP是否安装</li>\n<li>通过遍历获取AndroidManifest.xml文件信息</li>\n</ul>\n<h4 id=\"四、获取信息\"><a href=\"#四、获取信息\" class=\"headerlink\" title=\"四、获取信息\"></a>四、获取信息</h4><h5 id=\"1-ApplicationInfo类测试：获取Application节点信息\"><a href=\"#1-ApplicationInfo类测试：获取Application节点信息\" class=\"headerlink\" title=\"1.ApplicationInfo类测试：获取Application节点信息\"></a>1.ApplicationInfo类测试：获取Application节点信息</h5><ul>\n<li><p>示例：</p>\n<pre><code>ApplicationInfo applicationInfo = getApplicationInfo();  \n Log.d(&quot;lsh&quot;,applicationInfo.className + &quot;\\n&quot; +  \n        applicationInfo.dataDir+&quot;\\n&quot; +  \n        applicationInfo.permission + &quot;\\n&quot;  \n        + applicationInfo.packageName + &quot;\\n&quot;  \n        + applicationInfo.processName + &quot;\\n&quot;  \n        + applicationInfo.taskAffinity + &quot;\\n&quot;  \n);  \n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>3402-3402/com.example.liushihan.glidedemo D/lsh: null                                                 \n    /data/data/com.example.liushihan.glidedemo\n    null\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n     com.example.liushihan.glidedemo\n</code></pre></li>\n</ul>\n<h5 id=\"2-获取所有安装的Packages\"><a href=\"#2-获取所有安装的Packages\" class=\"headerlink\" title=\"2. 获取所有安装的Packages\"></a>2. 获取所有安装的Packages</h5><ul>\n<li><p>示例：</p>\n<pre><code>List&lt;PackageInfo&gt; listPack = getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES);\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:<br>部分日志</p>\n<pre><code> D/lsh: PackageInfo{132b54a7 com.android.smoketest}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{3d681d54 com.example.android.livecubes}\ncom.example.liushihan.glidedemo D/lsh: PackageInfo{213c44fd com.android.providers.telephony}\n</code></pre></li>\n</ul>\n<h5 id=\"3-获取指定应用的PackageInfo\"><a href=\"#3-获取指定应用的PackageInfo\" class=\"headerlink\" title=\"3. 获取指定应用的PackageInfo\"></a>3. 获取指定应用的PackageInfo</h5><ul>\n<li><p>示例：</p>\n<pre><code>PackageManager packageManager = getPackageManager();\n        PackageInfo packageInfo = null;\n        try {\n            packageInfo = packageManager.getPackageInfo(&quot;com.example.liushihan&quot;,\n                    PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh&quot;, packageInfo.packageName + &quot;\\n&quot;\n                    + packageInfo.versionName + &quot;\\n&quot;\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat</p>\n<pre><code>D/lsh: com.example.liushihan.glidedemo\n                            1.0\n</code></pre></li>\n</ul>\n<h5 id=\"4-获取应用程序中的permission\"><a href=\"#4-获取应用程序中的permission\" class=\"headerlink\" title=\"4. 获取应用程序中的permission\"></a>4. 获取应用程序中的permission</h5><ul>\n<li><p>示例：</p>\n<pre><code>try {\n         PermissionInfo permissionInfo = getPackageManager().getPermissionInfo(&quot;android.permission.INTERNET&quot;,\n                 PermissionInfo.PROTECTION_NORMAL);\n         List&lt;PermissionGroupInfo&gt; list = getPackageManager().getAllPermissionGroups(PackageManager.PERMISSION_GRANTED);\n         Log.d(&quot;lsh&quot;,\n                 permissionInfo.group + &quot;\\n&quot;\n                         + permissionInfo.packageName + &quot;\\n&quot;\n                         + permissionInfo.name + &quot;\\n&quot;\n                         + permissionInfo.flags + &quot;\\n&quot;\n         );\n     } catch (PackageManager.NameNotFoundException e) {\n         e.printStackTrace();\n     }\n</code></pre></li>\n</ul>\n<ul>\n<li><p>Logcat:</p>\n<pre><code>D/lsh: android.permission-group.NETWORK\n                                  android\n                                  android.permission.INTERNET\n                                  0\n</code></pre></li>\n</ul>\n<h5 id=\"5-获取应用程序中执行的ActivityInfo\"><a href=\"#5-获取应用程序中执行的ActivityInfo\" class=\"headerlink\" title=\"5. 获取应用程序中执行的ActivityInfo\"></a>5. 获取应用程序中执行的ActivityInfo</h5><ul>\n<li>示例：</li>\n</ul>\n<pre><code>ComponentName componentName = new ComponentName(&quot;com.example.liushihan.glidedemo&quot;,&quot;com.example.liushihan.glidedemo.MainActivity&quot;);\n        try {\n            @SuppressLint(&quot;WrongConstant&quot;) ActivityInfo activityInfo = getPackageManager().getActivityInfo(componentName, PackageManager.GET_ACTIVITIES);\n            Log.d(&quot;lsh:activityInfo&quot;,activityInfo.name + &quot;\\n&quot;\n                    + activityInfo.packageName +&quot;\\n&quot;\n                    + activityInfo.targetActivity\n            );\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }  \n</code></pre><ul>\n<li>Logcat:</li>\n</ul>\n<pre><code>4829-4829/com.example.liushihan.glidedemo D/lsh:activityInfo: com.example.liushihan.glidedemo.MainActivity\n                                                                                 com.example.liushihan.glidedemo\n                                                                                 null\n</code></pre>"},{"title":"RxJava2.0(一)基本使用","date":"2017-08-10T11:16:59.000Z","_content":"\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","source":"_posts/RxJava2-0-一.md","raw":"---\ntitle: RxJava2.0(一)基本使用\ndate: 2017-08-10 19:16:59\ntags: [RxJava]\n---\n\n#### RxJava2.0(一)\n\n--\n\n一、基本概念\n\t\n官方介绍：\n\tRxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。\n\t\n简单来说，就是异步，观察者模式。\n\n* 首先需要了解几个概念\n\t* Observable 被观察者，即数据发射源\n\t* Observer 观察者，即数据接收源\n\t* subscribe 订阅，即将数据发射源和接收源相关联\n\n二、基本使用\n\n了解了基本概念，开始基本使用。\n\n写一个测试用例：\n\t\n\t/**\n     * RxJava基本使用\n     */\n    @Test\n    public void testRxJava() throws Exception {\n        Observable<String> observable = new Observable<String>() {\n            @Override\n            protected void subscribeActual(Observer<? super String> observer) {\n                observer.onNext(\"1\");\n            }\n        };\n        Observer<String> observer = new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer:\"+s);\n\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        };\n        observable.subscribe(observer);\n    }\n    \n    \n  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。\n  \n  简化上述操作，就是RxJava比较好的链式操作。\n  \t\n  \t/**\n     * RxJava链式基本操作\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testObservable1() throws Exception {\n        Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"hello\");\n                e.onComplete();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Observer Receive:\" + s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n\n\n三、简单介绍用法\n\n* 发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。\n* 上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。\n* onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。\n\n\n\n","slug":"RxJava2-0-一","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphf0010v7c0k3udnoy3","content":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"RxJava2-0-一\"><a href=\"#RxJava2-0-一\" class=\"headerlink\" title=\"RxJava2.0(一)\"></a>RxJava2.0(一)</h4><p>–</p>\n<p>一、基本概念</p>\n<p>官方介绍：<br>    RxJava是Reactive Extensions的Java VM实现：用于通过使用observable序列来组合异步和基于事件的程序的库。</p>\n<p>简单来说，就是异步，观察者模式。</p>\n<ul>\n<li>首先需要了解几个概念<ul>\n<li>Observable 被观察者，即数据发射源</li>\n<li>Observer 观察者，即数据接收源</li>\n<li>subscribe 订阅，即将数据发射源和接收源相关联</li>\n</ul>\n</li>\n</ul>\n<p>二、基本使用</p>\n<p>了解了基本概念，开始基本使用。</p>\n<p>写一个测试用例：</p>\n<pre><code>/**\n * RxJava基本使用\n */\n@Test\npublic void testRxJava() throws Exception {\n    Observable&lt;String&gt; observable = new Observable&lt;String&gt;() {\n        @Override\n        protected void subscribeActual(Observer&lt;? super String&gt; observer) {\n            observer.onNext(&quot;1&quot;);\n        }\n    };\n    Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer:&quot;+s);\n\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    };\n    observable.subscribe(observer);\n}\n</code></pre><p>  从上面的例子可以看到很简单的，发射源Observable发射数据，接收源Observer接收数据，通过subscribe将发射源和接收源相关联。订阅后才会开始发射数据。</p>\n<p>  简化上述操作，就是RxJava比较好的链式操作。</p>\n<pre><code>  /**\n * RxJava链式基本操作\n *\n * @throws Exception\n */\n@Test\npublic void testObservable1() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;hello&quot;);\n            e.onComplete();\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Observer Receive:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>三、简单介绍用法</p>\n<ul>\n<li>发射源，通过ObservableEmitter发射数据。Emitter的意思是发射器，这个就是用来发出事件的，它可以发出三种类型的事件，通过调用emitter的onNext(T value)、onComplete()和onError(Throwable error)就可以分别发出next事件、complete事件和error事件。</li>\n<li>上游可以发射无数个onNext事件，当发射onComplete()事件后，下游不再接收上游发送的数据，但是上游还是可以继续发送数据的。</li>\n<li>onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError。这一点很重要。</li>\n</ul>\n"},{"title":"RxJava2.0(三)操作符简介","date":"2017-08-12T07:58:33.000Z","_content":"\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n### 变换操作\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\t@Test\n    public void testConcat() throws Exception {\n        final Observable<String> factory = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"卫龙\");\n                e.onComplete();\n            }\n        });\n\n        Observable<String> price = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"5\");\n                e.onComplete();\n            }\n        });\n        Observable<String> material = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"chili\");\n                e.onComplete();\n            }\n        });\n\n        Observable.concat(factory, price,material).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"result\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n结果为：\n\n\tresult：卫龙\n\tresult：5\n\tresult：chili\n\t\n就拿到了辣条的所有信息了。\n\n\n\n### 过滤操作\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n\n\n\n\n\n\n\n\n","source":"_posts/RxJava2-0-三-变换操作.md","raw":"---\ntitle: RxJava2.0(三)操作符简介\ndate: 2017-08-12 15:58:33\ntags: [RxJava]\n---\n\n了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方--变换操作。\n\nRxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。\n\n### 变换操作\n\n#### 一、map\n\n\n返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。\n\n一对一的变换，如下图（来源：官方文档）\n\n![map](http://ot29getcp.bkt.clouddn.com/images/map.png)\n\t\n\t\t@Test\n\t    public void testMap() throws Exception {\n\t        Observable.create(new ObservableOnSubscribe<String>() {\n\t            @Override\n\t            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n\t                e.onNext(\"map\");\n\t            }\n\t        }).map(new Function<String, Integer>() {\n\t            @Override\n\t            public Integer apply(@NonNull String s) throws Exception {\n\t                return getValue(s);\n\t            }\n\t        }).subscribe(new Observer<Integer>() {\n\t            @Override\n\t            public void onSubscribe(@NonNull Disposable d) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onNext(@NonNull Integer s) {\n\t                System.out.println(\"testMap:\" + s);\n\t            }\n\t\n\t            @Override\n\t            public void onError(@NonNull Throwable e) {\n\t\n\t            }\n\t\n\t            @Override\n\t            public void onComplete() {\n\t\n\t            }\n\t        });\n\t    }\n\t    \n从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。\n\n* 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化\n\n* map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合\n\n#### 二、flatmap\n\n\t\n更加高级的变换。如图（来源：官方文档）\n\t\n![flatmap](http://ot29getcp.bkt.clouddn.com/images/flatMap.png)\n\t\n\t\n* 一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。\n\n* flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。\n\n\nFor Example：\n\n\t @Test\n    public void testRxFlatMap() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(99);\n                e.onNext(66);\n                e.onComplete();\n            }\n        }).flatMap(new Function<Integer, ObservableSource<String>>() {\n            @Override\n            public ObservableSource<String> apply(@NonNull Integer s) throws Exception {\n                if (s>80){\n                    return Observable.just(\"A\");\n                }\n                return Observable.just(\"B\");\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"成绩为：\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n    \n  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。\n  \n \n \n \n#### 三、concatMap\n\n* 官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。\n\n通俗一点，就是和flatmap相比，concatMap是有序的。\n\n\n![concatmap](http://ot29getcp.bkt.clouddn.com/images/concatMap.png)\n\n\n\n#### 四、zip\n\n返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。\n\nzip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。\n\n来看一个简单的例子，加深理解。\n\n\t/**\n     * RxJava zip变换\n     * @throws Exception\n     */\n    @Test\n    public void testZip() throws Exception {\n        Observable<String> observableHello = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"Hello\");\n            }\n        });\n        Observable<String> observableWorld = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"World\");\n            }\n        });\n        Observable.zip(observableHello, observableWorld, new BiFunction<String, String, String>() {\n            @Override\n            public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n                return s+s2;\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"Final:\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。\n\n#### 五、concat\n\nConcatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.\n\n简单来说就是将多个数据源按序发射。\n\n![concat](http://ot29getcp.bkt.clouddn.com/images/concat.png)\n\n举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。\n\n获取辣条制造商信息\n\n\t@Test\n    public void testConcat() throws Exception {\n        final Observable<String> factory = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"卫龙\");\n                e.onComplete();\n            }\n        });\n\n        Observable<String> price = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"5\");\n                e.onComplete();\n            }\n        });\n        Observable<String> material = Observable.create(new ObservableOnSubscribe<String>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<String> e) throws Exception {\n                e.onNext(\"chili\");\n                e.onComplete();\n            }\n        });\n\n        Observable.concat(factory, price,material).subscribe(new Observer<String>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull String s) {\n                System.out.println(\"result\"+s);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n    }\n    \n结果为：\n\n\tresult：卫龙\n\tresult：5\n\tresult：chili\n\t\n就拿到了辣条的所有信息了。\n\n\n\n### 过滤操作\n\n#### 一、buffer\n\n可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。\n\n![buffer](http://ot29getcp.bkt.clouddn.com/images/buffer.png)\n\n\n#### 二、filter\n \n 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.\n\n![filter](http://ot29getcp.bkt.clouddn.com/images/filter.png)\n\n举一个简单的例子：\n\n\t@Test\n    public void testFilter() throws Exception {\n        Observable.create(new ObservableOnSubscribe<Integer>() {\n            @Override\n            public void subscribe(@NonNull ObservableEmitter<Integer> e) throws Exception {\n                e.onNext(1);\n                e.onNext(666);\n                e.onNext(6);\n                e.onComplete();\n            }\n        }).filter(new Predicate<Integer>() {\n            @Override\n            public boolean test(@NonNull Integer integer) throws Exception {\n                return integer>100;\n            }\n        }).subscribe(new Observer<Integer>() {\n            @Override\n            public void onSubscribe(@NonNull Disposable d) {\n\n            }\n\n            @Override\n            public void onNext(@NonNull Integer integer) {\n                System.out.println(\"result:\"+integer);\n            }\n\n            @Override\n            public void onError(@NonNull Throwable e) {\n\n            }\n\n            @Override\n            public void onComplete() {\n\n            }\n        });\n\n\n从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。\n\n\n\n\n\n\n\n\n","slug":"RxJava2-0-三-变换操作","published":1,"updated":"2017-08-31T13:51:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphg0011v7c0tkdhe9az","content":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h3 id=\"变换操作\"><a href=\"#变换操作\" class=\"headerlink\" title=\"变换操作\"></a>变换操作</h3><h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n<pre><code>@Test\npublic void testConcat() throws Exception {\n    final Observable&lt;String&gt; factory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;卫龙&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable&lt;String&gt; price = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;5&quot;);\n            e.onComplete();\n        }\n    });\n    Observable&lt;String&gt; material = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;chili&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable.concat(factory, price,material).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;result&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>结果为：</p>\n<pre><code>result：卫龙\nresult：5\nresult：chili\n</code></pre><p>就拿到了辣条的所有信息了。</p>\n<h3 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h3><h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>了解了线程控制的基本使用，接下来就来看看RxJava厉害的地方–变换操作。</p>\n<p>RxJava提供对事件序列进行变换操作。就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>\n<h3 id=\"变换操作\"><a href=\"#变换操作\" class=\"headerlink\" title=\"变换操作\"></a>变换操作</h3><h4 id=\"一、map\"><a href=\"#一、map\" class=\"headerlink\" title=\"一、map\"></a>一、map</h4><p>返回一个Observable，它将指定的函数应用于源ObservableSource发出的每个项目，并发出这些函数应用程序的结果。</p>\n<p>一对一的变换，如下图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/map.png\" alt=\"map\"></p>\n<pre><code>@Test\npublic void testMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;map&quot;);\n        }\n    }).map(new Function&lt;String, Integer&gt;() {\n        @Override\n        public Integer apply(@NonNull String s) throws Exception {\n            return getValue(s);\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer s) {\n            System.out.println(&quot;testMap:&quot; + s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>从上面的例子可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。</p>\n<ul>\n<li><p>对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化</p>\n</li>\n<li><p>map是一对一的， 可以将上游发来的事件转换为任意的类型, 可以是一个Object, 也可以是一个集合</p>\n</li>\n</ul>\n<h4 id=\"二、flatmap\"><a href=\"#二、flatmap\" class=\"headerlink\" title=\"二、flatmap\"></a>二、flatmap</h4><p>更加高级的变换。如图（来源：官方文档）</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/flatMap.png\" alt=\"flatmap\"></p>\n<ul>\n<li><p>一个Observable它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的flatMap()函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。</p>\n</li>\n<li><p>flatMap()不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>\n</li>\n</ul>\n<p>For Example：</p>\n<pre><code> @Test\npublic void testRxFlatMap() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(99);\n            e.onNext(66);\n            e.onComplete();\n        }\n    }).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() {\n        @Override\n        public ObservableSource&lt;String&gt; apply(@NonNull Integer s) throws Exception {\n            if (s&gt;80){\n                return Observable.just(&quot;A&quot;);\n            }\n            return Observable.just(&quot;B&quot;);\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;成绩为：&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>  从上面的代码很容易看出FlatMap将int变换为String对象，操作简单。一个操作符搞定，这样就方便多了。</p>\n<h4 id=\"三、concatMap\"><a href=\"#三、concatMap\" class=\"headerlink\" title=\"三、concatMap\"></a>三、concatMap</h4><ul>\n<li>官方文档解释：返回一个新的Observable，它会发送由应用源ObservableSource发出的每个项目提供的函数产生的项目，该函数返回一个ObservableSource，然后发出连接那些由此产生的ObservableSource产生的项目。</li>\n</ul>\n<p>通俗一点，就是和flatmap相比，concatMap是有序的。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concatMap.png\" alt=\"concatmap\"></p>\n<h4 id=\"四、zip\"><a href=\"#四、zip\" class=\"headerlink\" title=\"四、zip\"></a>四、zip</h4><p>返回一个Observable，它发出指定的组合器函数的结果，该结果应用于依次发送的其他ObservableSource的迭代项的组合。</p>\n<p>zip以严格的顺序应用此功能，因此新的ObservableSource发出的第一个项目将是应用于每个源ObservableSources发出的第一个项目的函数的结果; 新的ObservableSource发出的第二个项目将是应用于每个ObservableSource发出的第二个项目的函数的结果; 等等。</p>\n<p>来看一个简单的例子，加深理解。</p>\n<pre><code>/**\n * RxJava zip变换\n * @throws Exception\n */\n@Test\npublic void testZip() throws Exception {\n    Observable&lt;String&gt; observableHello = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;Hello&quot;);\n        }\n    });\n    Observable&lt;String&gt; observableWorld = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;World&quot;);\n        }\n    });\n    Observable.zip(observableHello, observableWorld, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(@NonNull String s, @NonNull String s2) throws Exception {\n            return s+s2;\n        }\n    }).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;Final:&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p> 从上面的例子就可以看出zip将获取的不同两个String重新组装得到一个新的组装后的String，达到zip类似打包的效果，应该很好理解吧。</p>\n<h4 id=\"五、concat\"><a href=\"#五、concat\" class=\"headerlink\" title=\"五、concat\"></a>五、concat</h4><p>Concatenates elements of each ObservableSource provided via an Iterable sequence into a single sequence of elements without interleaving them.</p>\n<p>简单来说就是将多个数据源按序发射。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/concat.png\" alt=\"concat\"></p>\n<p>举个很简单的例子，获取一包卫龙辣条包装的信息，可能需要制造商信息、价格、材料信息。</p>\n<p>获取辣条制造商信息</p>\n<pre><code>@Test\npublic void testConcat() throws Exception {\n    final Observable&lt;String&gt; factory = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;卫龙&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable&lt;String&gt; price = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;5&quot;);\n            e.onComplete();\n        }\n    });\n    Observable&lt;String&gt; material = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception {\n            e.onNext(&quot;chili&quot;);\n            e.onComplete();\n        }\n    });\n\n    Observable.concat(factory, price,material).subscribe(new Observer&lt;String&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull String s) {\n            System.out.println(&quot;result&quot;+s);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n}\n</code></pre><p>结果为：</p>\n<pre><code>result：卫龙\nresult：5\nresult：chili\n</code></pre><p>就拿到了辣条的所有信息了。</p>\n<h3 id=\"过滤操作\"><a href=\"#过滤操作\" class=\"headerlink\" title=\"过滤操作\"></a>过滤操作</h3><h4 id=\"一、buffer\"><a href=\"#一、buffer\" class=\"headerlink\" title=\"一、buffer\"></a>一、buffer</h4><p>可以理解为缓存。它定期从Observable收集数据到一个集合，然后把这些数据打包发射，而不是一次发一个。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/buffer.png\" alt=\"buffer\"></p>\n<h4 id=\"二、filter\"><a href=\"#二、filter\" class=\"headerlink\" title=\"二、filter\"></a>二、filter</h4><p> 简单的说，就是按照自定义条件过滤。官方解释：Filters items emitted by an ObservableSource by only emitting those that satisfy a specified predicate.</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/filter.png\" alt=\"filter\"></p>\n<p>举一个简单的例子：</p>\n<pre><code>@Test\npublic void testFilter() throws Exception {\n    Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {\n        @Override\n        public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception {\n            e.onNext(1);\n            e.onNext(666);\n            e.onNext(6);\n            e.onComplete();\n        }\n    }).filter(new Predicate&lt;Integer&gt;() {\n        @Override\n        public boolean test(@NonNull Integer integer) throws Exception {\n            return integer&gt;100;\n        }\n    }).subscribe(new Observer&lt;Integer&gt;() {\n        @Override\n        public void onSubscribe(@NonNull Disposable d) {\n\n        }\n\n        @Override\n        public void onNext(@NonNull Integer integer) {\n            System.out.println(&quot;result:&quot;+integer);\n        }\n\n        @Override\n        public void onError(@NonNull Throwable e) {\n\n        }\n\n        @Override\n        public void onComplete() {\n\n        }\n    });\n</code></pre><p>从上面的例子，很明显的看出filter按照自己的定义，过滤掉了小于100的数字，然后输出自己想要得到的数字。很容易理解。</p>\n"},{"title":"RxJava2.0(二)线程控制","date":"2017-08-11T11:27:52.000Z","_content":"\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","source":"_posts/RxJava2-0-二.md","raw":"---\ntitle: RxJava2.0(二)线程控制\ndate: 2017-08-11 19:27:52\ntags: [RxJava]\n---\n\n已经知道了基本使用，那就继续进阶更高级的操作-线程切换。\n\n以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：\n\n\t@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Log.d(TAG, Thread.currentThread().getName());\n    }\n\n结果：main.\n\n那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。\n比如：\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on main thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribe(consumer);                                                             \n\t}\n\n\n即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：\n\t\n\tD/TAG: Observable thread is : main\n\tD/TAG: emit on main thread                    \n\tD/TAG: Observer thread is :main   \n\tD/TAG: onNext: 1\n\t\n\t\n发射源和接收源都在主线程工作。\n\n然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。\n\n那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。\n\n\n\t@Override                                                                                       \n\tprotected void onCreate(Bundle savedInstanceState) {                                            \n\t    super.onCreate(savedInstanceState);                                                         \n\t    setContentView(R.layout.activity_main);                                                     \n\n    Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {   \n        @Override                                                                               \n        public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {            \n            Log.d(TAG, \"Observable thread is : \" + Thread.currentThread().getName());           \n            Log.d(TAG, \"emit on new Thread\");                                                               \n            emitter.onNext(1);                                                                  \n        }                                                                                       \n    });                                                                                         \n\n    Consumer<Integer> consumer = new Consumer<Integer>() {                                      \n        @Override                                                                               \n        public void accept(Integer integer) throws Exception {                                  \n            Log.d(TAG, \"Observer thread is :\" + Thread.currentThread().getName());              \n            Log.d(TAG, \"onNext: \" + integer);                                                   \n        }                                                                                       \n    };                                                                                          \n\n    observable.subscribeOn(Schedulers.newThread())                                              \n            .observeOn(AndroidSchedulers.mainThread())                                          \n            .subscribe(consumer);                                                               \n\t}\n\t\n\t\n结果：\n\n\tD/TAG: Observable thread is : RxNewThreadScheduler-2  \n\tD/TAG: emit on new thread                                         \n\tD/TAG: Observer thread is :main                       \n\tD/TAG: onNext: 1\n\t\n从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。\n\n仔细观察下，在订阅的时候多了两个操作：\n\n* subscribeOn\n* observeOn\n\n下面解释下这两个操作。\n\n* subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。\n* observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。\n\n\n* Scheduler中内置的几种线程介绍：\n\n\t* Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n\t\n\t* Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n\t\n\t* Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n\t\n\t* Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n\t\n\t* AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。\n","slug":"RxJava2-0-二","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphh0013v7c0s88w52mh","content":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>已经知道了基本使用，那就继续进阶更高级的操作-线程切换。</p>\n<p>以Android为例，一个Activity的所有动作默认都是在主线程中运行的, 比如：</p>\n<pre><code>@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    Log.d(TAG, Thread.currentThread().getName());\n}\n</code></pre><p>结果：main.</p>\n<p>那么在使用RxJava情况下，在主线程创建Observable发射数据，那么发射源就会在主线程发射数据，在主线程创建Observer接收数据，那么接收源就会在主线程接收数据。<br>比如：</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on main thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribe(consumer);                                                             \n}\n</code></pre><p>即在主线程中创建Observable和Obsever，通过订阅关联后，打印结果显示：</p>\n<pre><code>D/TAG: Observable thread is : main\nD/TAG: emit on main thread                    \nD/TAG: Observer thread is :main   \nD/TAG: onNext: 1\n</code></pre><p>发射源和接收源都在主线程工作。</p>\n<p>然而，我们工作的实际情况是，耗时的操作我们会在子线程处理，处理完再到主线程更新UI。</p>\n<p>那么，为了达到这样的效果，首先就需要改变上游发送数据的线程，然后下游在主线程接收数据，更新UI。</p>\n<pre><code>@Override                                                                                       \nprotected void onCreate(Bundle savedInstanceState) {                                            \n    super.onCreate(savedInstanceState);                                                         \n    setContentView(R.layout.activity_main);                                                     \n\nObservable&lt;Integer&gt; observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {   \n    @Override                                                                               \n    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception {            \n        Log.d(TAG, &quot;Observable thread is : &quot; + Thread.currentThread().getName());           \n        Log.d(TAG, &quot;emit on new Thread&quot;);                                                               \n        emitter.onNext(1);                                                                  \n    }                                                                                       \n});                                                                                         \n\nConsumer&lt;Integer&gt; consumer = new Consumer&lt;Integer&gt;() {                                      \n    @Override                                                                               \n    public void accept(Integer integer) throws Exception {                                  \n        Log.d(TAG, &quot;Observer thread is :&quot; + Thread.currentThread().getName());              \n        Log.d(TAG, &quot;onNext: &quot; + integer);                                                   \n    }                                                                                       \n};                                                                                          \n\nobservable.subscribeOn(Schedulers.newThread())                                              \n        .observeOn(AndroidSchedulers.mainThread())                                          \n        .subscribe(consumer);                                                               \n}\n</code></pre><p>结果：</p>\n<pre><code>D/TAG: Observable thread is : RxNewThreadScheduler-2  \nD/TAG: emit on new thread                                         \nD/TAG: Observer thread is :main                       \nD/TAG: onNext: 1\n</code></pre><p>从结果就可以看出，上游发射源是在一个新的子线程进行数据的相关处理的。处理后，下游的接收源在主线程接收数据。实现主线程更新UI，子线程处理耗时操作的场景。</p>\n<p>仔细观察下，在订阅的时候多了两个操作：</p>\n<ul>\n<li>subscribeOn</li>\n<li>observeOn</li>\n</ul>\n<p>下面解释下这两个操作。</p>\n<ul>\n<li>subscribeOn：上游发射源切换发射线程，多次切换的情况仅第一次有效。</li>\n<li>observeOn:下游接收事件线程，可多次指定，没指定一次，就切换一次。</li>\n</ul>\n<ul>\n<li><p>Scheduler中内置的几种线程介绍：</p>\n<ul>\n<li><p>Schedulers.immediate()。直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>\n</li>\n<li><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>\n</li>\n<li><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>\n</li>\n<li><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>\n</li>\n<li><p>AndroidSchedulers.mainThread()。它指定的操作将在 Android 主线程运行，Android专用。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Set集合使用注意tips","date":"2017-02-22T11:11:02.000Z","_content":"\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","source":"_posts/Set集合使用注意tips.md","raw":"---\ntitle: Set集合使用注意tips\ndate: 2017-02-22 19:11:02\ntags:\n---\n\n### Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\n\nConcurrentModificationException\n\n\n\texample:\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        set.remove(checkWork);\n\t\t    }\n\t\t}\n\t\t\n### 解决方案：\n1. 遍历删除List\n\n\t\tList<CheckWork> list = this.getUserDao().getAll();\n\t\tIterator<CheckWork> chk_it = list.iterator();\n\t\twhile(chk_it.hasNext()){\n\t\t    CheckWork checkWork = chk_it.next();\n\t\t    if(checkWork.getPlanState()==1){\n\t\t        chk_it.remove();\n\t\t    }\n\t\t}\n\t\n2. 遍历删除Set\n\n\t\tSet<CheckWork> set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n\t\t\t\tIterator<CheckWork> it = set.iterator();\n\t\t\t\twhile(it.hasNext()){\n\t\t\t\t\tCheckWork checkWork = it.next();\n\t\t\t\t\tif(checkWork.getState()==1){\n\t\t\t\t\t\tit.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n3. 遍历删除Set\n\n\t\tSet<CheckWork> set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\n\t\tSet<CheckWork> delSet=new HashSet<>();\n\t\tfor(CheckWork checkWork : set){\n\t\t    if(checkWork.getState()==1){\n\t\t        delSet.add(checkWork);\n\t\t    }\n\t\t}\n\t\tset.removeAll(delSet);\t\n","slug":"Set集合使用注意tips","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphi0015v7c000w81pmr","content":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"><a href=\"#Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\" class=\"headerlink\" title=\"Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：\"></a>Set中的某些元素，当时使用边遍历，边删除的方法，报了以下异常：</h3><p>ConcurrentModificationException</p>\n<pre><code>example:\n    Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks();\n    for(CheckWork checkWork : set){\n        if(checkWork.getState()==1){\n            set.remove(checkWork);\n        }\n    }\n</code></pre><h3 id=\"解决方案：\"><a href=\"#解决方案：\" class=\"headerlink\" title=\"解决方案：\"></a>解决方案：</h3><ol>\n<li><p>遍历删除List</p>\n<pre><code>List&lt;CheckWork&gt; list = this.getUserDao().getAll();\nIterator&lt;CheckWork&gt; chk_it = list.iterator();\nwhile(chk_it.hasNext()){\n    CheckWork checkWork = chk_it.next();\n    if(checkWork.getPlanState()==1){\n        chk_it.remove();\n    }\n}\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set =  this.getUserDao().getAll().get(0).getActionCheckWorks();\n        Iterator&lt;CheckWork&gt; it = set.iterator();\n        while(it.hasNext()){\n            CheckWork checkWork = it.next();\n            if(checkWork.getState()==1){\n                it.remove();\n            }\n        }\n</code></pre></li>\n<li><p>遍历删除Set</p>\n<pre><code>Set&lt;CheckWork&gt; set = this.getUserDao().getAll(qf).get(0).getActionCheckWorks()；\nSet&lt;CheckWork&gt; delSet=new HashSet&lt;&gt;();\nfor(CheckWork checkWork : set){\n    if(checkWork.getState()==1){\n        delSet.add(checkWork);\n    }\n}\nset.removeAll(delSet);    \n</code></pre></li>\n</ol>\n"},{"title":"RxJava2.0(四)Backpressure","date":"2017-09-04T15:27:16.000Z","_content":"\n上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。\n\n#### 一、什么是背压\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。\n\n例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？\n\n那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。\n\n简单来说，就是来控制事件流速。\n","source":"_posts/RxJava2-0-四-Backpressure.md","raw":"---\ntitle: RxJava2.0(四)Backpressure\ndate: 2017-09-04 23:27:16\ntags: [RxJava]\n---\n\n上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。\n\n#### 一、什么是背压\n\n在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。\n\n例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？\n\n那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。\n\n简单来说，就是来控制事件流速。\n","slug":"RxJava2-0-四-Backpressure","published":1,"updated":"2017-09-11T15:57:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphj0018v7c02m9plleb","content":"<p>上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。</p>\n<h4 id=\"一、什么是背压\"><a href=\"#一、什么是背压\" class=\"headerlink\" title=\"一、什么是背压\"></a>一、什么是背压</h4><p>在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。</p>\n<p>例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？</p>\n<p>那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。</p>\n<p>简单来说，就是来控制事件流速。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一节对于基本常用的操作符有了基本的了解。接下来学学BackPressure(背压)。</p>\n<h4 id=\"一、什么是背压\"><a href=\"#一、什么是背压\" class=\"headerlink\" title=\"一、什么是背压\"></a>一、什么是背压</h4><p>在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或者订阅者不能及时处理相关的消息。那么随之而来的就是如何处理这些未处理的消息。</p>\n<p>例如，上节讲到的zip操作符，如果zip将两个无限发送事件的被观察者进行组合，那么其中一个被观察者A发送事件特别快，另外一个被观察者发送事件特别慢，那么就会有越来越多等待组合的事件。等发送事件慢的被观察者发送事件，等待的发射事件快的再与慢的组合，是不是很笨重+占资源？</p>\n<p>那么这个时候backpressure(背压)出现了，RxJava中多重控制流及背压策略用来应对一个快速发送消息的被观察者遇到一个处理消息缓慢的观察者。下面的解释将会向你展示你应当怎么设计属于你自己的被观察者和操作符去应对流量控制（flow control）。</p>\n<p>简单来说，就是来控制事件流速。</p>\n"},{"title":"Hello World","date":"2016-09-01T12:02:08.000Z","type":["Hello"],"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-09-01 20:02:08\ntype: [Hello]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphk001av7c0u3ec1xbd","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"},{"title":"书读的不多，却想的太多","date":"2017-09-03T06:54:22.000Z","_content":"\n书读得不多却想的太多。\n先好好看书。\n持续更新···\n\n![程序设计](http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png)\n\n\n![软件工程](http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png)\n","source":"_posts/书读的不多，却想的太多.md","raw":"---\ntitle: 书读的不多，却想的太多\ndate: 2017-09-03 14:54:22\ntags: [Book推荐]\n---\n\n书读得不多却想的太多。\n先好好看书。\n持续更新···\n\n![程序设计](http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png)\n\n\n![软件工程](http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png)\n","slug":"书读的不多，却想的太多","published":1,"updated":"2017-09-03T06:57:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphl001bv7c0anhdrjvo","content":"<p>书读得不多却想的太多。<br>先好好看书。<br>持续更新···</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png\" alt=\"程序设计\"></p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png\" alt=\"软件工程\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>书读得不多却想的太多。<br>先好好看书。<br>持续更新···</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/chengxusheji.png\" alt=\"程序设计\"></p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/ruanjiangongcheng.png\" alt=\"软件工程\"></p>\n"},{"title":"关于HTTP需要理解的知识点","date":"2016-11-13T07:24:05.000Z","_content":"\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","source":"_posts/关于HTTP需要理解的知识点.md","raw":"---\ntitle: 关于HTTP需要理解的知识点\ndate: 2016-11-13 15:24:05\ntags: [HTTP]\n---\n\n\n## 关于HTTP需要知道的知识点\n\n### HTTP简介\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\n### HTTP消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![“请求报文”](http://ot29getcp.bkt.clouddn.com\n/images/request.png) \n\n\n#### 服务器相应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![“服务器响应”](http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg) \n\n\n#### 实例\n\n使用GET来传递数据的实例：\n\n客户端请求：\n\n\tGET /hello.txt HTTP/1.1\n\tUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n\tHost: www.example.com\n\tAccept-Language: en, mi\n\t\n服务端响应：\n\n\tHTTP/1.1 200 OK\n\tDate: Mon, 27 Jul 2009 12:28:53 GMT\n\tServer: Apache\n\tLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n\tETag: \"34aa387-d-1568eb00\"\n\tAccept-Ranges: bytes\n\tContent-Length: 51\n\tVary: Accept-Encoding\n\tContent-Type: text/plain\n\t\n输出结果：\n\n\tHello World! My payload includes a trailing CRLF.\n\t\n### HTTP请求方法\n\n* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。\n\n* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\n序号 | 方法 | 描述 \n---- |---- |----\n1|GET|请求指定的页面信息，并返回实体主体。\n2|HEAD|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头\n3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。\n4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。\n5|DELETE|请求服务器删除指定的页面。\n6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n7|OPTIONS|允许客户端查看服务器的性能。\n8|TRACE|回显服务器收到的请求，主要用于测试或诊断。\n\n\n### HTTP响应头信息\n\nHTTP请求头提供了关于请求，响应或者其他的发送实体的信息。\n\n应答头 | 说明\n---- |----\nAllow | 服务器支持哪些请求方法（如GET、POST等）\nContent-Encoding\t|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(\"Accept-Encoding\")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。\nContent-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。\nContent-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。\nDate|当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。\nExpires|应该在什么时候认为文档已经过期，从而不再缓存它\nLast-Modified\t|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。\nLocation|表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。\nRefresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面\"，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=\"Refresh\" ...＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。\nServer|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\nSet-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。\nWWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(\"WWW-Authenticate\", \"BASIC realm=＼\"executives＼\"\")。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。\n\n### HTTP状态码\n常见的HTTP状态码：\n\n* 200 - 请求成功\n* 301 - 资源（网页等）被永久转移到其它URL\n* 404 - 请求的资源（网页等）不存在\n* 500 - 内部服务器错误\n","slug":"关于HTTP需要理解的知识点","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphn001ev7c0u8wkfpe2","content":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于HTTP需要知道的知识点\"><a href=\"#关于HTTP需要知道的知识点\" class=\"headerlink\" title=\"关于HTTP需要知道的知识点\"></a>关于HTTP需要知道的知识点</h2><h3 id=\"HTTP简介\"><a href=\"#HTTP简介\" class=\"headerlink\" title=\"HTTP简介\"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<h3 id=\"HTTP消息结构\"><a href=\"#HTTP消息结构\" class=\"headerlink\" title=\"HTTP消息结构\"></a>HTTP消息结构</h3><h4 id=\"客户端请求消息\"><a href=\"#客户端请求消息\" class=\"headerlink\" title=\"客户端请求消息\"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/request.png\" alt=\"“请求报文”\"> </p>\n<h4 id=\"服务器相应消息\"><a href=\"#服务器相应消息\" class=\"headerlink\" title=\"服务器相应消息\"></a>服务器相应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com\n/images/httpmessage.jpg\" alt=\"“服务器响应”\"> </p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>使用GET来传递数据的实例：</p>\n<p>客户端请求：</p>\n<pre><code>GET /hello.txt HTTP/1.1\nUser-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\nHost: www.example.com\nAccept-Language: en, mi\n</code></pre><p>服务端响应：</p>\n<pre><code>HTTP/1.1 200 OK\nDate: Mon, 27 Jul 2009 12:28:53 GMT\nServer: Apache\nLast-Modified: Wed, 22 Jul 2009 19:15:56 GMT\nETag: &quot;34aa387-d-1568eb00&quot;\nAccept-Ranges: bytes\nContent-Length: 51\nVary: Accept-Encoding\nContent-Type: text/plain\n</code></pre><p>输出结果：</p>\n<pre><code>Hello World! My payload includes a trailing CRLF.\n</code></pre><h3 id=\"HTTP请求方法\"><a href=\"#HTTP请求方法\" class=\"headerlink\" title=\"HTTP请求方法\"></a>HTTP请求方法</h3><ul>\n<li><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n</li>\n<li><p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>方法</th>\n<th>描述 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP响应头信息\"><a href=\"#HTTP响应头信息\" class=\"headerlink\" title=\"HTTP响应头信息\"></a>HTTP响应头信息</h3><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的＜META</a> HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href=\"http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META\" target=\"_blank\" rel=\"external\">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是&quot;N秒之后刷新本页面或访问指定页面&quot;，而不是&quot;每隔N秒刷新本页面或访问指定页面&quot;。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META</a> HTTP-EQUIV=”Refresh” …＞。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p>常见的HTTP状态码：</p>\n<ul>\n<li>200 - 请求成功</li>\n<li>301 - 资源（网页等）被永久转移到其它URL</li>\n<li>404 - 请求的资源（网页等）不存在</li>\n<li>500 - 内部服务器错误</li>\n</ul>\n"},{"title":"多的是，你不知道的事","date":"2017-09-02T16:09:12.000Z","_content":"\n### 多的是，你不知道的事\n\n---\n\n\n#### Android系统源码学习\n\n* Binder机制和AIDL\n* Activity的启动过程\n* 进程的优先级\n* ServiceManager\n* Window和WindowManager\n\n\n#### 开源框架学习\n\n* OKHTTP\n* Retrofit\n* Glide\n* Gson\n* fastjson\n* Jackson\n* Realm\n* Ormlite\n* ButterKnief\n* GreenDao\n* RePlugin\n* Leakcanary\n* EventBus\n* otto\n* MPAndroidChart\n* ZXing\n* PhotoView\n* dragger\n* DisLruCache\n\n\n#### 多线程处理\n\n* Handler原理\n* AsyncTask\n* HandlerThread\n* IntentService\n* RxJava\n\n#### 自定义控件\n\n* measure\n* layout\n* draw\n* 事件分发\n* 自定义动画\n\n#### 性能优化\n\n* ANR处理\n* OOM处理\n* 布局优化\n* 线程优化\n\n#### Java高级知识\n\n* 反射\n* 动态代理\n* NIO\n* 垃圾回收\n* 多线程（并发锁）\n* 网络协议\n\n#### APP架构\n\n* MVC\n* MVP\n* MVVM\n\n#### 插件化技术\n\n* class和dex学习\n* ClassLoader原理\n* 插件化原理\n* 插件化框架学习\n\n#### NDK开发\n\n* 调用JNI方法\n* 回调JAVA方法\n* CMAKE语法\n* NDK MakeFile语法\n\n\n#### 音视频处理\n\n* 音频编解码\n* AudioTrack播放\n* 视频解码\n* OpenGL绘制\n* 视频编辑转码\n* 视频滤镜\n\n\n#### 工具\n\n* AndroidStudio\n* Gradle脚本\n* Git\n","source":"_posts/多的是，你不知道的事.md","raw":"---\ntitle: 多的是，你不知道的事\ndate: 2017-09-03 00:09:12\ntags: [Android进阶]\n---\n\n### 多的是，你不知道的事\n\n---\n\n\n#### Android系统源码学习\n\n* Binder机制和AIDL\n* Activity的启动过程\n* 进程的优先级\n* ServiceManager\n* Window和WindowManager\n\n\n#### 开源框架学习\n\n* OKHTTP\n* Retrofit\n* Glide\n* Gson\n* fastjson\n* Jackson\n* Realm\n* Ormlite\n* ButterKnief\n* GreenDao\n* RePlugin\n* Leakcanary\n* EventBus\n* otto\n* MPAndroidChart\n* ZXing\n* PhotoView\n* dragger\n* DisLruCache\n\n\n#### 多线程处理\n\n* Handler原理\n* AsyncTask\n* HandlerThread\n* IntentService\n* RxJava\n\n#### 自定义控件\n\n* measure\n* layout\n* draw\n* 事件分发\n* 自定义动画\n\n#### 性能优化\n\n* ANR处理\n* OOM处理\n* 布局优化\n* 线程优化\n\n#### Java高级知识\n\n* 反射\n* 动态代理\n* NIO\n* 垃圾回收\n* 多线程（并发锁）\n* 网络协议\n\n#### APP架构\n\n* MVC\n* MVP\n* MVVM\n\n#### 插件化技术\n\n* class和dex学习\n* ClassLoader原理\n* 插件化原理\n* 插件化框架学习\n\n#### NDK开发\n\n* 调用JNI方法\n* 回调JAVA方法\n* CMAKE语法\n* NDK MakeFile语法\n\n\n#### 音视频处理\n\n* 音频编解码\n* AudioTrack播放\n* 视频解码\n* OpenGL绘制\n* 视频编辑转码\n* 视频滤镜\n\n\n#### 工具\n\n* AndroidStudio\n* Gradle脚本\n* Git\n","slug":"多的是，你不知道的事","published":1,"updated":"2017-09-17T15:31:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpho001fv7c0kjk2n7sl","content":"<h3 id=\"多的是，你不知道的事\"><a href=\"#多的是，你不知道的事\" class=\"headerlink\" title=\"多的是，你不知道的事\"></a>多的是，你不知道的事</h3><hr>\n<h4 id=\"Android系统源码学习\"><a href=\"#Android系统源码学习\" class=\"headerlink\" title=\"Android系统源码学习\"></a>Android系统源码学习</h4><ul>\n<li>Binder机制和AIDL</li>\n<li>Activity的启动过程</li>\n<li>进程的优先级</li>\n<li>ServiceManager</li>\n<li>Window和WindowManager</li>\n</ul>\n<h4 id=\"开源框架学习\"><a href=\"#开源框架学习\" class=\"headerlink\" title=\"开源框架学习\"></a>开源框架学习</h4><ul>\n<li>OKHTTP</li>\n<li>Retrofit</li>\n<li>Glide</li>\n<li>Gson</li>\n<li>fastjson</li>\n<li>Jackson</li>\n<li>Realm</li>\n<li>Ormlite</li>\n<li>ButterKnief</li>\n<li>GreenDao</li>\n<li>RePlugin</li>\n<li>Leakcanary</li>\n<li>EventBus</li>\n<li>otto</li>\n<li>MPAndroidChart</li>\n<li>ZXing</li>\n<li>PhotoView</li>\n<li>dragger</li>\n<li>DisLruCache</li>\n</ul>\n<h4 id=\"多线程处理\"><a href=\"#多线程处理\" class=\"headerlink\" title=\"多线程处理\"></a>多线程处理</h4><ul>\n<li>Handler原理</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>IntentService</li>\n<li>RxJava</li>\n</ul>\n<h4 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h4><ul>\n<li>measure</li>\n<li>layout</li>\n<li>draw</li>\n<li>事件分发</li>\n<li>自定义动画</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>ANR处理</li>\n<li>OOM处理</li>\n<li>布局优化</li>\n<li>线程优化</li>\n</ul>\n<h4 id=\"Java高级知识\"><a href=\"#Java高级知识\" class=\"headerlink\" title=\"Java高级知识\"></a>Java高级知识</h4><ul>\n<li>反射</li>\n<li>动态代理</li>\n<li>NIO</li>\n<li>垃圾回收</li>\n<li>多线程（并发锁）</li>\n<li>网络协议</li>\n</ul>\n<h4 id=\"APP架构\"><a href=\"#APP架构\" class=\"headerlink\" title=\"APP架构\"></a>APP架构</h4><ul>\n<li>MVC</li>\n<li>MVP</li>\n<li>MVVM</li>\n</ul>\n<h4 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h4><ul>\n<li>class和dex学习</li>\n<li>ClassLoader原理</li>\n<li>插件化原理</li>\n<li>插件化框架学习</li>\n</ul>\n<h4 id=\"NDK开发\"><a href=\"#NDK开发\" class=\"headerlink\" title=\"NDK开发\"></a>NDK开发</h4><ul>\n<li>调用JNI方法</li>\n<li>回调JAVA方法</li>\n<li>CMAKE语法</li>\n<li>NDK MakeFile语法</li>\n</ul>\n<h4 id=\"音视频处理\"><a href=\"#音视频处理\" class=\"headerlink\" title=\"音视频处理\"></a>音视频处理</h4><ul>\n<li>音频编解码</li>\n<li>AudioTrack播放</li>\n<li>视频解码</li>\n<li>OpenGL绘制</li>\n<li>视频编辑转码</li>\n<li>视频滤镜</li>\n</ul>\n<h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>AndroidStudio</li>\n<li>Gradle脚本</li>\n<li>Git</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"多的是，你不知道的事\"><a href=\"#多的是，你不知道的事\" class=\"headerlink\" title=\"多的是，你不知道的事\"></a>多的是，你不知道的事</h3><hr>\n<h4 id=\"Android系统源码学习\"><a href=\"#Android系统源码学习\" class=\"headerlink\" title=\"Android系统源码学习\"></a>Android系统源码学习</h4><ul>\n<li>Binder机制和AIDL</li>\n<li>Activity的启动过程</li>\n<li>进程的优先级</li>\n<li>ServiceManager</li>\n<li>Window和WindowManager</li>\n</ul>\n<h4 id=\"开源框架学习\"><a href=\"#开源框架学习\" class=\"headerlink\" title=\"开源框架学习\"></a>开源框架学习</h4><ul>\n<li>OKHTTP</li>\n<li>Retrofit</li>\n<li>Glide</li>\n<li>Gson</li>\n<li>fastjson</li>\n<li>Jackson</li>\n<li>Realm</li>\n<li>Ormlite</li>\n<li>ButterKnief</li>\n<li>GreenDao</li>\n<li>RePlugin</li>\n<li>Leakcanary</li>\n<li>EventBus</li>\n<li>otto</li>\n<li>MPAndroidChart</li>\n<li>ZXing</li>\n<li>PhotoView</li>\n<li>dragger</li>\n<li>DisLruCache</li>\n</ul>\n<h4 id=\"多线程处理\"><a href=\"#多线程处理\" class=\"headerlink\" title=\"多线程处理\"></a>多线程处理</h4><ul>\n<li>Handler原理</li>\n<li>AsyncTask</li>\n<li>HandlerThread</li>\n<li>IntentService</li>\n<li>RxJava</li>\n</ul>\n<h4 id=\"自定义控件\"><a href=\"#自定义控件\" class=\"headerlink\" title=\"自定义控件\"></a>自定义控件</h4><ul>\n<li>measure</li>\n<li>layout</li>\n<li>draw</li>\n<li>事件分发</li>\n<li>自定义动画</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>ANR处理</li>\n<li>OOM处理</li>\n<li>布局优化</li>\n<li>线程优化</li>\n</ul>\n<h4 id=\"Java高级知识\"><a href=\"#Java高级知识\" class=\"headerlink\" title=\"Java高级知识\"></a>Java高级知识</h4><ul>\n<li>反射</li>\n<li>动态代理</li>\n<li>NIO</li>\n<li>垃圾回收</li>\n<li>多线程（并发锁）</li>\n<li>网络协议</li>\n</ul>\n<h4 id=\"APP架构\"><a href=\"#APP架构\" class=\"headerlink\" title=\"APP架构\"></a>APP架构</h4><ul>\n<li>MVC</li>\n<li>MVP</li>\n<li>MVVM</li>\n</ul>\n<h4 id=\"插件化技术\"><a href=\"#插件化技术\" class=\"headerlink\" title=\"插件化技术\"></a>插件化技术</h4><ul>\n<li>class和dex学习</li>\n<li>ClassLoader原理</li>\n<li>插件化原理</li>\n<li>插件化框架学习</li>\n</ul>\n<h4 id=\"NDK开发\"><a href=\"#NDK开发\" class=\"headerlink\" title=\"NDK开发\"></a>NDK开发</h4><ul>\n<li>调用JNI方法</li>\n<li>回调JAVA方法</li>\n<li>CMAKE语法</li>\n<li>NDK MakeFile语法</li>\n</ul>\n<h4 id=\"音视频处理\"><a href=\"#音视频处理\" class=\"headerlink\" title=\"音视频处理\"></a>音视频处理</h4><ul>\n<li>音频编解码</li>\n<li>AudioTrack播放</li>\n<li>视频解码</li>\n<li>OpenGL绘制</li>\n<li>视频编辑转码</li>\n<li>视频滤镜</li>\n</ul>\n<h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><ul>\n<li>AndroidStudio</li>\n<li>Gradle脚本</li>\n<li>Git</li>\n</ul>\n"},{"title":"自定义View(2)Canvas简介","date":"2017-09-21T02:56:35.000Z","_content":"\n### 一、Canvas简介\n\n\n#### （1）Canvas简介\n\nCanvas,即画布。\n\n#### （2）Canvas详解\n\n画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。\n\n* 首先介绍一下画笔Paint\n\n\t* 1.三个构造函数\n\t\t\n\t\t* Paint()\t创建一个画笔\n\t\t* Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）\n\t\t* Paint(Paint paint)\t使用已构造的Paint创建一个画笔\n\n\t* 2.常用方法\n\t\n\t\t* setAlpha(int a)\t设置透明度\n\t\t* setARGB(int a, int r, int g, int b) \t设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue\n\t\t* setAntiAlias(boolean aa)\t设置抗锯齿\n\t\t* setColor(@ColorInt int color) 设置颜色\n\t\t* setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬\n\t\t* setUnderlineText(boolean underlineText)\t设置文本下划线\n\t\t* setStyle(Style style)\t设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边\n\t\t* setStrikeThruText(boolean strikeThruText)\t设置文本删除线\n\t\t* setFilterBitmap(boolean filter)\t\t对bitmap进行滤波处理，true-去除优化，加快显示\n\t\t* setColorFilter(ColorFilter filter) \t设置颜色过滤\n\t\t\n\t\t······\n\t\t\n\t* 3.ColorFilter\n\n\t\tColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。\n\t\t\n\t\t1. ColorMatrixColorFilter\n\n\t\t\t* ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.\n\t\t\t* 通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。\n\t\t\n\t\n","source":"_posts/自定义View-2-Canvas简介.md","raw":"---\ntitle: 自定义View(2)Canvas简介\ndate: 2017-09-21 10:56:35\ntags: [自定义View]\n---\n\n### 一、Canvas简介\n\n\n#### （1）Canvas简介\n\nCanvas,即画布。\n\n#### （2）Canvas详解\n\n画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。\n\n* 首先介绍一下画笔Paint\n\n\t* 1.三个构造函数\n\t\t\n\t\t* Paint()\t创建一个画笔\n\t\t* Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）\n\t\t* Paint(Paint paint)\t使用已构造的Paint创建一个画笔\n\n\t* 2.常用方法\n\t\n\t\t* setAlpha(int a)\t设置透明度\n\t\t* setARGB(int a, int r, int g, int b) \t设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue\n\t\t* setAntiAlias(boolean aa)\t设置抗锯齿\n\t\t* setColor(@ColorInt int color) 设置颜色\n\t\t* setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬\n\t\t* setUnderlineText(boolean underlineText)\t设置文本下划线\n\t\t* setStyle(Style style)\t设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边\n\t\t* setStrikeThruText(boolean strikeThruText)\t设置文本删除线\n\t\t* setFilterBitmap(boolean filter)\t\t对bitmap进行滤波处理，true-去除优化，加快显示\n\t\t* setColorFilter(ColorFilter filter) \t设置颜色过滤\n\t\t\n\t\t······\n\t\t\n\t* 3.ColorFilter\n\n\t\tColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。\n\t\t\n\t\t1. ColorMatrixColorFilter\n\n\t\t\t* ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.\n\t\t\t* 通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。\n\t\t\n\t\n","slug":"自定义View-2-Canvas简介","published":1,"updated":"2017-09-25T14:37:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphr001iv7c0m29t1k5d","content":"<h3 id=\"一、Canvas简介\"><a href=\"#一、Canvas简介\" class=\"headerlink\" title=\"一、Canvas简介\"></a>一、Canvas简介</h3><h4 id=\"（1）Canvas简介\"><a href=\"#（1）Canvas简介\" class=\"headerlink\" title=\"（1）Canvas简介\"></a>（1）Canvas简介</h4><p>Canvas,即画布。</p>\n<h4 id=\"（2）Canvas详解\"><a href=\"#（2）Canvas详解\" class=\"headerlink\" title=\"（2）Canvas详解\"></a>（2）Canvas详解</h4><p>画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。</p>\n<ul>\n<li><p>首先介绍一下画笔Paint</p>\n<ul>\n<li><p>1.三个构造函数</p>\n<ul>\n<li>Paint()    创建一个画笔</li>\n<li>Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）</li>\n<li>Paint(Paint paint)    使用已构造的Paint创建一个画笔</li>\n</ul>\n</li>\n<li><p>2.常用方法</p>\n<ul>\n<li>setAlpha(int a)    设置透明度</li>\n<li>setARGB(int a, int r, int g, int b)     设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue</li>\n<li>setAntiAlias(boolean aa)    设置抗锯齿</li>\n<li>setColor(@ColorInt int color) 设置颜色</li>\n<li>setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬</li>\n<li>setUnderlineText(boolean underlineText)    设置文本下划线</li>\n<li>setStyle(Style style)    设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边</li>\n<li>setStrikeThruText(boolean strikeThruText)    设置文本删除线</li>\n<li>setFilterBitmap(boolean filter)        对bitmap进行滤波处理，true-去除优化，加快显示</li>\n<li><p>setColorFilter(ColorFilter filter)     设置颜色过滤</p>\n<p>······</p>\n</li>\n</ul>\n</li>\n<li><p>3.ColorFilter</p>\n<p>  ColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。</p>\n<ol>\n<li><p>ColorMatrixColorFilter</p>\n<ul>\n<li>ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.</li>\n<li>通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、Canvas简介\"><a href=\"#一、Canvas简介\" class=\"headerlink\" title=\"一、Canvas简介\"></a>一、Canvas简介</h3><h4 id=\"（1）Canvas简介\"><a href=\"#（1）Canvas简介\" class=\"headerlink\" title=\"（1）Canvas简介\"></a>（1）Canvas简介</h4><p>Canvas,即画布。</p>\n<h4 id=\"（2）Canvas详解\"><a href=\"#（2）Canvas详解\" class=\"headerlink\" title=\"（2）Canvas详解\"></a>（2）Canvas详解</h4><p>画布，就是我们用来绘制的载体，我们可以用画笔（Paint）在画布（Canvas）上绘制我们想要的图形。</p>\n<ul>\n<li><p>首先介绍一下画笔Paint</p>\n<ul>\n<li><p>1.三个构造函数</p>\n<ul>\n<li>Paint()    创建一个画笔</li>\n<li>Paint(int flags) 创建一个画笔，指定flag。也可在不指定flag创建后，通过setFlag指定。例如：Paint.ANTI_ALIAS_FLAG(用于绘制时抗锯齿）</li>\n<li>Paint(Paint paint)    使用已构造的Paint创建一个画笔</li>\n</ul>\n</li>\n<li><p>2.常用方法</p>\n<ul>\n<li>setAlpha(int a)    设置透明度</li>\n<li>setARGB(int a, int r, int g, int b)     设置画笔颜色，a-alpha透明度，r-red,g-green,b-blue</li>\n<li>setAntiAlias(boolean aa)    设置抗锯齿</li>\n<li>setColor(@ColorInt int color) 设置颜色</li>\n<li>setDither(boolean dither) 设置抖动，设置后线条会相对柔和一些，不那么僵硬</li>\n<li>setUnderlineText(boolean underlineText)    设置文本下划线</li>\n<li>setStyle(Style style)    设置画笔风格。FILL内部填充，STROKE描边，FILL_AND_STROKE填充内部和描边</li>\n<li>setStrikeThruText(boolean strikeThruText)    设置文本删除线</li>\n<li>setFilterBitmap(boolean filter)        对bitmap进行滤波处理，true-去除优化，加快显示</li>\n<li><p>setColorFilter(ColorFilter filter)     设置颜色过滤</p>\n<p>······</p>\n</li>\n</ul>\n</li>\n<li><p>3.ColorFilter</p>\n<p>  ColorFilter主要用来处理颜色.它有三个子类：ColorMatrixColorFilter、LightingColorFilter、PorterDuffColorFilter。下面一一进行解释。</p>\n<ol>\n<li><p>ColorMatrixColorFilter</p>\n<ul>\n<li>ColorMatrixColorFilter在Android中，图片是以一个个 RGBA 的像素点的形式加载到内存中的，所以如果需要改变图片的颜色，就需要针对这一个个像素点的RGBA的值进行修改。修改图片的RGBA值，需要ColorMatrix类支持.</li>\n<li>通过4x5颜色矩阵转换颜色的滤色镜。 该滤镜可用于改变像素的饱和度，从YUV转换为RGB等。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"自定义View(一)View简介","date":"2017-08-26T14:06:02.000Z","_content":"\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n1. 组合控件或继承基本控件\n\n\t像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View\n\t\n\t举个简单的例子：ToolBar\n\t\n\t在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。\n\t\n\t看源码：\n\t\n\t![toolbar](http://ot29getcp.bkt.clouddn.com/images/toolbar.png)\n\t\n\t可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。\n\t\n\t\n2. 自定义View\n\n 自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View\n\n * (1)屏幕坐标系\n\n \t![zuobiaoxi](http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png)\n \t\n \t手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。\n * （2）View坐标系\n \n ![viewzuobiao](http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png)\n \n View坐标系都是相对父控件而言来确定位置的。\n \t\n \t* getTop():view顶部相对于父控件顶部距离\n \t* getBottom():view底部相对于父控件顶部距离\n \t* getLeft():view左边相对于父控件距离\n \t* getRight():view右边相对于父控件距离\n \t\n \t\n \t\n3. View绘制流程\n\n![viewhuizhi](http://ot29getcp.bkt.clouddn.com/images/customview.jpg)\n\n ","source":"_posts/自定义View-一.md","raw":"---\ntitle: 自定义View(一)View简介\ndate: 2017-08-26 22:06:02\ntags: [自定义View]\n---\n\n#### 一、常见View继承关系\n\n* 如下图\n\t\n\t![view](http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png)\n\t\n可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.\n\n#### 二、自定义控件\n\n* 大致可分为两大类：\n\t\n\t* 组合或继承基本控件TextView、ImageView等，加上自定义的内容。\n\t* 继承自View\n\n\t \n\t\n1. 组合控件或继承基本控件\n\n\t像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View\n\t\n\t举个简单的例子：ToolBar\n\t\n\t在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。\n\t\n\t看源码：\n\t\n\t![toolbar](http://ot29getcp.bkt.clouddn.com/images/toolbar.png)\n\t\n\t可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。\n\t\n\t\n2. 自定义View\n\n 自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View\n\n * (1)屏幕坐标系\n\n \t![zuobiaoxi](http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png)\n \t\n \t手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。\n * （2）View坐标系\n \n ![viewzuobiao](http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png)\n \n View坐标系都是相对父控件而言来确定位置的。\n \t\n \t* getTop():view顶部相对于父控件顶部距离\n \t* getBottom():view底部相对于父控件顶部距离\n \t* getLeft():view左边相对于父控件距离\n \t* getRight():view右边相对于父控件距离\n \t\n \t\n \t\n3. View绘制流程\n\n![viewhuizhi](http://ot29getcp.bkt.clouddn.com/images/customview.jpg)\n\n ","slug":"自定义View-一","published":1,"updated":"2017-09-21T03:25:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphu001jv7c02xjspsqo","content":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>组合控件或继承基本控件</p>\n<p> 像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View</p>\n<p> 举个简单的例子：ToolBar</p>\n<p> 在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。</p>\n<p> 看源码：</p>\n<p> <img src=\"http://ot29getcp.bkt.clouddn.com/images/toolbar.png\" alt=\"toolbar\"></p>\n<p> 可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。</p>\n</li>\n</ol>\n<ol>\n<li><p>自定义View</p>\n<p>自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View</p>\n<ul>\n<li><p>(1)屏幕坐标系</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></p>\n<p>手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。</p>\n</li>\n<li>（2）View坐标系</li>\n</ul>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png\" alt=\"viewzuobiao\"></p>\n<p>View坐标系都是相对父控件而言来确定位置的。</p>\n<ul>\n<li>getTop():view顶部相对于父控件顶部距离</li>\n<li>getBottom():view底部相对于父控件顶部距离</li>\n<li>getLeft():view左边相对于父控件距离</li>\n<li>getRight():view右边相对于父控件距离</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>View绘制流程</li>\n</ol>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/customview.jpg\" alt=\"viewhuizhi\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、常见View继承关系\"><a href=\"#一、常见View继承关系\" class=\"headerlink\" title=\"一、常见View继承关系\"></a>一、常见View继承关系</h4><ul>\n<li><p>如下图</p>\n<p>  <img src=\"http://ot29getcp.bkt.clouddn.com/view%E7%BB%A7%E6%89%BF.png\" alt=\"view\"></p>\n</li>\n</ul>\n<p>可以看到所有的控件都是最终继承自View。布局控件都是直接或间接继承自ViewGroup.</p>\n<h4 id=\"二、自定义控件\"><a href=\"#二、自定义控件\" class=\"headerlink\" title=\"二、自定义控件\"></a>二、自定义控件</h4><ul>\n<li><p>大致可分为两大类：</p>\n<ul>\n<li>组合或继承基本控件TextView、ImageView等，加上自定义的内容。</li>\n<li>继承自View</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>组合控件或继承基本控件</p>\n<p> 像这种自定义的控件，很好理解，就是在原有的基础上，自定义的进行组合或者添加新的功能属性等。自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或Layout,包含子View</p>\n<p> 举个简单的例子：ToolBar</p>\n<p> 在Android 5.0推出的一个新的导航控件用于取代之前的ActionBar。如果去看ToolBar的源码，就可以发现，其实就是将几种基本控件组合在一起，实现开发者的更好的可定制性。</p>\n<p> 看源码：</p>\n<p> <img src=\"http://ot29getcp.bkt.clouddn.com/images/toolbar.png\" alt=\"toolbar\"></p>\n<p> 可以看出来ToolBar组合了ActionMenuView、TextView、ImageButton、ImageView等。相当于一个布局文件里面加了自己自定义的控件组合而成达到自己想要的效果。</p>\n</li>\n</ol>\n<ol>\n<li><p>自定义View</p>\n<p>自定义View一般是没有需要的View,需要自己实现，继承自View、surfaceView或者其他的View,不包含子View</p>\n<ul>\n<li><p>(1)屏幕坐标系</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></p>\n<p>手机屏幕的坐标系如图所示，是以手机屏幕左上顶角为坐标原点。</p>\n</li>\n<li>（2）View坐标系</li>\n</ul>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/viewzuobiao.png\" alt=\"viewzuobiao\"></p>\n<p>View坐标系都是相对父控件而言来确定位置的。</p>\n<ul>\n<li>getTop():view顶部相对于父控件顶部距离</li>\n<li>getBottom():view底部相对于父控件顶部距离</li>\n<li>getLeft():view左边相对于父控件距离</li>\n<li>getRight():view右边相对于父控件距离</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>View绘制流程</li>\n</ol>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/customview.jpg\" alt=\"viewhuizhi\"></p>\n"},{"title":"设计模式之路（1）-简单工厂模式","date":"2017-07-17T04:48:01.000Z","_content":"\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","source":"_posts/设计模式之路（1）-简单工厂模式.md","raw":"---\ntitle: 设计模式之路（1）-简单工厂模式\ndate: 2017-07-17 12:48:01\ntags: [设计模式]\n---\n\n ---\n如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。\n\n ---\n\n#### 一、简单工厂模式的概念\n简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。\n\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。\n\nshow me code~\n\n举个栗子：\n\n抽象产品--汽车，汽车有很多品牌：Audi、Benz、BMW···\n\n现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~\n\n\t\tBenz benz = new Benz();\n\t\tbenz.addGPS();\n\t\tbenz.addRecodes();\n\t\tbenz.addWheels();\n\t\tbenz.drive();\n\t\t\n那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，\n\n\t\tAudi audi = new Audi();\n\t\taudi.addGPS();\n\t\taudi.addRecodes();\n\t\taudi.addWheels();\n\t\taudi.drive();\n\t\t\n\t\t\n问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。\n\n所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。\n\n工厂类：\n\n\tpublic class CarFactory{\n\t\tpublic Benz createBenz(int type){\n\t\t\tswitch(type){\n\t\t\t\tcase 200 :\n\t\t\t\t\treturn new Benz200();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 260 :\n\t\t\t\t\treturn new Benz260();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 300 :\n\t\t\t\t\treturn new Benz300();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n客户类：\n\n\tpublic class Customer{\n\t\tpublic static viod main(String[] args){\n\t\t\tCarFactory carFactory = new CarFactory();\n\t\t\tBenz benz200 = carFactory.createBenz(200);//客户定制车型号\n\t\t\tbenz200.drive();//客户开走\n\t\t}\n\t}\n\t\n#### 二、简单工厂模式中的几个角色\n\n在简单工厂模式中包含如下几个角色：\n\n* Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n\n* Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n\n* ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n\n在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n\n","slug":"设计模式之路（1）-简单工厂模式","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphw001mv7c033rnznbl","content":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>如果对面向对象还不太熟悉，建议先把面向对象的概念过一遍比较好。</p>\n<hr>\n<h4 id=\"一、简单工厂模式的概念\"><a href=\"#一、简单工厂模式的概念\" class=\"headerlink\" title=\"一、简单工厂模式的概念\"></a>一、简单工厂模式的概念</h4><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p>\n<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>\n<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>\n<p>show me code~</p>\n<p>举个栗子：</p>\n<p>抽象产品–汽车，汽车有很多品牌：Audi、Benz、BMW···</p>\n<p>现在有一个客户想开Benz品牌的车，那么最直接的做法就是创建Benz汽车的实例，然后开走~</p>\n<pre><code>Benz benz = new Benz();\nbenz.addGPS();\nbenz.addRecodes();\nbenz.addWheels();\nbenz.drive();\n</code></pre><p>那么再来一个客户，想开Audi品牌的车，那么我们和之前一样，</p>\n<pre><code>Audi audi = new Audi();\naudi.addGPS();\naudi.addRecodes();\naudi.addWheels();\naudi.drive();\n</code></pre><p>问题就出现了，客户和汽车的创建耦合在一起了，客户是不需要知道的创建的细节的。</p>\n<p>所以为了降低耦合，就可以把这些都放到工厂里面去做，客户只需要告诉工厂汽车的品牌和型号就可以了，所有细节交给工厂完成就可以了。这就是简单工厂模式。</p>\n<p>工厂类：</p>\n<pre><code>public class CarFactory{\n    public Benz createBenz(int type){\n        switch(type){\n            case 200 :\n                return new Benz200();\n                break;\n            case 260 :\n                return new Benz260();\n                break;\n            case 300 :\n                return new Benz300();\n                break;\n            default:\n                break;\n        }\n    }\n}\n</code></pre><p>客户类：</p>\n<pre><code>public class Customer{\n    public static viod main(String[] args){\n        CarFactory carFactory = new CarFactory();\n        Benz benz200 = carFactory.createBenz(200);//客户定制车型号\n        benz200.drive();//客户开走\n    }\n}\n</code></pre><h4 id=\"二、简单工厂模式中的几个角色\"><a href=\"#二、简单工厂模式中的几个角色\" class=\"headerlink\" title=\"二、简单工厂模式中的几个角色\"></a>二、简单工厂模式中的几个角色</h4><p>在简单工厂模式中包含如下几个角色：</p>\n<ul>\n<li><p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>\n</li>\n<li><p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>\n</li>\n<li><p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>\n</li>\n</ul>\n<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>\n"},{"title":"设计模式之路（2）单一职责原则","date":"2017-07-18T07:06:41.000Z","_content":"\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","source":"_posts/设计模式之路（2）单一职责原则.md","raw":"---\ntitle: 设计模式之路（2）单一职责原则\ndate: 2017-07-18 15:06:41\ntags: [设计模式]\n---\n\n### 一、单一职责原则基本定义\nSingle Responsibility Principle，缩写是SRP。\n\n定义：There should never be more than one reason for a class to change.\n\n即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n\n单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n\n### 二、由来\nSRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：\n\n* 职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n* 单一：只有一个引起类改变的原因\n\n\n在Martin的书中分析单一职责带来的好处是：\n\n* 可以分离变化\n* 减少改动\n* 减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。\n\n但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。\n\n### 三、小结\n\n  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。\n\n总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。\n\n\n","slug":"设计模式之路（2）单一职责原则","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjphz001ov7c0gllnc35l","content":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、单一职责原则基本定义\"><a href=\"#一、单一职责原则基本定义\" class=\"headerlink\" title=\"一、单一职责原则基本定义\"></a>一、单一职责原则基本定义</h3><p>Single Responsibility Principle，缩写是SRP。</p>\n<p>定义：There should never be more than one reason for a class to change.</p>\n<p>即单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。</p>\n<p>单一职责原则定义如下： 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>\n<h3 id=\"二、由来\"><a href=\"#二、由来\" class=\"headerlink\" title=\"二、由来\"></a>二、由来</h3><p>SRP这一概念，由Robot C. Martin在其广泛流行的经典著作《Agile Software Development, Principles, Patterns, and Practices》中的面向对象设计原则部分引入。此原则有两个约束：</p>\n<ul>\n<li><p>职责：什么是职责？我之前认为是一个类要实现的功能，或者提供的服务，从面向对象的角度说是内聚性。从这个角度去理解也可以，但是，功能的大小怎么定义是个难题，什么样的功能放在一起是好的内聚也不好定义。我们知道，面向对象设计更多考虑变化因素可能导致系统的改变，从而提供更灵活应变的设计。所以Robert C. Martin从变化这个角度对职责的定义为：“变化的原因（a reason for change）”，理解为，如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n<li><p>单一：只有一个引起类改变的原因</p>\n</li>\n</ul>\n<p>在Martin的书中分析单一职责带来的好处是：</p>\n<ul>\n<li>可以分离变化</li>\n<li>减少改动</li>\n<li>减少不必要的依赖，从而在发生变化时减少设计所遭受的破坏。</li>\n</ul>\n<p>但更多的是从类和接口的角度去分析。然而SRP对每一个程序模块都是适用的，比如小到代码块，函数，大到包级别，组件级别。</p>\n<h3 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h3><p>  SRP是一把双刃剑，如果做到极端，没有合理的权衡，对于类来说就有可能形成爆炸。类爆炸的可能性有，职责没有划分清楚而形成过多的类；因为业务的需要，需求的复杂性带来的。不论其产生的原因，过多的类，如果没有好的组织方式，杂乱无章，势必带来维护的复杂性。所谓维护的复杂性，在于代码的可读性，以及重构的高成本。一种可行的解决方案就是利用模式来管理，定义清晰的层次结构。比如利用工厂，模板方法等等。</p>\n<p>总结起来，对于SRP，正如Robert C. Martin所说，是一起面向对象设计中最简单的原则之一，也是最难正确应用之一。它是其它原则的基础，比如OCP（Open for extension, Close for modification）。但是，万变不离其宗，本质是抽象变化，解除耦合，让设计出来的系统可读性好，可维护性好，可扩展性好。合理的职责划定带来清晰代码单元结构，如果设计不合理则适得其反，导致代码难以读懂，维护成本增加。</p>\n"},{"title":"设计模式之路（3）开放-封闭原则","date":"2017-07-18T08:24:08.000Z","_content":"\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","source":"_posts/设计模式之路（3）开放-封闭原则.md","raw":"---\ntitle: 设计模式之路（3）开放-封闭原则\ndate: 2017-07-18 16:24:08\ntags: [设计模式]\n---\n\n### 一、具体解释\n\n开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。\n\n也就是，对于扩展是开放的（Open for extension）\n对于更改是封闭的（Closed for modification）\n\n### 二、核心思想\n\n关于开放封闭原则，其核心的思想是：\n\n软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。\n\n因此，开放封闭原则主要体现在两个方面：\n\n* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n\n* 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。\n","slug":"设计模式之路（3）开放-封闭原则","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpi0001qv7c0s2zjz1xv","content":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、具体解释\"><a href=\"#一、具体解释\" class=\"headerlink\" title=\"一、具体解释\"></a>一、具体解释</h3><p>开放-封闭原则，是说软件实体（类、模块】函数等等）应该可以扩展，但是不可以修改。</p>\n<p>也就是，对于扩展是开放的（Open for extension）<br>对于更改是封闭的（Closed for modification）</p>\n<h3 id=\"二、核心思想\"><a href=\"#二、核心思想\" class=\"headerlink\" title=\"二、核心思想\"></a>二、核心思想</h3><p>关于开放封闭原则，其核心的思想是：</p>\n<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。</p>\n<p>因此，开放封闭原则主要体现在两个方面：</p>\n<ul>\n<li><p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>\n</li>\n<li><p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</p>\n</li>\n</ul>\n"},{"title":"设计模式之路（4）装饰者模式","date":"2017-07-19T02:20:23.000Z","author":"Neil Liu","_content":"\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","source":"_posts/设计模式之路（4）装饰者模式.md","raw":"---\ntitle: 设计模式之路（4）装饰者模式\ndate: 2017-07-19 10:20:23\ntags: [设计模式]\nauthor: Neil Liu\n---\n\n#### 一、定义\n装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。\n\n#### 二、特性\n\n1. 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n2. 装饰对象包含一个真实对象的引用（reference）\n3. 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n4. 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n#### 三、结构\n\n![“装饰者”](http://ot29getcp.bkt.clouddn.com/images/decorator.png)\n\n1. 抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n2. 具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。\n3. 装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。\n4. 具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。\n\n举个栗子：\n\n(1)在Java设计中\n\n![“Java装饰者”](http://ot29getcp.bkt.clouddn.com/images/javadecorator)\n\n(2)在Android中\n\n![“Android装饰者”](http://ot29getcp.bkt.clouddn.com/androiddecorator)\n\n#### 四、小结\n\n装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。\n同时有几个要点需要提一下：\n\n* 继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；\n* 在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；\n* 组合和委托可用于在运行时动态加上新的行为；\n* 装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；\n* 可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；\n* 同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。\n* 装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；\n* 缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。","slug":"设计模式之路（4）装饰者模式","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpi2001rv7c0rxczfxnw","content":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一、定义\"><a href=\"#一、定义\" class=\"headerlink\" title=\"一、定义\"></a>一、定义</h4><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>\n<h4 id=\"二、特性\"><a href=\"#二、特性\" class=\"headerlink\" title=\"二、特性\"></a>二、特性</h4><ol>\n<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>\n<li>装饰对象包含一个真实对象的引用（reference）</li>\n<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>\n<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>\n</ol>\n<h4 id=\"三、结构\"><a href=\"#三、结构\" class=\"headerlink\" title=\"三、结构\"></a>三、结构</h4><p><img src=\"http://ot29getcp.bkt.clouddn.com/images/decorator.png\" alt=\"“装饰者”\"></p>\n<ol>\n<li>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</li>\n<li>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>\n<li>具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</li>\n</ol>\n<p>举个栗子：</p>\n<p>(1)在Java设计中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/javadecorator\" alt=\"“Java装饰者”\"></p>\n<p>(2)在Android中</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/androiddecorator\" alt=\"“Android装饰者”\"></p>\n<h4 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h4><p>装饰者模式和代理模式有点类似，很多时候需要仔细辨别，容易混淆，倒不是说会把代理模式看成装饰者模式，而是会把装饰者模式看作代理模式。区分一下，装饰者模式的目的是透明地为客户端对象扩展功能，是继承关系的一种替代方案，而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰者模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。<br>同时有几个要点需要提一下：</p>\n<ul>\n<li>继承属于扩展形式之一，但不一定是达到弹性设计的最佳方案；</li>\n<li>在我们的设计，应该尽量对修改关闭，对扩展开发，无需修改现有代码；</li>\n<li>组合和委托可用于在运行时动态加上新的行为；</li>\n<li>装饰者可以在被装饰者行为的前后根据实际情况加上自己的行为，必要时也可以将被装饰者行为给替换掉；</li>\n<li>可以用无数个装饰者包装一个组件，也就是说，装饰者 A 包装了被装饰者 B ，装饰者 C 再包装装饰者 A，根据实际情况这种行为可以累加到多层，通俗讲就是套上多层外壳；</li>\n<li>同时，被装饰者也可以存在多个，也就是说 ConcreteComponent 这个角色也可以是多个的。</li>\n<li>装饰者模式的优点就是它的特点：可以在运行时动态，透明的为一个组件扩展功能，比继承更加灵活；</li>\n<li>缺点也很明显：它会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li>\n</ul>\n"},{"title":"设计模式之路（5）代理模式","date":"2017-07-24T07:06:52.000Z","_content":"\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","source":"_posts/设计模式之路（5）代理模式.md","raw":"---\ntitle: 设计模式之路（5）代理模式\ndate: 2017-07-24 15:06:52\ntags: [设计模式]\n---\n\n### 一、基本概念\n\n简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。\n\n### 二、代理模式结构图\n\n借用大话中的结构图，如下：\n\n![“代理模式”](http://ot29getcp.bkt.clouddn.com/images/proxy.png)\n\n","slug":"设计模式之路（5）代理模式","published":1,"updated":"2017-08-28T15:01:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpi4001uv7c06pzdxdox","content":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h3><p>简单来说，代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p>\n<h3 id=\"二、代理模式结构图\"><a href=\"#二、代理模式结构图\" class=\"headerlink\" title=\"二、代理模式结构图\"></a>二、代理模式结构图</h3><p>借用大话中的结构图，如下：</p>\n<p><img src=\"http://ot29getcp.bkt.clouddn.com/images/proxy.png\" alt=\"“代理模式”\"></p>\n"},{"title":"设计模式之路（6）依赖倒转原则","date":"2017-09-10T14:55:38.000Z","_content":"\n\n### 依赖倒置原则\n\n--\n#### 概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n\n--\n\n* 要针对接口编程，不要针对实现编程。\n\n\t* 针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n\t* 不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n### 一、依赖倒置原则：\n\n#### A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\n\n#### B.抽象不应该依赖细节。细节应该依赖抽象。\n\n\n### 二、为什么要依赖倒置\n\n传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。\n\n### 三、总结\n\n一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。\n\n\n\n","source":"_posts/设计模式之路（6）依赖倒转原则.md","raw":"---\ntitle: 设计模式之路（6）依赖倒转原则\ndate: 2017-09-10 22:55:38\ntags: [设计模式]\n---\n\n\n### 依赖倒置原则\n\n--\n#### 概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n\n--\n\n* 要针对接口编程，不要针对实现编程。\n\n\t* 针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n\t* 不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。\n\n### 一、依赖倒置原则：\n\n#### A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\n\n#### B.抽象不应该依赖细节。细节应该依赖抽象。\n\n\n### 二、为什么要依赖倒置\n\n传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。\n\n### 三、总结\n\n一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。\n\n\n\n","slug":"设计模式之路（6）依赖倒转原则","published":1,"updated":"2017-09-10T15:20:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpi4001wv7c01dh0m4e7","content":"<h3 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h3><p>–</p>\n<h4 id=\"概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"><a href=\"#概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\" class=\"headerlink\" title=\"概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"></a>概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</h4><p>–</p>\n<ul>\n<li><p>要针对接口编程，不要针对实现编程。</p>\n<ul>\n<li><p>针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n<li><p>不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、依赖倒置原则：\"><a href=\"#一、依赖倒置原则：\" class=\"headerlink\" title=\"一、依赖倒置原则：\"></a>一、依赖倒置原则：</h3><h4 id=\"A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\"><a href=\"#A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\" class=\"headerlink\" title=\"A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\"></a>A.高层模块不应该依赖低层模块。两个都应该依赖抽象。</h4><h4 id=\"B-抽象不应该依赖细节。细节应该依赖抽象。\"><a href=\"#B-抽象不应该依赖细节。细节应该依赖抽象。\" class=\"headerlink\" title=\"B.抽象不应该依赖细节。细节应该依赖抽象。\"></a>B.抽象不应该依赖细节。细节应该依赖抽象。</h4><h3 id=\"二、为什么要依赖倒置\"><a href=\"#二、为什么要依赖倒置\" class=\"headerlink\" title=\"二、为什么要依赖倒置\"></a>二、为什么要依赖倒置</h3><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h3><p>–</p>\n<h4 id=\"概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"><a href=\"#概述：依赖倒置原则（Dependence-Inversion-Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\" class=\"headerlink\" title=\"概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\"></a>概述：依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</h4><p>–</p>\n<ul>\n<li><p>要针对接口编程，不要针对实现编程。</p>\n<ul>\n<li><p>针对接口编程的意思就是说，应当使用Java接口和抽象Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n<li><p>不要针对实现编程的意思就是说，不应当使用具体Java类进行变量的类型声明、参量的类型声明、方法的返回类型声明，以及数据类型的转换等。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、依赖倒置原则：\"><a href=\"#一、依赖倒置原则：\" class=\"headerlink\" title=\"一、依赖倒置原则：\"></a>一、依赖倒置原则：</h3><h4 id=\"A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\"><a href=\"#A-高层模块不应该依赖低层模块。两个都应该依赖抽象。\" class=\"headerlink\" title=\"A.高层模块不应该依赖低层模块。两个都应该依赖抽象。\"></a>A.高层模块不应该依赖低层模块。两个都应该依赖抽象。</h4><h4 id=\"B-抽象不应该依赖细节。细节应该依赖抽象。\"><a href=\"#B-抽象不应该依赖细节。细节应该依赖抽象。\" class=\"headerlink\" title=\"B.抽象不应该依赖细节。细节应该依赖抽象。\"></a>B.抽象不应该依赖细节。细节应该依赖抽象。</h4><h3 id=\"二、为什么要依赖倒置\"><a href=\"#二、为什么要依赖倒置\" class=\"headerlink\" title=\"二、为什么要依赖倒置\"></a>二、为什么要依赖倒置</h3><p>传统的过程性系统的设计方法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒置原则就是要把这个错误的依赖关系倒转过来。</p>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><p>一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过子程序库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层模块独立于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。</p>\n"},{"title":"设计模式之路（7）里氏替换原则","date":"2017-09-11T14:49:50.000Z","_content":"\n里氏替换原则（LSP）\n\n#### 一、基本概念：\n\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。\n\n#### 二、例证\n\n只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。\n\n举个例子：\n\n小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。\n\t\n\tAnimal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\t\n\tanimal.eat();\n\tanimal.drink();\n\t","source":"_posts/设计模式之路（7）里氏替换原则.md","raw":"---\ntitle: 设计模式之路（7）里氏替换原则\ndate: 2017-09-11 22:49:50\ntags: [设计模式]\n---\n\n里氏替换原则（LSP）\n\n#### 一、基本概念：\n\n一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。\n\n#### 二、例证\n\n只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。\n\n举个例子：\n\n小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。\n\t\n\tAnimal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\t\n\tanimal.eat();\n\tanimal.drink();\n\t","slug":"设计模式之路（7）里氏替换原则","published":1,"updated":"2017-09-11T15:18:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcxjpmn0036v7c0mi39q963","content":"<p>里氏替换原则（LSP）</p>\n<h4 id=\"一、基本概念：\"><a href=\"#一、基本概念：\" class=\"headerlink\" title=\"一、基本概念：\"></a>一、基本概念：</h4><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。</p>\n<h4 id=\"二、例证\"><a href=\"#二、例证\" class=\"headerlink\" title=\"二、例证\"></a>二、例证</h4><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。</p>\n<p>举个例子：</p>\n<p>小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。</p>\n<pre><code>Animal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\nanimal.eat();\nanimal.drink();\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>里氏替换原则（LSP）</p>\n<h4 id=\"一、基本概念：\"><a href=\"#一、基本概念：\" class=\"headerlink\" title=\"一、基本概念：\"></a>一、基本概念：</h4><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的 区别，也就是说，在软件程序里面，把父类都替换成它的子类，程序的行为没有变化。简单地说，子类型必须能够替换掉它们的父类型。</p>\n<h4 id=\"二、例证\"><a href=\"#二、例证\" class=\"headerlink\" title=\"二、例证\"></a>二、例证</h4><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为特性。</p>\n<p>举个例子：</p>\n<p>小狗具备动物的基本行为：吃、喝等行为，当需要小猫、小猪也有类似的行为时，由于它们都是继承动物，所以只需要更改实例化的地方，程序的其他地方不要更改。</p>\n<pre><code>Animal animal = new Cat();//只需要修改实例化即可，如：new Dog()\n\nanimal.eat();\nanimal.drink();\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjdcxjpgj0000v7c0x05fm00v","tag_id":"cjdcxjpgp0002v7c02bqnazfk","_id":"cjdcxjpgv0007v7c0w7646nwt"},{"post_id":"cjdcxjpgn0001v7c0ugo0yxsh","tag_id":"cjdcxjpgu0006v7c0i3es3vyd","_id":"cjdcxjph1000cv7c0t9fndaod"},{"post_id":"cjdcxjpgq0003v7c0bnyqhsa3","tag_id":"cjdcxjph0000av7c0uuyfsl2j","_id":"cjdcxjph4000gv7c04ia3lahq"},{"post_id":"cjdcxjpgr0004v7c0fho4w1q0","tag_id":"cjdcxjph2000ev7c0llbcle94","_id":"cjdcxjph8000kv7c0kcf7xn7g"},{"post_id":"cjdcxjpgt0005v7c05zraynvn","tag_id":"cjdcxjph0000av7c0uuyfsl2j","_id":"cjdcxjph9000ov7c0fm0x23fz"},{"post_id":"cjdcxjpgv0008v7c0fqyv3yri","tag_id":"cjdcxjph9000mv7c0m083v7fp","_id":"cjdcxjphe000vv7c0qujqyt47"},{"post_id":"cjdcxjpgv0008v7c0fqyv3yri","tag_id":"cjdcxjph0000av7c0uuyfsl2j","_id":"cjdcxjphf000xv7c0nqkfxrf5"},{"post_id":"cjdcxjpgx0009v7c0d0eqekdk","tag_id":"cjdcxjphe000uv7c0rk4360zp","_id":"cjdcxjphi0014v7c0he5z63ll"},{"post_id":"cjdcxjpgx0009v7c0d0eqekdk","tag_id":"cjdcxjphf000zv7c0w34hzthx","_id":"cjdcxjphj0016v7c0xm0tj5gt"},{"post_id":"cjdcxjph0000bv7c01tlxy0f8","tag_id":"cjdcxjphg0012v7c0kig7cmef","_id":"cjdcxjphk0019v7c0q8li35cc"},{"post_id":"cjdcxjph3000fv7c0obcpq65h","tag_id":"cjdcxjphj0017v7c0cfrkua20","_id":"cjdcxjphn001dv7c0bxzkw201"},{"post_id":"cjdcxjphn001ev7c0u8wkfpe2","tag_id":"cjdcxjphj0017v7c0cfrkua20","_id":"cjdcxjphq001hv7c0lyc9fbc9"},{"post_id":"cjdcxjph4000hv7c05vmco8xz","tag_id":"cjdcxjphe000uv7c0rk4360zp","_id":"cjdcxjphw001lv7c0wus8az3s"},{"post_id":"cjdcxjph4000hv7c05vmco8xz","tag_id":"cjdcxjphf000zv7c0w34hzthx","_id":"cjdcxjphz001nv7c0wdqs90kv"},{"post_id":"cjdcxjph6000jv7c07arxkyve","tag_id":"cjdcxjphe000uv7c0rk4360zp","_id":"cjdcxjpi3001tv7c0ue5b4fuc"},{"post_id":"cjdcxjph6000jv7c07arxkyve","tag_id":"cjdcxjphf000zv7c0w34hzthx","_id":"cjdcxjpi4001vv7c0sf7ifyti"},{"post_id":"cjdcxjph8000lv7c0lum7fokq","tag_id":"cjdcxjphe000uv7c0rk4360zp","_id":"cjdcxjpi6001zv7c04du6ftsy"},{"post_id":"cjdcxjph8000lv7c0lum7fokq","tag_id":"cjdcxjphf000zv7c0w34hzthx","_id":"cjdcxjpi60020v7c0uvyq380w"},{"post_id":"cjdcxjph9000nv7c0gcr7oesv","tag_id":"cjdcxjpi6001yv7c0wy51fh0w","_id":"cjdcxjpi60022v7c0ce97yo7g"},{"post_id":"cjdcxjpha000pv7c04jkxkm0y","tag_id":"cjdcxjpi60021v7c0tj8ulbuq","_id":"cjdcxjpi60024v7c0pweznzb2"},{"post_id":"cjdcxjphc000qv7c0nw9ceot1","tag_id":"cjdcxjpi60023v7c0g2mx7h9m","_id":"cjdcxjpi70026v7c0ceaesyiv"},{"post_id":"cjdcxjphd000sv7c0kc2ynrtb","tag_id":"cjdcxjpi60023v7c0g2mx7h9m","_id":"cjdcxjpi70028v7c0e4oxur03"},{"post_id":"cjdcxjphe000tv7c0dyiqt0x4","tag_id":"cjdcxjpi60023v7c0g2mx7h9m","_id":"cjdcxjpi8002av7c0izl23z45"},{"post_id":"cjdcxjphe000wv7c052h8w1hh","tag_id":"cjdcxjpi60023v7c0g2mx7h9m","_id":"cjdcxjpi8002cv7c0w2q4hync"},{"post_id":"cjdcxjphf000yv7c01uge6yic","tag_id":"cjdcxjpi8002bv7c0x8jn6q3c","_id":"cjdcxjpi8002ev7c0gzwejyqb"},{"post_id":"cjdcxjphf0010v7c0k3udnoy3","tag_id":"cjdcxjpi8002dv7c0yy9ejrve","_id":"cjdcxjpi9002gv7c0y662f0eq"},{"post_id":"cjdcxjphg0011v7c0tkdhe9az","tag_id":"cjdcxjpi8002dv7c0yy9ejrve","_id":"cjdcxjpi9002iv7c0knsk1kfh"},{"post_id":"cjdcxjphh0013v7c0s88w52mh","tag_id":"cjdcxjpi8002dv7c0yy9ejrve","_id":"cjdcxjpi9002kv7c0v9ye3j0m"},{"post_id":"cjdcxjphj0018v7c02m9plleb","tag_id":"cjdcxjpi8002dv7c0yy9ejrve","_id":"cjdcxjpia002mv7c0yn3jm85u"},{"post_id":"cjdcxjphl001bv7c0anhdrjvo","tag_id":"cjdcxjpia002lv7c00jm1zmmi","_id":"cjdcxjpia002ov7c0nzwkd825"},{"post_id":"cjdcxjpho001fv7c0kjk2n7sl","tag_id":"cjdcxjpia002nv7c0kx7szhn0","_id":"cjdcxjpia002qv7c0az69f096"},{"post_id":"cjdcxjphr001iv7c0m29t1k5d","tag_id":"cjdcxjpia002pv7c0uue0wnq7","_id":"cjdcxjpib002sv7c0l0im259j"},{"post_id":"cjdcxjphu001jv7c02xjspsqo","tag_id":"cjdcxjpia002pv7c0uue0wnq7","_id":"cjdcxjpib002uv7c0l3c9b2da"},{"post_id":"cjdcxjphw001mv7c033rnznbl","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpic002wv7c0m9td0xg9"},{"post_id":"cjdcxjphz001ov7c0gllnc35l","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpid002yv7c01yzwn9d5"},{"post_id":"cjdcxjpi0001qv7c0s2zjz1xv","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpie0030v7c03nl7oz01"},{"post_id":"cjdcxjpi2001rv7c0rxczfxnw","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpie0032v7c082xs7fgd"},{"post_id":"cjdcxjpi4001uv7c06pzdxdox","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpif0034v7c0cz6b0fyn"},{"post_id":"cjdcxjpi4001wv7c01dh0m4e7","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpif0035v7c0jw3oelhb"},{"post_id":"cjdcxjpmn0036v7c0mi39q963","tag_id":"cjdcxjpib002tv7c0kdoyz267","_id":"cjdcxjpmp0039v7c0ik428x5k"}],"Tag":[{"name":"ADB","_id":"cjdcxjpgp0002v7c02bqnazfk"},{"name":"Gradle","_id":"cjdcxjpgu0006v7c0i3es3vyd"},{"name":"Android","_id":"cjdcxjph0000av7c0uuyfsl2j"},{"name":"View事件分发机制","_id":"cjdcxjph2000ev7c0llbcle94"},{"name":"Bugsnag","_id":"cjdcxjph9000mv7c0m083v7fp"},{"name":"hexo","_id":"cjdcxjphe000uv7c0rk4360zp"},{"name":"github","_id":"cjdcxjphf000zv7c0w34hzthx"},{"name":"Glide","_id":"cjdcxjphg0012v7c0kig7cmef"},{"name":"HTTP","_id":"cjdcxjphj0017v7c0cfrkua20"},{"name":"MarkDown","_id":"cjdcxjpi6001yv7c0wy51fh0w"},{"name":"Java","_id":"cjdcxjpi60021v7c0tj8ulbuq"},{"name":"OkHttp3","_id":"cjdcxjpi60023v7c0g2mx7h9m"},{"name":"PackageManager","_id":"cjdcxjpi8002bv7c0x8jn6q3c"},{"name":"RxJava","_id":"cjdcxjpi8002dv7c0yy9ejrve"},{"name":"Book推荐","_id":"cjdcxjpia002lv7c00jm1zmmi"},{"name":"Android进阶","_id":"cjdcxjpia002nv7c0kx7szhn0"},{"name":"自定义View","_id":"cjdcxjpia002pv7c0uue0wnq7"},{"name":"设计模式","_id":"cjdcxjpib002tv7c0kdoyz267"}]}}